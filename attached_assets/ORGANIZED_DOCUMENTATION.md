# FlipMyFile - Organized Documentation

This document contains all markdown documentation from the FlipMyFile project, organized by category for easier reference.

Last Updated: Sat May  3 03:42:14 PDT 2025

## Document Categories

1. [Project Overview](#project-overview)
2. [User Guides](#user-guides)
3. [Developer Guides](#developer-guides)
4. [Technical Documentation](#technical-documentation)
5. [Deployment & Operations](#deployment-operations)
6. [Architecture & Design](#architecture-design)
7. [Format Support Documentation](#format-support)
8. [Monorepo Structure](#monorepo-structure)
9. [Tool & Script Documentation](#tools-scripts)
10. [Miscellaneous](#miscellaneous)

---

## Project Overview {#project-overview}

Documentation providing high-level information about the FlipMyFile project.

| Document | Path | Description |
|----------|------|-------------|
| [BACKUP_README.md](formatflip_complete/scripts/BACKUP_README.md) | formatflip_complete/scripts | HEICFlip Backup System |
| [README.md](formatflip_complete/scripts/enhanced-variant-generator/README.md) | formatflip_complete/scripts/enhanced-variant-generator | HEICFlip Format Transformation System |
| [README.md](deploy_tools/README.md) | deploy_tools | Deployment Guide for FlipMyFile |
| [README.md](meta/tools/README.md) | meta/tools | HEICFlip Project Tools Directory |
| [README.md](meta/tools/project/README.md) | meta/tools/project | Project Management Scripts |
| [README.md](meta/tools/github/README.md) | meta/tools/github | GitHub Scripts |
| [README.md](meta/tools/deployment/README.md) | meta/tools/deployment | Deployment Scripts |
| [README.md](meta/tools/maintenance/README.md) | meta/tools/maintenance | Maintenance Scripts |
| [README.md](meta/tools/backup/README.md) | meta/tools/backup | Backup System Scripts |
| [README.md](meta/variants/README.md) | meta/variants | Converter Variants |
| [[HEICFLIP-100]_PROJECT_OVERVIEW.md](meta/docs/[HEICFLIP-100]_PROJECT_OVERVIEW.md) | meta/docs | [HEICFLIP-100] Project Overview |
| [overview.md](meta/docs/overview.md) | meta/docs | HEICFlip Project Overview |
| [[HEICFLIP-DOC]_PROJECT_OVERVIEW.md](meta/docs/[HEICFLIP-DOC]_PROJECT_OVERVIEW.md) | meta/docs | [HEICFLIP-DOC] Project Overview |
| [README.md](/Users/cameronbrooks/Downloads/FlipMyFIle/README.md) | /Users/cameronbrooks/Downloads/FlipMyFIle | FlipMyFile: Comprehensive Format Transformation System |
| [BACKUP_README.md](scripts/BACKUP_README.md) | scripts | HEICFlip Backup System |
| [README.md](scripts/deployment/enhanced-variant-generator/README.md) | scripts/deployment/enhanced-variant-generator | HEICFlip Format Transformation System |
| [README.md](.github/workflows/README.md) | .github/workflows | No workflows |

---

## User Guides {#user-guides}

Guides for end users of FlipMyFile.

| Document | Path | Description |
|----------|------|-------------|
| [DEPLOY_GUIDE.md](/Users/cameronbrooks/Downloads/FlipMyFIle/DEPLOY_GUIDE.md) | /Users/cameronbrooks/Downloads/FlipMyFIle | Deployment Guide for FlipMyFile |
| [[HEICFLIP-050]_NAME_CHANGE_GUIDE.md](meta/docs/[HEICFLIP-050]_NAME_CHANGE_GUIDE.md) | meta/docs | [HEICFLIP-050] Project Name Change Guide |
| [AI_GUIDE.md](docs/AI_GUIDE.md) | docs | HEICFlip AI Guide |
| [[HEICFLIP-001]_AI_INSTRUCTIONS.md](docs/[HEICFLIP-001]_AI_INSTRUCTIONS.md) | docs | [HEICFLIP-001] AI Instructions |
| [[HEICFLIP-000]_AI_NAVIGATION_INDEX.md](docs/[HEICFLIP-000]_AI_NAVIGATION_INDEX.md) | docs | [HEICFLIP-000] Master Navigation Index |

---

## Developer Guides {#developer-guides}

Guides for developers working on the FlipMyFile project.

| Document | Path | Description |
|----------|------|-------------|
| [RESTORE_INSTRUCTIONS.md](docs/RESTORE_INSTRUCTIONS.md) | docs | Simple Restore System for HEICFlip |
| [TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md) | docs | TROUBLESHOOTING Guide for HEICFlip |
| [[HEICFLIP-001]_AI_INSTRUCTIONS.md](docs/[HEICFLIP-001]_AI_INSTRUCTIONS.md) | docs | [HEICFLIP-001] AI Instructions |
| [GITHUB_INSTRUCTIONS.md](docs/GITHUB_INSTRUCTIONS.md) | docs | Instructions for Pushing to GitHub |
| [AGENT_INSTRUCTIONS.md](docs/AGENT_INSTRUCTIONS.md) | docs | Agent Instructions for HEICFlip Project |
| [github_summary.md](github_tools/github_summary.md) | github_tools | FormatFlip GitHub Repository Summary |

---

## Technical Documentation {#technical-documentation}

Detailed technical documentation on FlipMyFile components and systems.

| Document | Path | Description |
|----------|------|-------------|
| [LOADERS_AND_ENCODERS.md](formatflip_complete/scripts/enhanced-variant-generator/LOADERS_AND_ENCODERS.md) | formatflip_complete/scripts/enhanced-variant-generator | Loaders and Encoders System |
| [TRANSFORMER_COMPARISON.md](formatflip_complete/scripts/enhanced-variant-generator/TRANSFORMER_COMPARISON.md) | formatflip_complete/scripts/enhanced-variant-generator | AST vs Text-Based Transformer Comparison |
| [conversion-process.md](meta/docs/patterns/conversion-process.md) | meta/docs/patterns | Image Conversion Process |
| [browser-processing.md](meta/docs/decisions/browser-processing.md) | meta/docs/decisions | Browser-based Processing Decision |
| [LOADERS_AND_ENCODERS.md](scripts/deployment/enhanced-variant-generator/LOADERS_AND_ENCODERS.md) | scripts/deployment/enhanced-variant-generator | Loaders and Encoders System |
| [TRANSFORMER_COMPARISON.md](scripts/deployment/enhanced-variant-generator/TRANSFORMER_COMPARISON.md) | scripts/deployment/enhanced-variant-generator | AST vs Text-Based Transformer Comparison |

---

## Deployment & Operations {#deployment-operations}

Documentation for deploying and operating FlipMyFile.

| Document | Path | Description |
|----------|------|-------------|
| [DEPLOY_GUIDE.md](/Users/cameronbrooks/Downloads/FlipMyFIle/DEPLOY_GUIDE.md) | /Users/cameronbrooks/Downloads/FlipMyFIle | Deployment Guide for FlipMyFile |
| [[HEICFLIP-603]_vercel_deployment_guide.md](meta/monorepo/[HEICFLIP-603]_vercel_deployment_guide.md) | meta/monorepo | Vercel Deployment Guide for Monorepo Variants |
| [[HEICFLIP-621]_vercel_monorepo_benefits.md](meta/monorepo/[HEICFLIP-621]_vercel_monorepo_benefits.md) | meta/monorepo | Vercel and npm Workspaces: Perfect Integration |
| [[HEICFLIP-604]_cloudflare_domain_configuration.md](meta/monorepo/[HEICFLIP-604]_cloudflare_domain_configuration.md) | meta/monorepo | CloudFlare Domain Configuration for Multiple Converters |
| [README.md](meta/tools/deployment/README.md) | meta/tools/deployment | Deployment Scripts |
| [[HEICFLIP-501]_deployment_guide.md](meta/variants/[HEICFLIP-501]_deployment_guide.md) | meta/variants | Deployment Guide for Converter Variants |
| [LOADERS_AND_ENCODERS.md](scripts/deployment/enhanced-variant-generator/LOADERS_AND_ENCODERS.md) | scripts/deployment/enhanced-variant-generator | Loaders and Encoders System |
| [TRANSFORMER_COMPARISON.md](scripts/deployment/enhanced-variant-generator/TRANSFORMER_COMPARISON.md) | scripts/deployment/enhanced-variant-generator | AST vs Text-Based Transformer Comparison |
| [README.md](scripts/deployment/enhanced-variant-generator/README.md) | scripts/deployment/enhanced-variant-generator | HEICFlip Format Transformation System |

---

## Architecture & Design {#architecture-design}

Documentation on the architecture and design of FlipMyFile.

| Document | Path | Description |
|----------|------|-------------|
| [[HEICFLIP-610]_implementation_plan.md](meta/monorepo/[HEICFLIP-610]_implementation_plan.md) | meta/monorepo | Comprehensive Monorepo Implementation Plan |
| [[HEICFLIP-700]_secrets_management.md](meta/security/[HEICFLIP-700]_secrets_management.md) | meta/security | Secure Secrets Management Guide |
| [[HEICFLIP-900]_BACKUP_SYSTEM.md](meta/docs/backup-system/[HEICFLIP-900]_BACKUP_SYSTEM.md) | meta/docs/backup-system | [HEICFLIP-900] Backup System |
| [[HEICFLIP-900]_BACKUP_SYSTEM.md](meta/docs/[HEICFLIP-900]_BACKUP_SYSTEM.md) | meta/docs | [HEICFLIP-900] Backup System Guide |

---

## Format Support Documentation {#format-support}

Documentation on file format support in FlipMyFile.

| Document | Path | Description |
|----------|------|-------------|
| [BACKUP_README.md](formatflip_complete/scripts/BACKUP_README.md) | formatflip_complete/scripts | HEICFlip Backup System |
| [LOADERS_AND_ENCODERS.md](formatflip_complete/scripts/enhanced-variant-generator/LOADERS_AND_ENCODERS.md) | formatflip_complete/scripts/enhanced-variant-generator | Loaders and Encoders System |
| [TRANSFORMER_COMPARISON.md](formatflip_complete/scripts/enhanced-variant-generator/TRANSFORMER_COMPARISON.md) | formatflip_complete/scripts/enhanced-variant-generator | AST vs Text-Based Transformer Comparison |
| [README.md](formatflip_complete/scripts/enhanced-variant-generator/README.md) | formatflip_complete/scripts/enhanced-variant-generator | HEICFlip Format Transformation System |
| [[HEICFLIP-645]_ast_transformation.md](meta/variant-creation/[HEICFLIP-645]_ast_transformation.md) | meta/variant-creation | AST-Based Code Transformation |
| [[HEICFLIP-642]_comprehensive_format_replacement.md](meta/variant-creation/[HEICFLIP-642]_comprehensive_format_replacement.md) | meta/variant-creation | Comprehensive Format Reference Replacement |
| [[HEICFLIP-644]_visual_identity_transformation.md](meta/variant-creation/[HEICFLIP-644]_visual_identity_transformation.md) | meta/variant-creation | Visual Identity Transformation System |
| [[HEICFLIP-643]_comprehensive_ui_branding_replacement.md](meta/variant-creation/[HEICFLIP-643]_comprehensive_ui_branding_replacement.md) | meta/variant-creation | Comprehensive UI and Branding Replacement |
| [[HEICFLIP-640]_dynamic_format_support.md](meta/variant-creation/[HEICFLIP-640]_dynamic_format_support.md) | meta/variant-creation | Dynamic Format Support in HEICFlip Monorepo |
| [[HEICFLIP-641]_supported_formats.md](meta/variant-creation/[HEICFLIP-641]_supported_formats.md) | meta/variant-creation | Supported Formats in HEICFlip Monorepo |
| [format_specific_pages.md](docs/format_specific_pages.md) | docs | Format-Specific Conversion Pages Documentation |
| [[HEICFLIP-644]_visual_identity_transformation.md](attached_assets/[HEICFLIP-644]_visual_identity_transformation.md) | attached_assets | Visual Identity Transformation System |

---

## Monorepo Structure {#monorepo-structure}

Documentation on the monorepo structure of FlipMyFile.

| Document | Path | Description |
|----------|------|-------------|
| [[HEICFLIP-600]_monorepo_structure.md](meta/monorepo/[HEICFLIP-600]_monorepo_structure.md) | meta/monorepo | Monorepo Structure for Conversion Tools |
| [[HEICFLIP-602]_step_by_step_implementation.md](meta/monorepo/[HEICFLIP-602]_step_by_step_implementation.md) | meta/monorepo | Comprehensive Step-by-Step Monorepo Implementation Guide |
| [[HEICFLIP-603]_vercel_deployment_guide.md](meta/monorepo/[HEICFLIP-603]_vercel_deployment_guide.md) | meta/monorepo | Vercel Deployment Guide for Monorepo Variants |
| [[HEICFLIP-605]_monorepo_sample_files.md](meta/monorepo/[HEICFLIP-605]_monorepo_sample_files.md) | meta/monorepo | Monorepo Sample Files |
| [[HEICFLIP-611]_monorepo_checklist.md](meta/monorepo/[HEICFLIP-611]_monorepo_checklist.md) | meta/monorepo | Monorepo Implementation Checklist |
| [[HEICFLIP-601]_migration_guide.md](meta/monorepo/[HEICFLIP-601]_migration_guide.md) | meta/monorepo | Migration Guide: Converting to Monorepo Structure |
| [[HEICFLIP-620]_monorepo_approach_comparison.md](meta/monorepo/[HEICFLIP-620]_monorepo_approach_comparison.md) | meta/monorepo | Monorepo Implementation Approaches: Npm Workspaces vs. Subdirectories |
| [[HEICFLIP-621]_vercel_monorepo_benefits.md](meta/monorepo/[HEICFLIP-621]_vercel_monorepo_benefits.md) | meta/monorepo | Vercel and npm Workspaces: Perfect Integration |
| [[HEICFLIP-630]_implementation_timeline.md](meta/monorepo/[HEICFLIP-630]_implementation_timeline.md) | meta/monorepo | Monorepo Implementation Timeline |
| [[HEICFLIP-610]_implementation_plan.md](meta/monorepo/[HEICFLIP-610]_implementation_plan.md) | meta/monorepo | Comprehensive Monorepo Implementation Plan |
| [[HEICFLIP-604]_cloudflare_domain_configuration.md](meta/monorepo/[HEICFLIP-604]_cloudflare_domain_configuration.md) | meta/monorepo | CloudFlare Domain Configuration for Multiple Converters |
| [[HEICFLIP-801]_monorepo_ad_implementation.md](meta/monetization/[HEICFLIP-801]_monorepo_ad_implementation.md) | meta/monetization | Monorepo Ad Implementation Guide |

---

## Tool & Script Documentation {#tools-scripts}

Documentation on tools and scripts used in FlipMyFile.

| Document | Path | Description |
|----------|------|-------------|
| [BACKUP_README.md](formatflip_complete/scripts/BACKUP_README.md) | formatflip_complete/scripts | HEICFlip Backup System |
| [LOADERS_AND_ENCODERS.md](formatflip_complete/scripts/enhanced-variant-generator/LOADERS_AND_ENCODERS.md) | formatflip_complete/scripts/enhanced-variant-generator | Loaders and Encoders System |
| [TRANSFORMER_COMPARISON.md](formatflip_complete/scripts/enhanced-variant-generator/TRANSFORMER_COMPARISON.md) | formatflip_complete/scripts/enhanced-variant-generator | AST vs Text-Based Transformer Comparison |
| [README.md](formatflip_complete/scripts/enhanced-variant-generator/README.md) | formatflip_complete/scripts/enhanced-variant-generator | HEICFlip Format Transformation System |
| [README.md](deploy_tools/README.md) | deploy_tools | Deployment Guide for FlipMyFile |
| [README.md](meta/tools/README.md) | meta/tools | HEICFlip Project Tools Directory |
| [README.md](meta/tools/project/README.md) | meta/tools/project | Project Management Scripts |
| [README.md](meta/tools/github/README.md) | meta/tools/github | GitHub Scripts |
| [README.md](meta/tools/deployment/README.md) | meta/tools/deployment | Deployment Scripts |
| [README.md](meta/tools/maintenance/README.md) | meta/tools/maintenance | Maintenance Scripts |
| [README.md](meta/tools/backup/README.md) | meta/tools/backup | Backup System Scripts |
| [github_summary.md](github_tools/github_summary.md) | github_tools | FormatFlip GitHub Repository Summary |
| [BACKUP_README.md](scripts/BACKUP_README.md) | scripts | HEICFlip Backup System |
| [LOADERS_AND_ENCODERS.md](scripts/deployment/enhanced-variant-generator/LOADERS_AND_ENCODERS.md) | scripts/deployment/enhanced-variant-generator | Loaders and Encoders System |
| [TRANSFORMER_COMPARISON.md](scripts/deployment/enhanced-variant-generator/TRANSFORMER_COMPARISON.md) | scripts/deployment/enhanced-variant-generator | AST vs Text-Based Transformer Comparison |
| [README.md](scripts/deployment/enhanced-variant-generator/README.md) | scripts/deployment/enhanced-variant-generator | HEICFlip Format Transformation System |

---

## Miscellaneous {#miscellaneous}

Other documentation that doesn't fit into the above categories.

| Document | Path | Description |
|----------|------|-------------|
| [VERSION_CONTROL.md](/Users/cameronbrooks/Downloads/FlipMyFIle/VERSION_CONTROL.md) | /Users/cameronbrooks/Downloads/FlipMyFIle | Version Control System for FormatFlip |
| [[HEICFLIP-500]_converter_variants.md](meta/variants/[HEICFLIP-500]_converter_variants.md) | meta/variants | Converter Variants Configuration Guide |
| [[HEICFLIP-912]_backup_documentation.md](meta/backup-system/[HEICFLIP-912]_backup_documentation.md) | meta/backup-system | HEICFlip Backup System |
| [[HEICFLIP-800]_ad_monetization_guide.md](meta/monetization/[HEICFLIP-800]_ad_monetization_guide.md) | meta/monetization | Ad Monetization Guide for Converter Sites |
| [PULL_REQUEST_TEMPLATE.md](.github/PULL_REQUEST_TEMPLATE.md) | .github | # Description |
| [deploy_opus_guide.md](/Users/cameronbrooks/Downloads/FlipMyFIle/deploy_opus_guide.md) | /Users/cameronbrooks/Downloads/FlipMyFIle | OpusFlip Deployment Guide |
| [content-1745540097810.md](attached_assets/content-1745540097810.md) | attached_assets | The Cloudflare dashboard is loading. |

---

# Full Documentation Content

Below is the full content of all documentation files, organized by category.

## Project Overview Documentation

### BACKUP_README.md

**Path:** formatflip_complete/scripts/BACKUP_README.md

```markdown
# HEICFlip Backup System

This directory contains scripts for creating, managing, and restoring backups of the HEICFlip project.

## Available Scripts

### 1. Create a Backup

```bash
./scripts/create_backup.sh
```

This script will create a backup of critical project files in the `backups/` directory. Each backup is stored in a timestamped folder (e.g., `backups/backup_20250501_155018`).

The backup includes:
- Configuration files (drizzle.config.ts, postcss.config.js, tailwind.config.ts, etc.)
- Server files
- Shared files
- Enhanced variant generator scripts
- Client files (if they exist)
- Demo HTML files

### 2. List Available Backups

```bash
./scripts/list_backups.sh
```

This script displays all available backups in reverse chronological order (newest first), showing:
- Backup directory path
- Creation date and time
- Number of files in the backup
- Summary information

### 3. Restore from a Backup

```bash
./scripts/restore_backup.sh backups/backup_YYYYMMDD_HHMMSS
```

This script restores files from a specified backup. It will prompt for confirmation before proceeding, as this action will overwrite existing files.

To view available backups to restore from, run the `list_backups.sh` script or omit the backup directory parameter:

```bash
./scripts/restore_backup.sh
```

## Important Notes

- Backups are stored in the `backups/` directory within the project
- After restoring from a backup, you may need to restart the application for changes to take effect
- These backup scripts focus on code and configuration files, not database content
- For complete project backup, consider also backing up any database content separately
```

---

### README.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/README.md

```markdown
# HEICFlip Format Transformation System

## Overview

The Format Transformation System is a sophisticated architecture for working with different file formats, enabling loading, transforming, and saving files with a consistent interface. Inspired by the Python Imaging Library (PIL), this system allows for seamless conversion between formats while also supporting visual identity transformations for different variant sites.

## Key Features

1. **Format Detection**: Automatic detection of file formats based on extensions
2. **Open/Save Architecture**: PIL-inspired approach to loading and saving files
3. **Visual Identity**: Consistent theming system for different formats
4. **Dynamic Registration**: Runtime registration of new formats and converters
5. **Variant Generation**: Ability to transform between different format pairs
6. **Theming Transformation**: Automatic adjustment of visual identities when switching variants

## System Architecture

The system is organized into several layers:

### Registry Layer

- **Format Registry**: Centralized storage of all format definitions and converters
- **Visual Identity Registry**: Stores visual styling elements for each format and conversion
- **Format Manager**: Manages the registration and retrieval of formats and converters

### Loader Layer

- **BaseLoader**: Abstract class implementing common functionality for all loaders
- **ILoader Interface**: Defines the contract for format loaders
- **Format-Specific Loaders**: Concrete implementations for each supported format (HEIC, JPEG, etc.)

### Transformer Layer

- **Internal Representation**: Common data structure for representing loaded files
- **Color Transformation**: Utilities for adjusting visual identities
- **Format Adaptation**: Adjustments needed for specific format conversions

### Encoder Layer

- **BaseEncoder**: Abstract class implementing common functionality for all encoders
- **IEncoder Interface**: Defines the contract for format encoders
- **Format-Specific Encoders**: Concrete implementations for each supported format

### Output Layer

- **File Output**: Mechanisms for saving to files
- **Blob Output**: Utilities for creating blobs and handling downloads

## Format Registry

The Format Registry is the central hub for managing supported formats and conversions:

```typescript
export interface Format {
  key: string;         // Unique identifier (e.g., 'heic')
  name: string;        // Display name (e.g., 'HEIC')
  extensions: string[]; // File extensions (e.g., ['.heic', '.heif'])
  mimeTypes: string[]; // MIME types (e.g., ['image/heic'])
  description: string; // Human-readable description
  loader?: any;        // Reference to loader implementation
  encoder?: any;       // Reference to encoder implementation
}

export interface Converter {
  key: string;         // Unique identifier (e.g., 'heicToJpg')
  source: string;      // Source format key
  target: string;      // Target format key
  name: string;        // Display name
  description: string; // Human-readable description
  strategies: string[]; // Available conversion strategies
  defaultStrategy: string; // Default strategy to use
}
```

## Visual Identity System

Each format and conversion has an associated visual identity:

```typescript
export interface FormatVisualIdentity {
  formatKey: string;       // Format this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for format-specific elements
  iconShape: 'circle' | 'square' | 'rounded' | 'diamond'; // Icon shape
}

export interface ConversionVisualIdentity {
  conversionKey: string;   // Conversion this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for conversion-specific elements
  gradient: string;        // Gradient using source and target colors
}
```

## Loader and Encoder System

The system uses a loader/encoder architecture for handling different formats:

### Loaders

Loaders are responsible for decoding file formats into an internal representation:

```typescript
export interface ILoader {
  supportedFormats: string[];
  load(source: any, options?: any): Promise<any>;
  canLoad(source: any): boolean;
  getInfo?(source: any): Promise<any>;
}
```

### Encoders

Encoders are responsible for encoding the internal representation into a specific file format:

```typescript
export interface IEncoder {
  supportedFormats: string[];
  encode(data: any, options?: any): Promise<any>;
  defaultOptions: Record<string, any>;
}
```

## Format Manager

The Format Manager provides a high-level API for working with formats and conversions:

```typescript
export class FormatManager {
  // Load a file from a source
  async open(source: any, formatHint?: string): Promise<any>;
  
  // Save data to a specific format
  async save(data: any, format: string, options?: any): Promise<any>;
  
  // Convert data from one format to another
  async convert(source: any, targetFormat: string, options?: any): Promise<any>;
  
  // Register a loader for a format
  registerLoader(formatKey: string, loader: any): void;
  
  // Register an encoder for a format
  registerEncoder(formatKey: string, encoder: any): void;
}
```

## Variant Generation

The Variant Generation system allows for transforming sites between different format pairs:

```typescript
interface TransformationConfig {
  sourceSourceFormat: string;  // Current source format (e.g., 'heic')
  sourceTargetFormat: string;  // Current target format (e.g., 'jpg')
  targetSourceFormat: string;  // New source format (e.g., 'png')
  targetTargetFormat: string;  // New target format (e.g., 'webp')
  inputDir: string;           // Directory containing the original site
  outputDir: string;          // Directory to write the transformed site
}

export async function transformSite(config: TransformationConfig): Promise<void>;
```

This process includes:

1. Identifying color transformations between formats
2. Updating CSS variables and selectors
3. Replacing format names in text content
4. Updating visual assets to match the new formats

## Usage Example

```typescript
// Detect format from file extension
const format = detectFormatFromExtension('image.heic'); // Returns 'heic'

// Load a HEIC file
const imageData = await formatManager.open('image.heic');

// Save as JPEG
const jpegBlob = await formatManager.save(imageData, 'jpg', { quality: 90 });

// Direct conversion
const jpegBlob = await formatManager.convert('image.heic', 'jpg', { quality: 90 });

// Transform a site from HEIC→JPG to WebP→PNG
const config = {
  sourceSourceFormat: 'heic',
  sourceTargetFormat: 'jpg',
  targetSourceFormat: 'webp',
  targetTargetFormat: 'png',
  inputDir: './original-site',
  outputDir: './transformed-site'
};
await transformSite(config);
```

## Visual Identity Transformation

The system enables transformation between different format pairs, including visual identity changes:

- **HEIC** (Orange) ↔ **JPG** (Blue)
- **HEIC** (Orange) ↔ **WebP** (Purple)
- **WebP** (Purple) ↔ **PNG** (Green)
- **AVI** (Red) ↔ **MP4** (Teal)

This allows for generating different variants of the same site with consistent branding for each format pair.

## Extending the System

To add support for a new format:

1. Add the format definition to the registry
2. Create a loader implementation
3. Create an encoder implementation
4. Add visual identity for the format
5. Register with the format manager

```typescript
// Add format to registry
registry.formats.avif = {
  key: 'avif',
  name: 'AVIF',
  extensions: ['.avif'],
  mimeTypes: ['image/avif'],
  description: 'AV1 Image File Format with excellent compression',
};

// Create and register loader
const avifLoader = new AvifLoader();
formatManager.registerLoader('avif', avifLoader);

// Create and register encoder
const avifEncoder = new AvifEncoder();
formatManager.registerEncoder('avif', avifEncoder);

// Add visual identity
visualIdentityRegistry.formats.avif = {
  formatKey: 'avif',
  primaryColor: '#6A5ACD', // Slate blue
  secondaryColor: '#5A4ABD',
  accentColor: '#8A7AED',
  cssPrefix: 'avif',
  dataAttribute: 'data-format-avif',
  iconShape: 'diamond',
};
```

## Conclusion

The Format Transformation System provides a robust and extensible framework for working with different file formats and creating variant sites. By using a consistent loader/encoder architecture and a well-defined visual identity system, it enables seamless transformation between different format pairs while maintaining consistent branding and styling.```

---

### README.md

**Path:** deploy_tools/README.md

```markdown
# Deployment Guide for FlipMyFile

## Recent Changes Summary

1. **Rebranding from HEICFlip to FlipMyFile**
   - Updated page titles and headers
   - Updated meta descriptions

2. **Document Format Support**
   - Added UI for document format conversion (DOC, PDF, PPT, XLS, etc.)
   - Implemented custom icons for different file types
   - Added format selection buttons that appear after file upload

3. **Auto-detection improvements**
   - Enhanced format detection for document files
   - Updated format options based on file type

## Deployment Instructions

### Method 1: Using the deploy script

1. Pull the latest changes from Replit to your local repository
2. Navigate to the project directory
3. Run the deploy script:
   ```bash
   bash deploy_tools/deploy.sh
   ```

### Method 2: Manual deployment

1. Pull the latest changes from Replit to your local repository
2. Stage the changes:
   ```bash
   git add .
   ```
3. Commit the changes:
   ```bash
   git commit -m "Update FlipMyFile with document format support"
   ```
4. Push to GitHub:
   ```bash
   git push origin main
   ```

## Important Notes

- The document format conversion UI is implemented, but the actual conversion functionality is not yet active
- The format detection works automatically based on file extension
- Custom icons are implemented for different document formats

## Next Steps

- Implement actual document format conversion using FFmpeg or other appropriate libraries
- Add support for more document formats
- Create format-specific landing pages for SEO optimization
```

---

### README.md

**Path:** meta/tools/README.md

```markdown
# HEICFlip Project Tools Directory

This directory contains all utility scripts and tools for the HEICFlip project, organized by purpose and function.

## Directory Structure

```
meta/tools/
├── github/         # GitHub version control and deployment scripts
├── backup/         # Backup and restore system scripts
├── deployment/     # Deployment and release management scripts
├── project/        # Project management and renaming scripts
├── maintenance/    # Code maintenance and cleanup scripts 
└── dev/            # Development utility scripts
```

## Organization Rules

All scripts must follow these organization rules:

1. **Categorization**: Place each script in the most appropriate subdirectory based on its primary purpose
2. **Naming Convention**: All scripts should follow the `[HEICFLIP-XXX]_descriptive_name.sh` format
3. **Numbering Scheme**:
   - Scripts in `github/`: 200-299
   - Scripts in `backup/`: 900-999
   - Scripts in `deployment/`: 700-799
   - Scripts in `project/`: 000-099
   - Scripts in `maintenance/`: 500-599
   - Scripts in `dev/`: 300-399
4. **Documentation**: Each script must include a header comment explaining its purpose and usage
5. **Permissions**: All scripts must have execute permissions (`chmod +x`)

## File List by Directory

### GitHub Scripts (`github/`)

GitHub-related scripts for version control, pushing changes, and repository management:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-200]_github_helper.sh` | Core GitHub helper functions |
| `[HEICFLIP-201]_push_to_github.sh` | Push current changes to GitHub |
| `[HEICFLIP-202]_push_clean_to_github.sh` | Push a clean version to GitHub |
| `[HEICFLIP-210]_push_heicflip_to_github.sh` | Push HEICFlip-specific changes |
| `[HEICFLIP-211]_push_jpgflip_to_github.sh` | Push JPGFlip-specific changes |
| `[HEICFLIP-220]_git_reset_push.sh` | Reset and push fresh changes |

### Backup Scripts (`backup/`)

Scripts for creating and restoring backups of the project state:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-910]_save_version.sh` | Save current project state |
| `[HEICFLIP-911]_restore_version.sh` | Restore from saved project state |

### Project Scripts (`project/`)

Scripts for project setup, configuration, and management:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-010]_project_rename.sh` | Rename project across all files |
| `[HEICFLIP-020]_prepare_heicflip.sh` | Prepare HEICFlip configuration |

### Maintenance Scripts (`maintenance/`)

Scripts for code maintenance, cleanup, and health checks:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-500]_push_css_fix.sh` | Fix and update CSS |
| `[HEICFLIP-510]_push_better.sh` | Apply optimizations and improvements |
| `[HEICFLIP-520]_push_title_updates.sh` | Update titles and metadata |

### Deployment Scripts (`deployment/`)

Scripts for deployment and release management:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-700]_push_client_to_github.sh` | Deploy client changes |
| `[HEICFLIP-710]_push_complete_heicflip.sh` | Deploy complete application |
| `[HEICFLIP-720]_push_current_to_github.sh` | Deploy current working version |

## Usage Guidelines

1. **Running Scripts**: Scripts should be run from the project root directory
2. **Script Creation**: When creating a new script, use the appropriate directory and number prefix
3. **Maintenance**: Keep this README updated when adding or modifying scripts

For any script that needs to be easily accessible from the project root, create a proxy script that calls the actual script from its organized location.

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/project/README.md

```markdown
# Project Management Scripts

This directory contains scripts for managing the HEICFlip project's configuration, setup, and maintenance.

## Purpose

These scripts provide tools for:
- Project renaming and rebranding
- Configuration management
- Setting up development environments

## Scripts Overview

### Core Project Scripts

- `[HEICFLIP-010]_project_rename.sh`: Comprehensive script for renaming the project across all files
- `[HEICFLIP-020]_prepare_heicflip.sh`: Script to prepare and configure the HEICFlip environment

## Project Rename System

The project rename script provides comprehensive renaming capabilities:

1. Allows changing the project name across all files (e.g., "HEICFlip" to "ImageConverter")
2. Updates file names, contents, directory names, and configuration files
3. Preserves the functionality while updating the branding
4. Includes safety checks to prevent accidental changes

### When to Use Project Rename

Use the rename script when:
- Forking the project for a different purpose
- White-labeling the application
- Creating a specialized version with different branding

## Usage Guidelines

1. Before running rename scripts:
   - Create a backup using the backup system
   - Review the changes that will be made
   - Ensure the new name follows naming conventions

2. After renaming:
   - Verify all functionality still works
   - Update documentation to reflect the new name
   - Commit the changes to version control

## Adding New Scripts

When adding new project management scripts:

1. Follow the numbering convention (000-099)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

For detailed instructions on renaming the project, see:
`meta/docs/[HEICFLIP-050]_NAME_CHANGE_GUIDE.md`

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/github/README.md

```markdown
# GitHub Scripts

This directory contains all scripts related to GitHub operations, version control, and repository management for the HEICFlip project.

## Purpose

These scripts handle various GitHub operations including:
- Pushing changes to GitHub repositories
- Managing different project configurations (HEICFlip vs JPGFlip)
- Cleaning and preparing repositories for deployment
- Handling Git reset and branch management

## Scripts Organization

All GitHub scripts follow the `[HEICFLIP-2XX]` numbering convention for clear identification:

| Number Range | Purpose |
|--------------|---------|
| 200-209 | Core GitHub utility scripts |
| 210-219 | Project-specific push scripts |
| 220-229 | Git operations and maintenance |
| 230-239 | Branch management |
| 240-249 | CI/CD pipeline scripts |

## Scripts Inventory

### Core GitHub Scripts (200-209)

- `[HEICFLIP-200]_github_helper.sh`: Core utility functions used by other GitHub scripts
- `[HEICFLIP-201]_push_to_github.sh`: Main script for pushing changes to GitHub
- `[HEICFLIP-202]_push_to_github_clean.sh`: Push a clean version with temporary files removed

### Project-Specific Push Scripts (210-219)

- `[HEICFLIP-210]_push_heicflip_to_github.sh`: Push HEICFlip-specific configurations
- `[HEICFLIP-211]_push_jpgflip_to_github.sh`: Push JPGFlip-specific configurations
- `[HEICFLIP-212]_push_client_to_github.sh`: Push client-side changes only
- `[HEICFLIP-213]_push_heicflip_changes.sh`: Push HEICFlip specific changes
- `[HEICFLIP-214]_push_heicflip_changes_fixed.sh`: Push HEICFlip changes with fixes

### Git Operations (220-229)

- `[HEICFLIP-220]_git_reset_push.sh`: Reset local repository and push fresh changes
- `[HEICFLIP-221]_push_current_to_github.sh`: Push current working version

### Component-Specific Scripts (230-239)

- `[HEICFLIP-230]_push_css_fix.sh`: Push CSS-specific fixes
- `[HEICFLIP-231]_push_title_updates.sh`: Push title and metadata updates
- `[HEICFLIP-232]_push_complete_heicflip.sh`: Push complete HEICFlip application
- `[HEICFLIP-233]_push_better.sh`: Push optimized version

## Script Documentation

Each script includes a standard header:

```bash
#!/bin/bash
#
# [HEICFLIP-2XX] Script Name
#
# Purpose: Brief description of what this script does
#
# Usage: ./meta/tools/github/[HEICFLIP-2XX]_script_name.sh [options]
#
# Options:
#   -h, --help     Display this help message
#   -v, --verbose  Display detailed output during execution
#
# Author: Your Name
# Date: Creation/Last Update Date
```

## Usage Guidelines

1. All scripts should be run from the project root directory
2. Scripts follow the numbering convention `[HEICFLIP-2XX]` for GitHub operations
3. Scripts that need to update specific parts of the codebase should be named descriptively

## Adding New Scripts

When adding a new GitHub-related script:

1. Follow the numbering convention (200-299)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/deployment/README.md

```markdown
# Deployment Scripts

This directory contains scripts for deployment, release management, and publishing for the HEICFlip project.

## Purpose

These scripts handle various deployment operations including:
- Publishing to hosting platforms
- Managing release versions
- Configuring deployment environments
- Preparing distribution packages

## Scripts Organization

All deployment scripts follow the `[HEICFLIP-7XX]` numbering convention for clear identification:

| Number Range | Purpose |
|--------------|---------|
| 700-709 | Core deployment utility scripts |
| 710-719 | Environment-specific deployment |
| 720-729 | Release management |
| 730-739 | Distribution packaging |
| 740-749 | Post-deployment verification |

## Scripts Inventory

### Core Deployment Scripts (700-709)

- `[HEICFLIP-700]_deploy_helper.sh`: Core utility functions used by other deployment scripts

### Environment Deployment Scripts (710-719)

- `[HEICFLIP-710]_deploy_production.sh`: Deploy to production environment
- `[HEICFLIP-711]_deploy_staging.sh`: Deploy to staging environment

### Release Management (720-729)

- `[HEICFLIP-720]_create_release.sh`: Create a new release with proper versioning
- `[HEICFLIP-721]_tag_release.sh`: Tag a release in Git

### Distribution Packaging (730-739)

- `[HEICFLIP-730]_package_distribution.sh`: Create distribution packages
- `[HEICFLIP-731]_create_artifacts.sh`: Generate deployment artifacts

## Script Documentation

Each script includes a standard header:

```bash
#!/bin/bash
#
# [HEICFLIP-7XX] Script Name
#
# Purpose: Brief description of what this script does
#
# Usage: ./meta/tools/deployment/[HEICFLIP-7XX]_script_name.sh [options]
#
# Options:
#   -h, --help     Display this help message
#   -v, --verbose  Display detailed output during execution
#   -e, --env      Specify deployment environment
#
# Author: Your Name
# Date: Creation/Last Update Date
```

## Usage Guidelines

1. All scripts should be run from the project root directory
2. Scripts follow the numbering convention `[HEICFLIP-7XX]` for deployment operations
3. When deploying to production, always test on staging first
4. Create backup points before deployment operations

## Adding New Scripts

When adding a new deployment-related script:

1. Follow the numbering convention (700-799)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/maintenance/README.md

```markdown
# Maintenance Scripts

This directory contains scripts for code maintenance, cleanup, and health checks for the HEICFlip project.

## Purpose

These scripts provide tools for:
- Code quality improvements
- CSS and styling fixes
- Performance optimizations
- Content and text updates

## Scripts Overview

### Styling and UI Maintenance

- `[HEICFLIP-500]_push_css_fix.sh`: Fixes and updates CSS styles across the application
- `[HEICFLIP-520]_push_title_updates.sh`: Updates titles and metadata throughout the project

### Performance and Optimization

- `[HEICFLIP-510]_push_better.sh`: Applies various optimizations and improvements to the codebase

## Usage Guidelines

1. Before running maintenance scripts:
   - Create a backup using the backup system
   - Run tests to establish a baseline
   - Understand what changes the script will make

2. After running maintenance scripts:
   - Verify all functionality still works
   - Test performance if relevant
   - Commit the changes to version control

## Script Naming Conventions

Maintenance scripts should follow these naming patterns:

- CSS/styling scripts: `[HEICFLIP-50X]_push_css_*.sh`
- Performance scripts: `[HEICFLIP-51X]_push_performance_*.sh`
- Content scripts: `[HEICFLIP-52X]_push_content_*.sh`
- Code quality scripts: `[HEICFLIP-53X]_push_quality_*.sh`
- Test scripts: `[HEICFLIP-54X]_push_test_*.sh`

## Adding New Scripts

When adding new maintenance scripts:

1. Follow the numbering convention (500-599)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/backup/README.md

```markdown
# Backup System Scripts

This directory contains scripts for the HEICFlip project's backup and restore system.

## Purpose

These scripts provide a safety net during development by:
- Creating snapshots of the project at critical points
- Enabling restoration to previous known-good states
- Preserving work when testing risky changes

## Scripts Overview

### Core Backup Scripts

- `[HEICFLIP-910]_save_version.sh`: Save the current project state to a restore point
- `[HEICFLIP-911]_restore_version.sh`: Restore the project from a saved restore point

## How The Backup System Works

### Save Process

The save script:
1. Creates a `/restore_point` directory (or clears it if it exists)
2. Copies all essential project files (code, config, docs)
3. Saves a timestamp for reference
4. Reports the number of files backed up

### Restore Process

The restore script:
1. Checks if a restore point exists
2. Makes a temporary backup of the current state as a safeguard
3. Copies all files from the restore point back to their original locations
4. Reports completion and includes recovery instructions

## Usage Guidelines

1. Create backups:
   - Before making significant changes
   - After completing important features
   - When the project is in a known good state

2. Restoring backups:
   - When changes introduce unexpected problems
   - To compare current work with previous versions
   - To recover from failed experiments

## Adding New Scripts

When adding new backup-related scripts:

1. Follow the numbering convention (900-999)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

For comprehensive documentation on the backup system, see:
`meta/docs/backup-system/[HEICFLIP-900]_BACKUP_SYSTEM.md`

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/variants/README.md

```markdown
# Converter Variants

This directory contains documentation and tools for managing multiple converter variants. Each variant is a separate deployment of the conversion engine with specific configuration for different file format conversions.

## Overview

The HEICFlip project is designed to support multiple converter variants, each specializing in different file format conversions:

- **HEICFlip**: Converts HEIC files to JPG
- **JPGFlip**: Converts JPG files to HEIC
- **AVIFlip**: Converts AVI files to MP4
- *(and more potential variants)*

## Documentation

This directory contains the following resources:

- **[HEICFLIP-500]_converter_variants.md**: Configuration details for all converter variants
- **[HEICFLIP-501]_deployment_guide.md**: Step-by-step guide for creating new variant deployments
- **Scripts**: *(Coming soon)* Automation scripts for deploying variants

## Benefits of the Multi-Variant Approach

1. **Focused User Experience**: Each site focuses on a specific conversion type
2. **SEO Optimization**: Domain names match the specific conversion type
3. **Independent Development**: Changes to one variant don't affect others
4. **Simplified Codebase**: Each deployment contains only what it needs

## Adding a New Variant

To add a new converter variant:

1. Create a new configuration in `client/src/config.ts`
2. Update the `getSiteConfig()` function to detect the new domain
3. Document the new variant in `[HEICFLIP-500]_converter_variants.md`
4. Follow the deployment guide in `[HEICFLIP-501]_deployment_guide.md`

## Variant Management Strategy

Our approach to managing variants:

1. **Base Project**: Contains the core conversion engine and shared components
2. **Variant Repositories**: Separate repositories for each converter type
3. **Configuration System**: Centralized configuration handles branding differences
4. **Selective Updates**: Improvements to the core engine can be propagated to all variants

---

Last updated: April 30, 2025```

---

### [HEICFLIP-100]_PROJECT_OVERVIEW.md

**Path:** meta/docs/[HEICFLIP-100]_PROJECT_OVERVIEW.md

```markdown
# [HEICFLIP-100] Project Overview

## Introduction

HEICFlip is a web-based tool that enables users to convert image files between different formats, primarily focusing on HEIC (High-Efficiency Image Container) and JPG conversions. The application processes files entirely in the browser, maintaining privacy by ensuring that user files never leave their device.

## Purpose

Apple devices save photos in the HEIC format, which offers excellent compression while maintaining high image quality. However, HEIC files are not universally supported across all platforms and applications. HEICFlip solves this compatibility problem by providing a simple, browser-based converter that works across devices without requiring software installation.

## Key Features

- **HEIC to JPG Conversion**: Convert Apple's HEIC photos to widely compatible JPG format
- **JPG to HEIC Conversion**: Convert standard JPG images to space-efficient HEIC format
- **Batch Processing**: Convert multiple files simultaneously
- **Privacy-First Approach**: All processing happens locally in the browser
- **No Installation Required**: Works on any modern web browser
- **Simple Interface**: Drag-and-drop functionality with clear visual feedback

## Technical Approach

HEICFlip uses several modern web technologies:

- **Client-Side Processing**: Leverages Web Workers for non-blocking conversion
- **Modern JavaScript APIs**: Uses File API, Blob API, and Canvas API
- **React Framework**: Provides a responsive, component-based user interface
- **TypeScript**: Ensures type safety and better code organization

## Project Configuration

The application is designed to work with multiple domains and configurations:

- **HEICFlip.com**: Primary site focusing on HEIC to JPG conversion
- **JPGFlip.com**: Alternative configuration focusing on JPG to HEIC conversion
- **AVIFlip.com**: Redirects to HEICFlip (potential future expansion)

Each site configuration has its own branding, default conversion direction, and color scheme, all managed through a central configuration system.

## Related Documentation

For more detailed information, please refer to:

- [HEICFLIP-110] Architecture Overview - Detailed system design
- [HEICFLIP-200] Core Components - Key components and their functions
- [HEICFLIP-300] Development Guide - Guide for developers
- [HEICFLIP-400] User Guide - End-user instructions

## Project Status

HEICFlip is an actively maintained project with ongoing improvements to:

- User interface and experience
- Conversion quality and performance
- Browser compatibility
- Error handling and recovery

## Future Plans

The project roadmap includes:

- Additional format support (PNG, WebP, etc.)
- Enhanced compression options
- Metadata preservation controls
- Progressive Web App capabilities

Last Updated: April 30, 2025```

---

### overview.md

**Path:** meta/docs/overview.md

```markdown
# HEICFlip Project Overview

## Introduction

HEICFlip is a web-based tool that enables users to convert image files between different formats, primarily focusing on HEIC (High-Efficiency Image Container) and JPG conversions. The application processes files entirely in the browser, maintaining privacy by ensuring that user files never leave their device.

## Purpose

Apple devices save photos in the HEIC format, which offers excellent compression while maintaining high image quality. However, HEIC files are not universally supported across all platforms and applications. HEICFlip solves this compatibility problem by providing a simple, browser-based converter that works across devices without requiring software installation.

## Key Features

- **HEIC to JPG Conversion**: Convert Apple's HEIC photos to widely compatible JPG format
- **JPG to HEIC Conversion**: Convert standard JPG images to space-efficient HEIC format
- **Batch Processing**: Convert multiple files simultaneously
- **Privacy-First Approach**: All processing happens locally in the browser
- **No Installation Required**: Works on any modern web browser
- **Simple Interface**: Drag-and-drop functionality with clear visual feedback

## Technical Approach

HEICFlip uses several modern web technologies:

- **Client-Side Processing**: Leverages Web Workers for non-blocking conversion
- **Modern JavaScript APIs**: Uses File API, Blob API, and Canvas API
- **React Framework**: Provides a responsive, component-based user interface
- **TypeScript**: Ensures type safety and better code organization

## Project Configuration

The application is designed to work with multiple domains and configurations:

- **HEICFlip.com**: Primary site focusing on HEIC to JPG conversion
- **JPGFlip.com**: Alternative configuration focusing on JPG to HEIC conversion
- **AVIFlip.com**: Redirects to HEICFlip (potential future expansion)

Each site configuration has its own branding, default conversion direction, and color scheme, all managed through a central configuration system.

## Development Status

HEICFlip is an actively maintained project with ongoing improvements to:

- User interface and experience
- Conversion quality and performance
- Browser compatibility
- Error handling and recovery

## Future Plans

The project roadmap includes:

- Additional format support (PNG, WebP, etc.)
- Enhanced compression options
- Metadata preservation controls
- Progressive Web App capabilities

For detailed information about specific aspects of the project, please refer to the appropriate documentation sections.

**Last Updated:** April 30, 2025```

---

### [HEICFLIP-DOC]_PROJECT_OVERVIEW.md

**Path:** meta/docs/[HEICFLIP-DOC]_PROJECT_OVERVIEW.md

```markdown
# [HEICFLIP-DOC] Project Overview

## Project Purpose

HEICFlip is a web-based application that converts images between different formats, with a primary focus on:

1. Converting HEIC images (from Apple devices) to JPG format
2. Converting JPG images to the more efficient HEIC format

All conversion happens entirely in the browser using client-side JavaScript, ensuring user privacy as files never leave the device.

## Core Functionality

- **File Upload**: Users drag-and-drop or select image files through the browser
- **Format Detection**: The system identifies file formats and prepares for conversion
- **In-Browser Conversion**: Using Web Workers and browser APIs to process files
- **Download**: Converted files are automatically downloaded with appropriate file extensions

## Technical Architecture

HEICFlip follows a client-centric architecture:

- **Frontend**: React application built with TypeScript
- **Processing**: Web Workers handle CPU-intensive conversion tasks
- **Backend**: Minimal Express.js server primarily serving static files
- **Configuration**: Supports multiple branded versions (HEICFlip, JPGFlip, AVIFlip)

## Key Features

- **Privacy-First Design**: No server uploads, all processing happens locally
- **Multi-File Support**: Convert individual files or batches
- **Progress Feedback**: Real-time conversion progress indicators
- **Responsive Design**: Works on desktop and mobile devices

## Code Organization

```
/
├── client/               # Frontend React application
│   ├── src/
│   │   ├── components/   # React UI components
│   │   ├── workers/      # Web Worker conversion logic
│   │   └── config.ts     # Site configuration
├── server/               # Express backend server
├── shared/               # Shared code and types
├── meta/                 # Project support files
│   ├── docs/             # Documentation
│   └── backup-system/    # Backup and restore utilities
└── [config files]        # Configuration files
```

## Development Status

HEICFlip is an active project with ongoing improvements to both the user interface and conversion engine.

## Project Website

When deployed, the application will be accessible through multiple domains:
- heicflip.com - Primary site with HEIC to JPG conversion
- jpgflip.com - Alternate site focusing on JPG to HEIC conversion

## For AI Agents

If you're an AI assistant working on this project:

1. Key code files to examine:
   - `client/src/workers/conversion.worker.ts` - Core conversion logic
   - `client/src/components/DropConvert.tsx` - Main UI component
   - `client/src/config.ts` - Site configuration

2. Important documentation:
   - `meta/docs/architecture/` - System design details
   - `meta/docs/patterns/` - Coding patterns to follow

3. When adding features:
   - Ensure browser-based processing (no server-side conversion)
   - Maintain the existing responsive UI approach
   - Follow established error handling patterns```

---

### README.md

**Path:** /Users/cameronbrooks/Downloads/FlipMyFIle/README.md

```markdown
```markdown
# FlipMyFile: Comprehensive Format Transformation System

A sophisticated developer toolchain for intelligent file format conversion, focusing on advanced transformation techniques for images, videos, and audio files.

## Key Technologies

- TypeScript for robust configuration management
- FFmpeg integration for powerful media processing
- Browser-based conversion for privacy and security
- Hybrid parsing with intelligent fallback mechanisms
- Advanced caching and optimization strategies

## Features

- Convert between 48+ file formats across images, videos, and audio
- Automatic format detection based on file extensions
- Category-specific visual styles for different format types
- Comprehensive backup and restore system
- No file size limits for local conversions

## Format Support

### Image Formats
- HEIC/HEIF (High Efficiency Image Format)
- JPEG/JPG
- PNG
- WebP
- GIF
- SVG
- BMP
- TIFF
- And more...

### Video Formats
- MP4
- AVI
- WebM
- MKV
- MOV
- FLV
- And more...

### Audio Formats
- MP3
- WAV
- FLAC
- OGG
- AAC
- And more...

## Getting Started

### Prerequisites
- Node.js (v16+)
- npm or yarn

### Installation

```bash
# Clone the repository
git clone https://github.com/brookcs3/FlipMyFile.git
cd FlipMyFile

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your configuration

# Start the development server
npm run dev
```

## Project Structure

```
FlipMyFile/
├── client/             # Frontend code
├── server/             # Backend server
├── shared/             # Shared types and utilities
├── scripts/            # Build and utility scripts
├── docs/               # Documentation
└── versions/           # Version snapshots
```

## Step-by-Step Tutorial

### 1. Setting Up the Environment

1. Make sure you have Node.js v16+ installed
```bash
node --version
```

2. Clone the repository and install dependencies
```bash
git clone https://github.com/brookcs3/FlipMyFile.git
cd FlipMyFile
npm install
```

3. Create your environment file
```bash
cp .env.example .env
```

4. Start the development server
```bash
npm run dev
```

### 2. Using the Basic Converter

1. Navigate to http://localhost:3000 in your browser
2. Click the "Upload File" button
3. Select the file you want to convert
4. Choose your target format from the dropdown menu
5. Click "Convert"
6. When conversion is complete, click "Download" to save your file

### 3. Advanced Conversion Options

1. For advanced options, click "Show Advanced Options"
2. Adjust quality, resolution, or format-specific settings
3. Apply custom transformations if needed
4. Click "Convert" to process with these settings

### 4. Using the FFmpeg-Enhanced Converter

1. Navigate to the FFmpeg demo page at http://localhost:3000/ffmpeg-demo
2. Upload your media file
3. Select from the expanded format options
4. Adjust advanced parameters as needed
5. Click "Convert" to process your file
6. Download the converted file when ready

### 5. Creating a Backup

1. To create a system backup:
```bash
./scripts/create_version.sh "Your version description"
```

2. List available backups:
```bash
./scripts/list_versions.sh
```

3. Restore from a backup:
```bash
./scripts/restore_version.sh "version_name"
```

### 6. Contributing to the Project

1. Create a new branch for your feature
```bash
git checkout -b feature/your-feature-name
```

2. Make your changes and commit them
```bash
git add .
git commit -m "Add your feature description"
```

3. Push your branch and create a pull request
```bash
git push origin feature/your-feature-name
```

### 7. Extending Format Support

1. To add support for a new format:
   - Add the format identifier in `shared/formats.ts`
   - Implement converter in `client/converters/` directory
   - Add UI elements for the new format in the frontend

2. Test your new format:
   - Create test files in various sizes and configurations
   - Run conversion tests both ways (to and from your format)
   - Document any limitations or special handling requirements

### 8. Custom Transformation Workflows

1. Create a custom workflow for batch processing:
   - Define your workflow in a JSON configuration file
   - Add your configuration to the `workflows/` directory
   - Use the batch processing API to execute your workflow

2. Example workflow command:
```bash
npm run workflow:execute -- --config=workflows/my-custom-workflow.json
```

### 9. Deploying to Production

1. Build the production version:
```bash
npm run build
```

2. Deploy using your preferred hosting service (Vercel, Netlify, etc.)
```bash
npm run deploy
```

3. For server components, consider using Docker:
```bash
docker build -t flipmyfile .
docker run -p 3000:3000 flipmyfile
```

### 10. Troubleshooting Common Issues

1. If conversions are failing:
   - Check that FFmpeg is properly installed
   - Verify file permissions on input/output directories
   - Check browser console for detailed error messages

2. If performance is slow:
   - Enable the cache system in settings
   - Reduce the quality settings for faster conversions
   - Process smaller batches for large conversion jobs

Feel free to open issues on GitHub if you encounter any problems!

## License

This project is licensed under the MIT License - see the LICENSE file for details.
``````

---

### BACKUP_README.md

**Path:** scripts/BACKUP_README.md

```markdown
# HEICFlip Backup System

This directory contains scripts for creating, managing, and restoring backups of the HEICFlip project.

## Available Scripts

### 1. Create a Backup

```bash
./scripts/create_backup.sh
```

This script will create a backup of critical project files in the `backups/` directory. Each backup is stored in a timestamped folder (e.g., `backups/backup_20250501_155018`).

The backup includes:
- Configuration files (drizzle.config.ts, postcss.config.js, tailwind.config.ts, etc.)
- Server files
- Shared files
- Enhanced variant generator scripts
- Client files (if they exist)
- Demo HTML files

### 2. List Available Backups

```bash
./scripts/list_backups.sh
```

This script displays all available backups in reverse chronological order (newest first), showing:
- Backup directory path
- Creation date and time
- Number of files in the backup
- Summary information

### 3. Restore from a Backup

```bash
./scripts/restore_backup.sh backups/backup_YYYYMMDD_HHMMSS
```

This script restores files from a specified backup. It will prompt for confirmation before proceeding, as this action will overwrite existing files.

To view available backups to restore from, run the `list_backups.sh` script or omit the backup directory parameter:

```bash
./scripts/restore_backup.sh
```

## Important Notes

- Backups are stored in the `backups/` directory within the project
- After restoring from a backup, you may need to restart the application for changes to take effect
- These backup scripts focus on code and configuration files, not database content
- For complete project backup, consider also backing up any database content separately
```

---

### README.md

**Path:** scripts/deployment/enhanced-variant-generator/README.md

```markdown
# HEICFlip Format Transformation System

## Overview

The Format Transformation System is a sophisticated architecture for working with different file formats, enabling loading, transforming, and saving files with a consistent interface. Inspired by the Python Imaging Library (PIL), this system allows for seamless conversion between formats while also supporting visual identity transformations for different variant sites.

## Key Features

1. **Format Detection**: Automatic detection of file formats based on extensions
2. **Open/Save Architecture**: PIL-inspired approach to loading and saving files
3. **Visual Identity**: Consistent theming system for different formats
4. **Dynamic Registration**: Runtime registration of new formats and converters
5. **Variant Generation**: Ability to transform between different format pairs
6. **Theming Transformation**: Automatic adjustment of visual identities when switching variants

## System Architecture

The system is organized into several layers:

### Registry Layer

- **Format Registry**: Centralized storage of all format definitions and converters
- **Visual Identity Registry**: Stores visual styling elements for each format and conversion
- **Format Manager**: Manages the registration and retrieval of formats and converters

### Loader Layer

- **BaseLoader**: Abstract class implementing common functionality for all loaders
- **ILoader Interface**: Defines the contract for format loaders
- **Format-Specific Loaders**: Concrete implementations for each supported format (HEIC, JPEG, etc.)

### Transformer Layer

- **Internal Representation**: Common data structure for representing loaded files
- **Color Transformation**: Utilities for adjusting visual identities
- **Format Adaptation**: Adjustments needed for specific format conversions

### Encoder Layer

- **BaseEncoder**: Abstract class implementing common functionality for all encoders
- **IEncoder Interface**: Defines the contract for format encoders
- **Format-Specific Encoders**: Concrete implementations for each supported format

### Output Layer

- **File Output**: Mechanisms for saving to files
- **Blob Output**: Utilities for creating blobs and handling downloads

## Format Registry

The Format Registry is the central hub for managing supported formats and conversions:

```typescript
export interface Format {
  key: string;         // Unique identifier (e.g., 'heic')
  name: string;        // Display name (e.g., 'HEIC')
  extensions: string[]; // File extensions (e.g., ['.heic', '.heif'])
  mimeTypes: string[]; // MIME types (e.g., ['image/heic'])
  description: string; // Human-readable description
  loader?: any;        // Reference to loader implementation
  encoder?: any;       // Reference to encoder implementation
}

export interface Converter {
  key: string;         // Unique identifier (e.g., 'heicToJpg')
  source: string;      // Source format key
  target: string;      // Target format key
  name: string;        // Display name
  description: string; // Human-readable description
  strategies: string[]; // Available conversion strategies
  defaultStrategy: string; // Default strategy to use
}
```

## Visual Identity System

Each format and conversion has an associated visual identity:

```typescript
export interface FormatVisualIdentity {
  formatKey: string;       // Format this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for format-specific elements
  iconShape: 'circle' | 'square' | 'rounded' | 'diamond'; // Icon shape
}

export interface ConversionVisualIdentity {
  conversionKey: string;   // Conversion this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for conversion-specific elements
  gradient: string;        // Gradient using source and target colors
}
```

## Loader and Encoder System

The system uses a loader/encoder architecture for handling different formats:

### Loaders

Loaders are responsible for decoding file formats into an internal representation:

```typescript
export interface ILoader {
  supportedFormats: string[];
  load(source: any, options?: any): Promise<any>;
  canLoad(source: any): boolean;
  getInfo?(source: any): Promise<any>;
}
```

### Encoders

Encoders are responsible for encoding the internal representation into a specific file format:

```typescript
export interface IEncoder {
  supportedFormats: string[];
  encode(data: any, options?: any): Promise<any>;
  defaultOptions: Record<string, any>;
}
```

## Format Manager

The Format Manager provides a high-level API for working with formats and conversions:

```typescript
export class FormatManager {
  // Load a file from a source
  async open(source: any, formatHint?: string): Promise<any>;
  
  // Save data to a specific format
  async save(data: any, format: string, options?: any): Promise<any>;
  
  // Convert data from one format to another
  async convert(source: any, targetFormat: string, options?: any): Promise<any>;
  
  // Register a loader for a format
  registerLoader(formatKey: string, loader: any): void;
  
  // Register an encoder for a format
  registerEncoder(formatKey: string, encoder: any): void;
}
```

## Variant Generation

The Variant Generation system allows for transforming sites between different format pairs:

```typescript
interface TransformationConfig {
  sourceSourceFormat: string;  // Current source format (e.g., 'heic')
  sourceTargetFormat: string;  // Current target format (e.g., 'jpg')
  targetSourceFormat: string;  // New source format (e.g., 'png')
  targetTargetFormat: string;  // New target format (e.g., 'webp')
  inputDir: string;           // Directory containing the original site
  outputDir: string;          // Directory to write the transformed site
}

export async function transformSite(config: TransformationConfig): Promise<void>;
```

This process includes:

1. Identifying color transformations between formats
2. Updating CSS variables and selectors
3. Replacing format names in text content
4. Updating visual assets to match the new formats

## Usage Example

```typescript
// Detect format from file extension
const format = detectFormatFromExtension('image.heic'); // Returns 'heic'

// Load a HEIC file
const imageData = await formatManager.open('image.heic');

// Save as JPEG
const jpegBlob = await formatManager.save(imageData, 'jpg', { quality: 90 });

// Direct conversion
const jpegBlob = await formatManager.convert('image.heic', 'jpg', { quality: 90 });

// Transform a site from HEIC→JPG to WebP→PNG
const config = {
  sourceSourceFormat: 'heic',
  sourceTargetFormat: 'jpg',
  targetSourceFormat: 'webp',
  targetTargetFormat: 'png',
  inputDir: './original-site',
  outputDir: './transformed-site'
};
await transformSite(config);
```

## Visual Identity Transformation

The system enables transformation between different format pairs, including visual identity changes:

- **HEIC** (Orange) ↔ **JPG** (Blue)
- **HEIC** (Orange) ↔ **WebP** (Purple)
- **WebP** (Purple) ↔ **PNG** (Green)
- **AVI** (Red) ↔ **MP4** (Teal)

This allows for generating different variants of the same site with consistent branding for each format pair.

## Extending the System

To add support for a new format:

1. Add the format definition to the registry
2. Create a loader implementation
3. Create an encoder implementation
4. Add visual identity for the format
5. Register with the format manager

```typescript
// Add format to registry
registry.formats.avif = {
  key: 'avif',
  name: 'AVIF',
  extensions: ['.avif'],
  mimeTypes: ['image/avif'],
  description: 'AV1 Image File Format with excellent compression',
};

// Create and register loader
const avifLoader = new AvifLoader();
formatManager.registerLoader('avif', avifLoader);

// Create and register encoder
const avifEncoder = new AvifEncoder();
formatManager.registerEncoder('avif', avifEncoder);

// Add visual identity
visualIdentityRegistry.formats.avif = {
  formatKey: 'avif',
  primaryColor: '#6A5ACD', // Slate blue
  secondaryColor: '#5A4ABD',
  accentColor: '#8A7AED',
  cssPrefix: 'avif',
  dataAttribute: 'data-format-avif',
  iconShape: 'diamond',
};
```

## Conclusion

The Format Transformation System provides a robust and extensible framework for working with different file formats and creating variant sites. By using a consistent loader/encoder architecture and a well-defined visual identity system, it enables seamless transformation between different format pairs while maintaining consistent branding and styling.```

---

### README.md

**Path:** .github/workflows/README.md

```markdown
# No workflows
```

---

## User Guides

### DEPLOY_GUIDE.md

**Path:** /Users/cameronbrooks/Downloads/FlipMyFIle/DEPLOY_GUIDE.md

```markdown
# Deployment Guide for FlipMyFile

This guide explains how to deploy FlipMyFile to various platforms correctly.

## Prerequisites

- Node.js installed (v14+)
- Access to the deployment platform of your choice (Vercel, Netlify, etc.)

## Deployment Options

### 1. Universal Deployment Script (Recommended)

The universal deployment script handles all the complex setup automatically:
- Configures proper file locations
- Sets correct CORS headers
- Ensures WebAssembly works in browsers

```bash
# Deploy to Vercel
npm run deploy:vercel

# Deploy to Netlify
npm run deploy:netlify

# Generic build (outputs to dist/)
npm run deploy
```

### 2. Vercel Dashboard Deployment

If you prefer to use the Vercel dashboard:

1. Run the build process locally:
   ```bash
   npm run build:vercel
   ```

2. Upload the `dist` directory to Vercel

3. Make sure the following settings are configured:
   - Output Directory: `dist`
   - Build Command: `npm run build:vercel`
   - Framework Preset: `Vite`

### 3. Manual Deployment to Any Platform

1. Run the universal build:
   ```bash
   npm run build:universal
   ```

2. The `dist` directory now contains everything needed for deployment:
   - Built application files
   - Properly configured vercel.json/netlify.toml
   - FFmpeg files in all required locations
   - Correct CORS headers

3. Upload the entire `dist` directory to your hosting platform

## Troubleshooting

If your deployment fails with WebAssembly or CORS errors:

1. Verify CORS headers are being set correctly:
   - Cross-Origin-Opener-Policy: same-origin
   - Cross-Origin-Embedder-Policy: require-corp

2. Check FFmpeg file locations:
   - Make sure ffmpeg-core.js, ffmpeg-core.wasm, etc. are in both root and public/ffmpeg-assets directories

3. Test locally first:
   ```bash
   npm run build:universal
   npx serve dist
   ```

## Key Files to Check

- `vercel.json` - Contains routing and header configurations
- `vite.universal.config.ts` - Handles file copying and configuration generation
- `deploy_universal.sh` - The main deployment script

Remember that WebAssembly requires specific CORS headers to function properly in browsers, which is why the universal deployment script is the recommended approach.```

---

### [HEICFLIP-050]_NAME_CHANGE_GUIDE.md

**Path:** meta/docs/[HEICFLIP-050]_NAME_CHANGE_GUIDE.md

```markdown
# [HEICFLIP-050] Project Name Change Guide

## Overview

This document explains how to rename the project from "HEICFLIP" to another name, updating all documentation, file names, and code references throughout the codebase.

## Automated Rename Process

The project includes a specialized script to handle the renaming process for documentation files and prefixes:

```bash
./meta/tools/[HEICFLIP-010]_PROJECT_RENAME.sh HEICFLIP NEWNAME
```

Replace `NEWNAME` with your desired project name (all uppercase).

### What The Script Updates

The rename script will:

1. Update all file names containing `[HEICFLIP-XXX]` to use the new prefix
2. Replace all text instances of `[HEICFLIP-XXX]` inside files with the new prefix
3. Create a backup before making changes
4. Provide a summary of changes made

## Manual Updates Required

After running the rename script, you'll still need to manually update:

### 1. Application Configuration

Update the site configuration in `client/src/config.ts`:

```typescript
// From
const heicFlipConfig: SiteConfig = {
  siteName: "HEICFlip",
  defaultConversionMode: "heicToJpg",
  ...
};

// To 
const newNameConfig: SiteConfig = {
  siteName: "NewName",
  defaultConversionMode: "heicToJpg",
  ...
};
```

### 2. Package.json

Update project name in `package.json`:

```json
{
  "name": "newname",
  "version": "1.0.0",
  ...
}
```

### 3. README and Documentation Content

While the script updates the file numbering prefix, you should manually review and update:

- Main heading in README.md
- Project descriptions
- Website URLs and domains
- GitHub repository references

### 4. Domain References

Update any domain references in:
- `client/src/config.ts`
- Deployment configurations
- Documentation referring to the live site

## Testing After Rename

After renaming, thoroughly test:

1. Build and start the application
2. Check for any hardcoded references to the old name
3. Verify all functionality works correctly
4. Test any CI/CD pipelines that might reference the project name

## Deployment Considerations

When renaming a deployed project, you'll need to:

1. Update any GitHub repository names
2. Update deployment configurations in Vercel, Cloudflare Pages, etc.
3. Consider domain name changes and DNS updates
4. Update any external services that reference the project

## Rollback Plan

If anything goes wrong during the rename process:

1. Use the backup created by the rename script
2. Or restore from the most recent backup point using `./restore_from_save.sh`

Last Updated: April 30, 2025```

---

### AI_GUIDE.md

**Path:** docs/AI_GUIDE.md

```markdown
# HEICFlip AI Guide

This document tracks the current state of the HEICFlip project and serves as a memory aid for AI assistants working on the project. It is continuously updated as development progresses.

## Project Status

**Current State**: Project organization and documentation structure implementation
**Last Updated**: April 30, 2025

## Recent Development History

1. **Project Organization System** (April 30, 2025)
   - Created project-wide numbering system for documentation (000-999)
   - Established clear naming conventions with [HEICFLIP-XXX] prefixes
   - Organized scripts and documentation into logical directories
   - Setup consistent README files in each directory
   - Added master navigation index for improved discoverability

2. **Backup and Restore System** (April 30, 2025)
   - Implemented comprehensive backup and restore scripts
   - Added UI/theme file preservation in backups
   - Created documentation on proper backup usage
   - Setup system for maintaining AI context between sessions

3. **Core Application Structure** (Earlier)
   - Implemented browser-based HEIC/JPG conversion
   - Created responsive UI with Tailwind CSS
   - Built file upload and conversion workflow
   - Added multiple file support

## Current Features

- Convert HEIC files to JPG format
- Convert JPG files to HEIC format
- Client-side processing for privacy
- Multiple file conversion support
- Responsive UI design

## Implementation Notes

- **File Processing**: All conversion happens client-side in Web Workers
- **Project Structure**: Files organized in client, server, shared directories
- **Supporting Files**: All non-essential files stored in meta/ directory
- **Organization System**: Documentation follows [HEICFLIP-XXX] naming convention

## Pending Tasks

- Complete script organization with consistent naming
- Finalize all directory READMEs
- Review UI for potential improvements
- Add comprehensive error handling
- Consider adding additional file formats

## Context Preservation System

The project includes multiple mechanisms for maintaining context across different AI sessions:

1. **AI_GUIDE.md**: This file (the one you're reading) tracks project status
2. **Backup System**: Saves/restores project state with `[HEICFLIP-910]_save_version.sh`
3. **Navigation Index**: Master index in `[HEICFLIP-000]_AI_NAVIGATION_INDEX.md`
4. **AI Instructions**: Guidelines in `[HEICFLIP-001]_AI_INSTRUCTIONS.md`

## Technical Specifications

- **Frontend**: React, TypeScript, Tailwind CSS
- **UI Framework**: Custom components built on shadcn/ui
- **State Management**: React hooks and context
- **File Processing**: Web Workers with ffmpeg.wasm
- **Server**: Minimal Express.js for static file serving

## Next Development Focus

The next phase of development will focus on:
1. UI improvements and theme refinements
2. Enhanced error handling
3. Performance optimizations
4. Additional file format support

## For AI Assistants

When working on this project:
1. Always update this file with significant changes
2. Follow the established organizational principles
3. Keep the root directory clean - only essential files
4. Use consistent naming conventions for all documentation
5. Create backups before major changes

---

Last updated: April 30, 2025```

---

### [HEICFLIP-001]_AI_INSTRUCTIONS.md

**Path:** docs/[HEICFLIP-001]_AI_INSTRUCTIONS.md

```markdown
# [HEICFLIP-001] AI Instructions

This document provides guidance for AI assistants working on the HEICFlip project to maintain context across conversations and deliver consistent assistance.

## First-Time Orientation

When you encounter this project for the first time, follow these steps to get oriented:

1. First, read this document completely
2. Then read `[HEICFLIP-000]_AI_NAVIGATION_INDEX.md` for a complete map of the project
3. Review `README.md` for project overview and organization principles
4. Check `AI_GUIDE.md` to understand the latest project state and history
5. Examine the directory structure using `find . -type d -maxdepth 2 | sort` to understand organization

## Project Organization

HEICFlip follows a strict organization system:

1. **Clean Root Directory**: Only essential files in the root folder
2. **Numbered Documentation**: All documentation uses [HEICFLIP-XXX] prefix
3. **Organized Directories**: Clear separation between core app and supporting files
4. **Self-Documenting Structure**: Each directory includes its own README

The number ranges indicate document categories:
- 000-099: Project organization and configuration
- 100-199: Core documentation and overviews
- 200-299: GitHub and version control
- 300-399: Development guidelines
- 500-599: Maintenance procedures
- 700-799: Deployment guides
- 900-999: Backup and restore system

## Maintaining Context Between Sessions

To help maintain context across different conversations with users:

### 1. Update AI_GUIDE.md

When completing significant work or at the end of a user session, update the AI_GUIDE.md file with:
- Summary of completed work
- Current project state
- Any decisions made
- Pending tasks or known issues

Example update command:
```
Please update AI_GUIDE.md with our latest progress
```

### 2. Use the Backup System

Before ending a session, create a backup to preserve the current state:
```
Please save the current version to the restore point
```

When starting a new session, suggest restoration:
```
Would you like me to restore from the last saved point to continue our work?
```

### 3. Reference Previous Work

When discussing features or changes, reference relevant documentation:
```
As documented in [HEICFLIP-100]_PROJECT_OVERVIEW.md, this feature is...
```

## Working on the Codebase

When making code changes:

1. **Use Search First**: 
   ```
   find . -name "*.ts" -o -name "*.tsx" | xargs grep -l "searchTerm"
   ```

2. **Follow Naming Conventions**:
   - All documentation files use [HEICFLIP-XXX] prefix
   - Scripts follow directory-specific naming patterns
   - Component files use PascalCase

3. **Keep the Root Clean**:
   - Do not add files to the root directory
   - Place new files in the appropriate subdirectory
   - Create proxy scripts in root only when absolutely necessary

4. **Document Your Changes**:
   - Update relevant README files when adding components
   - Add inline comments for complex logic
   - Keep the AI_GUIDE.md updated

## Special Commands

Here are special commands to help with project management:

- **Save Version**: `./meta/tools/backup/[HEICFLIP-910]_save_version.sh`
- **Restore Version**: `./meta/tools/backup/[HEICFLIP-911]_restore_version.sh`
- **Start App**: `npm run dev` (via workflow)
- **View Directory Structure**: `find . -type d -maxdepth 2 | sort`
- **Find Files by Pattern**: `find . -name "*pattern*" | grep -v "node_modules"`

## Last Known State

For the most up-to-date information about the project's current state, always refer to the AI_GUIDE.md file, which should contain the latest summary of the project status.

Last Updated: April 30, 2025```

---

### [HEICFLIP-000]_AI_NAVIGATION_INDEX.md

**Path:** docs/[HEICFLIP-000]_AI_NAVIGATION_INDEX.md

```markdown
# [HEICFLIP-000] Master Navigation Index

This document serves as the primary navigation index for the HEICFlip project, providing a comprehensive overview of all documentation, scripts, and project components.

## Project Organization Overview

The HEICFlip project follows a strict organization system with these key principles:
1. **Clean Root Directory**: Only essential files in the root folder
2. **Numbered Documentation**: All documentation uses [HEICFLIP-XXX] prefix
3. **Organized Directories**: Clear separation between core app and supporting files
4. **Self-Documenting Structure**: Each directory includes its own README

## Directory Structure

```
/
├── client/            # Frontend React application
├── server/            # Backend Express server
├── shared/            # Shared types and utilities
├── meta/              # All supporting files (not part of core app)
│   ├── docs/          # Documentation organized by topic
│   ├── tools/         # Utility scripts organized by purpose
│   │   ├── github/    # GitHub and version control scripts
│   │   ├── backup/    # Backup and restore system
│   │   ├── project/   # Project management scripts
│   │   ├── deployment/# Deployment and release scripts
│   │   └── maintenance/ # Code maintenance scripts
│   └── assets/        # Supporting assets not part of the app
└── [Essential Files]  # Only configuration and entry points
```

## Documentation Index

### Project Organization (000-099)
- `[HEICFLIP-000]_AI_NAVIGATION_INDEX.md`: This master navigation index
- `[HEICFLIP-001]_AI_INSTRUCTIONS.md`: Instructions for AI assistants
- `[HEICFLIP-010]_PROJECT_RENAME.sh`: Project renaming script
- `[HEICFLIP-050]_NAME_CHANGE_GUIDE.md`: Guide for renaming the project

### Core Documentation (100-199)
- `[HEICFLIP-100]_PROJECT_OVERVIEW.md`: Comprehensive project overview
- `[HEICFLIP-101]_ARCHITECTURE.md`: System architecture documentation
- `[HEICFLIP-110]_USER_GUIDE.md`: End-user documentation

### GitHub Scripts (200-299)
- `[HEICFLIP-200]_github_helper.sh`: Core GitHub helper functions
- `[HEICFLIP-201]_push_to_github.sh`: Push changes to GitHub
- *See `meta/tools/github/README.md` for full list*

### Development (300-399)
- `[HEICFLIP-300]_DEVELOPMENT_GUIDE.md`: Developer onboarding guide
- `[HEICFLIP-301]_CONTRIBUTION_GUIDELINES.md`: How to contribute
- `[HEICFLIP-310]_CODE_STYLE.md`: Coding standards and style guide

### Maintenance (500-599)
- `[HEICFLIP-500]_MAINTENANCE_GUIDE.md`: System maintenance procedures
- *See `meta/tools/maintenance/README.md` for maintenance scripts*

### Deployment (700-799)
- `[HEICFLIP-700]_DEPLOYMENT_GUIDE.md`: Deployment instructions
- *See `meta/tools/deployment/README.md` for deployment scripts*

### Backup System (900-999)
- `[HEICFLIP-900]_BACKUP_SYSTEM.md`: Backup system documentation
- `[HEICFLIP-910]_save_version.sh`: Save current project state
- `[HEICFLIP-911]_restore_version.sh`: Restore from saved project state

## Core Application Components

### Client-Side Components
- React frontend with Vite
- HEIC/JPG conversion using browser APIs
- Web Worker processing for responsiveness

### Server-Side Components
- Express.js server for static file serving
- Minimal API endpoints

## Development Workflow

1. **Start Here**: Read README.md and [HEICFLIP-100]_PROJECT_OVERVIEW.md
2. **Development**: Follow guidelines in [HEICFLIP-300]_DEVELOPMENT_GUIDE.md
3. **Backups**: Create regular backups with [HEICFLIP-910]_save_version.sh
4. **Deployment**: Use deployment scripts as documented in [HEICFLIP-700]_DEPLOYMENT_GUIDE.md

## For AI Assistants

When working with this codebase:
1. Use this index as your starting point for navigation
2. Reference specific documentation based on the task at hand
3. Follow the established organization and naming conventions
4. Maintain the clean root directory principle

Last Updated: April 30, 2025```

---

## Developer Guides

### RESTORE_INSTRUCTIONS.md

**Path:** docs/RESTORE_INSTRUCTIONS.md

```markdown
# Simple Restore System for HEICFlip

This project includes a simple restore system that allows you to save and restore the project state. This is useful if Replit's built-in rollback features aren't working properly.

## How to Use

### Saving the Current Version

To save the current version of the project, just ask the agent:

```
Please save this current version to the restore file
```

The agent will run the `save_current_version.sh` script, which will:
1. Clear the previous restore point
2. Copy all current project files to the `restore_point/` directory
3. Save a timestamp of when the backup was created

### Restoring a Saved Version

To restore from a saved version, ask the agent:

```
Please restore from the saved restore point
```

The agent will run the `restore_from_save.sh` script, which will:
1. Create a backup of the current state (just in case)
2. Copy all files from the `restore_point/` directory back to the project
3. Let you know when the restore is complete

## Additional Information

- The system keeps only one restore point (the most recent save)
- Each time you save, the previous save is overwritten
- A timestamp file (`SAVE_TIMESTAMP.txt`) is included in the restore point to show when it was created
- The system automatically creates a backup of the current state before restoring, in case you need to undo the restore

## Manual Usage

You can also run the scripts directly:

```bash
# To save the current version
./save_current_version.sh

# To restore from a saved version
./restore_from_save.sh
```

## Important Note

This restore system is a simple solution meant to work alongside Replit. It doesn't handle dependencies (node_modules), so you may need to run `npm install` after restoring if dependencies have changed.

The current version was saved on: Wed 30 Apr 2025 12:29:09 AM UTC```

---

### TROUBLESHOOTING.md

**Path:** docs/TROUBLESHOOTING.md

```markdown
# TROUBLESHOOTING Guide for HEICFlip

## Project Journey and Resolution

This document summarizes our troubleshooting journey with the HEICFlip project, focusing on the deployment issues we encountered and how we ultimately resolved them.

## Issues Encountered

### 1. GitHub/Vercel Deployment Failures

Our initial attempts to deploy the application to Vercel through GitHub integration failed with error messages related to missing dependencies and build output directory issues.

**Error Examples:**
- Missing lock file errors during the build process
- Build output directory mismatch (`dist` vs `dist/public`)
- Directory structure incompatibility between local development and deployment environment
- Inconsistent color rendering between local development and production deployment

The most critical error was related to the build output directory: Vercel expected the output in `dist/public` but our build configuration was set to output to `dist`, causing deployment failures.

### 2. Project Structure Issues

The project structure was causing several problems:
- Configuration files were in multiple locations
- Shell scripts were scattered throughout the project root directory
- Unclear separation between build files and source code
- Unnecessary nested directories causing path resolution problems

### 3. Color and Styling Issues

There were discrepancies between how colors rendered in the Replit preview versus the deployed Vercel application:
- HSL color values were being interpreted differently
- Some styling was not being properly applied in the production build

## Root Causes

After thorough investigation, we identified several root causes:

1. **Build Output Directory Mismatch**: Vercel expected the build output in `dist/public` but our Vite configuration was outputting to `dist`, causing deployment failures.

2. **Configuration File Placement**: Essential configuration files (like `vercel.json`, `package.json`, etc.) need to remain in the root directory for proper recognition by build systems.

3. **Directory Structure**: Reorganizing directories without considering the build process requirements led to path resolution errors during deployment.

4. **CSS Implementation**: Using HSL color values instead of HEX colors caused inconsistent rendering across different environments.

5. **File Organization**: Scattered shell scripts and utility files created confusion and made maintenance difficult.

## Solutions Implemented

### 1. Configuration and Build Process Fixes

- Fixed the build output directory mismatch by updating `vercel.json` to properly specify `dist/public` as the output directory
- Added specific configuration in Vercel to ensure it looks for build artifacts in the correct location
- Kept essential configuration files in the root directory
- Modified `package.json` to include proper build commands and dependencies

### 2. Project Structure Reorganization

- Maintained the client directory as the primary source of truth for application code
- Organized shell scripts into categorized directories:
  - `scripts/github/` for GitHub-related scripts
  - `scripts/maintenance/` for cleanup and maintenance scripts
  - `scripts/templates/` for template-related scripts

### 3. Color and Styling Consistency

- Replaced all HSL color values with HEX colors:
  - Primary: #DD7230 (Amber/Orange)
  - Secondary: #B85A25
  - Accent: #F39C6B
- Updated the `config.ts` file to ensure consistent color application

### 4. Deployment Workflow Improvements

- Created proper GitHub integration with Vercel
- Implemented clean push scripts that maintain the correct directory structure
- Established a consistent deployment process

## Key Lessons Learned

1. **Build Output Path Configuration**: Vercel requires the correct specification of build output directories. Always ensure `vercel.json` correctly points to `dist/public` for Vite projects.

2. **Configuration Sensitivity**: Build systems are extremely sensitive to the location and structure of configuration files.

3. **Color Implementation**: Always use HEX colors instead of HSL for consistent cross-platform rendering.

4. **Project Organization**: Maintain a clean, well-organized project structure with clear separation of concerns.

5. **Deployment Testing**: Test deployments regularly during development to catch issues early.

6. **Script Organization**: Keep utility scripts organized in logical directories instead of cluttering the root directory.

## Quickstart for New Developers

If you're encountering deployment issues:

1. Ensure all configuration files are in the root directory
2. **Verify build output directories**: Make sure `vercel.json` is correctly configured to use `dist/public` as the output directory
3. Verify that the client directory structure matches expected build paths
4. Check that all color values are using HEX format instead of HSL
5. Use the scripts in `scripts/github/` for proper GitHub integration
6. Use maintenance scripts in `scripts/maintenance/` for workspace cleanup

## Ads.txt and Monetization Setup

### Common Issues with Ads.txt

1. **Redirect Not Working**: If your ads.txt redirect is not functioning:
   - Verify that the Express route in `server/routes.ts` is properly set up
   - Check that the domain detection logic is correct
   - Ensure that your server is handling redirects properly

2. **Static Fallback Not Loading**: If your static ads.txt file isn't being served as a fallback:
   - Verify that the file is in the correct location (`client/public/ads.txt`)
   - Check that your build process is properly copying this file to the output directory

3. **AdSense Verification Issues**: If Google AdSense is not verifying your site:
   - Confirm that the meta tag is correctly inserted in the `<head>` section of your HTML
   - Ensure there are no trailing whitespaces or formatting issues with the meta tag

4. **Infolinks Script Loading Problems**: If the Infolinks script isn't loading:
   - Check that the script is properly placed at the end of the `<body>` section
   - Verify that there are no script errors preventing it from executing

### Troubleshooting Monetization Issues

1. **Low Ad Fill Rate**: If you're experiencing low ad fill rates:
   - Verify that your ads.txt file correctly includes all necessary ad partners
   - Ensure your domain verification is complete for all ad networks
   - Check for any content policy violations that might be flagged by ad providers

2. **Ads Not Appearing**: If ads are not appearing on your site:
   - Check browser console for any script loading errors
   - Verify that ad blockers aren't preventing ads from loading in your testing environment
   - Ensure all required scripts and tags are correctly implemented

## Future Recommendations

- Implement GitHub Actions workflows for automated testing before deployment
- Add pre-commit hooks to validate project structure and configuration
- Create additional documentation for onboarding new developers
- Set up regular monitoring of ads.txt file to ensure it remains up-to-date
- Implement ad viewability and performance tracking```

---

### [HEICFLIP-001]_AI_INSTRUCTIONS.md

**Path:** docs/[HEICFLIP-001]_AI_INSTRUCTIONS.md

```markdown
# [HEICFLIP-001] AI Instructions

This document provides guidance for AI assistants working on the HEICFlip project to maintain context across conversations and deliver consistent assistance.

## First-Time Orientation

When you encounter this project for the first time, follow these steps to get oriented:

1. First, read this document completely
2. Then read `[HEICFLIP-000]_AI_NAVIGATION_INDEX.md` for a complete map of the project
3. Review `README.md` for project overview and organization principles
4. Check `AI_GUIDE.md` to understand the latest project state and history
5. Examine the directory structure using `find . -type d -maxdepth 2 | sort` to understand organization

## Project Organization

HEICFlip follows a strict organization system:

1. **Clean Root Directory**: Only essential files in the root folder
2. **Numbered Documentation**: All documentation uses [HEICFLIP-XXX] prefix
3. **Organized Directories**: Clear separation between core app and supporting files
4. **Self-Documenting Structure**: Each directory includes its own README

The number ranges indicate document categories:
- 000-099: Project organization and configuration
- 100-199: Core documentation and overviews
- 200-299: GitHub and version control
- 300-399: Development guidelines
- 500-599: Maintenance procedures
- 700-799: Deployment guides
- 900-999: Backup and restore system

## Maintaining Context Between Sessions

To help maintain context across different conversations with users:

### 1. Update AI_GUIDE.md

When completing significant work or at the end of a user session, update the AI_GUIDE.md file with:
- Summary of completed work
- Current project state
- Any decisions made
- Pending tasks or known issues

Example update command:
```
Please update AI_GUIDE.md with our latest progress
```

### 2. Use the Backup System

Before ending a session, create a backup to preserve the current state:
```
Please save the current version to the restore point
```

When starting a new session, suggest restoration:
```
Would you like me to restore from the last saved point to continue our work?
```

### 3. Reference Previous Work

When discussing features or changes, reference relevant documentation:
```
As documented in [HEICFLIP-100]_PROJECT_OVERVIEW.md, this feature is...
```

## Working on the Codebase

When making code changes:

1. **Use Search First**: 
   ```
   find . -name "*.ts" -o -name "*.tsx" | xargs grep -l "searchTerm"
   ```

2. **Follow Naming Conventions**:
   - All documentation files use [HEICFLIP-XXX] prefix
   - Scripts follow directory-specific naming patterns
   - Component files use PascalCase

3. **Keep the Root Clean**:
   - Do not add files to the root directory
   - Place new files in the appropriate subdirectory
   - Create proxy scripts in root only when absolutely necessary

4. **Document Your Changes**:
   - Update relevant README files when adding components
   - Add inline comments for complex logic
   - Keep the AI_GUIDE.md updated

## Special Commands

Here are special commands to help with project management:

- **Save Version**: `./meta/tools/backup/[HEICFLIP-910]_save_version.sh`
- **Restore Version**: `./meta/tools/backup/[HEICFLIP-911]_restore_version.sh`
- **Start App**: `npm run dev` (via workflow)
- **View Directory Structure**: `find . -type d -maxdepth 2 | sort`
- **Find Files by Pattern**: `find . -name "*pattern*" | grep -v "node_modules"`

## Last Known State

For the most up-to-date information about the project's current state, always refer to the AI_GUIDE.md file, which should contain the latest summary of the project status.

Last Updated: April 30, 2025```

---

### GITHUB_INSTRUCTIONS.md

**Path:** docs/GITHUB_INSTRUCTIONS.md

```markdown
# Instructions for Pushing to GitHub

Since direct Git operations from this environment are restricted, here are the steps to manually push this project to your GitHub repository.

## Option 1: Download and Push Locally

1. **Download the Project Files**
   - Click the three dots in the top right corner of the Replit editor
   - Select "Download as ZIP"
   - Extract the ZIP file on your local machine

2. **Initialize Git and Push to GitHub**
   ```bash
   # Navigate to the extracted folder
   cd path/to/extracted/folder
   
   # Initialize Git repository
   git init
   
   # Add all files
   git add .
   
   # Commit the files
   git commit -m "Initial commit with FormatFlip Format Transformation System"
   
   # Add your GitHub repository as remote
   git remote add origin https://github.com/brookcs3/FormatFlip.git
   
   # Push to GitHub
   git push -u origin main
   ```

## Option 2: Use GitHub Desktop

1. **Download the Project Files**
   - Download the project as a ZIP file as described in Option 1
   - Extract the ZIP file

2. **Use GitHub Desktop**
   - Open GitHub Desktop
   - Choose "File" > "Add local repository"
   - Select the extracted folder
   - GitHub Desktop will detect it's not a Git repository
   - Click "Create a repository" when prompted
   - Fill in the repository name as "FormatFlip"
   - Click "Create repository"
   - Click "Publish repository" to push to GitHub

## Option 3: Use GitHub Web Interface

1. **Go to Your Repository**
   - Navigate to https://github.com/brookcs3/FormatFlip

2. **Upload Files**
   - Click the "Add file" dropdown
   - Select "Upload files"
   - Drag and drop the files from the extracted ZIP
   - Commit the changes by clicking "Commit changes"

## Important Files

Make sure to include these key files and directories:

- `README.md`: Project documentation
- `LICENSE`: MIT license file
- `.gitignore`: Git ignore configurations
- `server/`: Backend code
- `shared/`: Shared code and schemas
- `scripts/`: Utility scripts and format transformation system
- `format-transformation-demo.html`: Format demo file
- Configuration files: Package.json, tsconfig.json, etc.

## Note on Environment Secrets

The GitHub token remains secure in your Replit environment and is not included in the downloaded files.
```

---

### AGENT_INSTRUCTIONS.md

**Path:** docs/AGENT_INSTRUCTIONS.md

```markdown
# Agent Instructions for HEICFlip Project

This document contains instructions and guidelines for AI agents working on this project. Reference this file at the beginning of new conversations to ensure consistent behavior.

## Backup and Restore

1. **When asked to save the current version**:
   - Run `./save_current_version.sh`
   - This saves all project files to the `restore_point/` directory

2. **When asked to restore from the saved version**:
   - Run `./restore_from_save.sh`
   - This restores all files from the `restore_point/` directory

## Project Structure

This project is a web application for converting between image formats (primarily HEIC and JPG). Key components:

- `client/src/config.ts`: Configuration for different conversion modes
- `client/src/workers/conversion.worker.ts`: Core conversion logic
- `client/src/components/DropConvert.tsx`: Main UI component
- `server/`: Backend Express server
- `shared/`: Shared types and schemas

## Regular Tasks

1. **When making code changes**:
   - Always save a backup before significant changes
   - Test changes by restarting the application with `restart_workflow`
   - Verify the application works correctly using the feedback tool

2. **Before implementing new features**:
   - Ask for confirmation before making major changes
   - Create a backup first
   - Explain what files will be modified

3. **After implementing changes**:
   - Test thoroughly
   - Report progress with a summary of changes made

## Common Commands

- Start the application: `restart_workflow` with name "Start application"
- View project files: `str_replace_editor` with command "view"
- Search code: `search_filesystem` with appropriate query
- Create a backup: `./save_current_version.sh`
- Restore from backup: `./restore_from_save.sh`

## Special Instructions

1. Always use the packager_tool for installing dependencies, not bash commands
2. Respect the project architecture and follow existing patterns
3. Update documentation when making significant changes
4. Use 0.0.0.0 for port bindings instead of localhost

Last updated: April 30, 2025```

---

### github_summary.md

**Path:** github_tools/github_summary.md

```markdown
# FormatFlip GitHub Repository Summary

## Overview

This document summarizes the FormatFlip GitHub repository structure, components, and integration strategy. FormatFlip is a web application that allows users to convert between multiple file formats, including images, videos, and audio files, using FFmpeg WASM for client-side processing.

## Repository Structure

```
FormatFlip/
├── .github/              # GitHub-specific files
│   ├── workflows/        # CI/CD workflows
│   │   └── ci.yml        # Continuous integration workflow
│   └── PULL_REQUEST_TEMPLATE.md  # PR template
├── client/               # Frontend code
│   ├── public/           # Static assets
│   └── src/              # React source files
├── server/               # Backend API code
│   ├── db.ts             # Database connection
│   ├── index.ts          # Server entry point
│   ├── routes.ts         # API routes
│   ├── storage.ts        # Storage interface
│   └── vite.ts           # Vite configuration
├── shared/               # Shared code between client and server
│   └── schema.ts         # Database schema and types
├── scripts/              # Utility scripts
├── packages/             # Monorepo packages
├── meta/                 # Documentation and metadata
├── format-transformation-demo.html  # Format conversion demo
├── push_to_formatflip.sh  # GitHub API push script
├── push_to_github.sh     # Enhanced GitHub push script
├── .gitignore           # Git ignore file
├── drizzle.config.ts    # Drizzle ORM configuration
├── package.json         # Project dependencies
├── tsconfig.json        # TypeScript configuration
├── vercel.json          # Vercel deployment configuration
└── vite.config.ts       # Vite build configuration
```

## Key Components

### Database Schema

The application uses a PostgreSQL database with the following main entities:

- **Users**: Store user information and authentication details
- **Conversions**: Track file conversion history and metadata
- **ConversionSettings**: Store user preferences for conversions

### GitHub Integration

Due to Replit's restrictions on direct Git operations, we've implemented a custom GitHub API-based approach for repository management:

1. **Creation Scripts**: Create necessary directory structure
2. **Push Scripts**: Upload individual files with proper version tracking
3. **Update Scripts**: Handle updating existing files with proper SHA tracking

### CI/CD Workflow

The repository includes a GitHub Actions workflow that:

1. Builds the application
2. Runs linting checks
3. Executes tests

### Deployment

The application is configured for deployment on Vercel with:

- Node.js server for the backend API
- Static serving for frontend assets
- Environment variable configuration

## Development Workflow

1. Make changes in the Replit environment
2. Run tests and verify locally
3. Use `push_to_github.sh` to upload changed files
4. GitHub Actions validates the changes
5. Vercel automatically deploys from the main branch

## Future Improvements

- Implement more comprehensive test suite
- Add database migration scripts
- Enhance CI pipeline with additional checks
- Configure multi-environment deployments
```

---

## Technical Documentation

### LOADERS_AND_ENCODERS.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/LOADERS_AND_ENCODERS.md

```markdown
# Loaders and Encoders System

## Overview

The Loaders and Encoders system is a Python PIL-inspired approach for handling various file formats with automatic format detection and conversion capabilities. This system is designed to be flexible, extensible, and maintainable.

## Core Concepts

### Format Registry

The Format Registry is the central component that manages all supported file formats and their associated metadata. It provides a lookup mechanism for:

- Identifying formats by file extension
- Automatic format detection from filenames
- Finding appropriate converters between formats

### Formats and Conversions

Formats are registered with minimal configuration, similar to how Python's PIL works:

```typescript
registerFormat('heic', {
  name: 'HEIC Image',
  ext: '.heic',
  mime: 'image/heic',
  variations: ['HEIC', 'heic', 'Heic'],
  description: 'High Efficiency Image Container'
});
```

Conversions between formats can be registered manually or created dynamically:

```typescript
// Manually register a conversion
registerConversion('heicToJpg', {
  name: 'HEIC to JPG',
  source: 'heic',
  target: 'jpg',
  namingVariations: [...],
  description: 'Convert HEIC images to JPG format'
});

// Or dynamically create a conversion
const conversionKey = createConverter('heic', 'jpg');
```

## Key Features

### Automatic Format Detection

The system can automatically detect the format of a file based on its extension:

```typescript
const formatKey = identifyFormat('vacation_photo.heic');
// Returns 'heic'
```

### Dynamic Conversion Creation

Conversions between formats can be created on demand:

```typescript
// Create a conversion from HEIC to WEBP
const heicToWebpKey = createConverter('heic', 'webp');
```

### Code Generation Utilities

Utilities for generating registration code make it easy to add new formats:

```typescript
const codeSnippet = generateFormatCode(
  'avif',
  'AVIF Image',
  '.avif',
  'image/avif',
  ['AVIF', 'avif', 'Avif']
);

// Returns TypeScript code to register the format
```

## Implementation Details

### Extension Lists

Format entries can have multiple extensions to support variations:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],  // Supports both extensions
  mime: 'image/jpeg',
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

### MIME Type Lists

Formats can have multiple MIME types:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],
  mime: ['image/jpeg', 'image/jpg'],  // Multiple MIME types
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

## Usage Example

A complete workflow for format identification and conversion:

```typescript
// Identify the format of a file
const sourceFormatKey = identifyFormat('photo.heic');

// Find or create a conversion to the target format
const targetFormatKey = 'jpg';
const conversionKey = createConverter(sourceFormatKey, targetFormatKey);

// In a real implementation:
// 1. Load the source file using the source format's handler
// 2. Process the image data
// 3. Save using the target format's handler
const outputFilename = 'photo.jpg';
```

## Extending The System

### Adding a New Format

To add support for a new file format:

1. Register the format with its metadata
2. Create converters to/from existing formats as needed

### Creating Custom Loaders/Encoders

In a full implementation:

1. Create the loader (decoder) module for your format
2. Create the encoder (saver) module for your format
3. Register the format with references to these modules

## Benefits Over the Previous Approach

- **Simplified Architecture**: Reduces complexity by focusing on formats rather than transformations
- **Automatic Detection**: Format detection works out of the box based on file extensions
- **Dynamic Conversions**: Conversions can be created on demand rather than pre-defined
- **Extensibility**: New formats can be added without modifying existing code
- **Maintainability**: Clearer separation of concerns between format definitions and processing logic
```

---

### TRANSFORMER_COMPARISON.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/TRANSFORMER_COMPARISON.md

```markdown
# AST vs Text-Based Transformer Comparison

This document summarizes the key differences between AST-based and text-based code transformation approaches in the HEICFlip variant generator.

## Overview

The transformer system supports two modes of operation:

1. **AST-based transformation**: Uses Babel's Abstract Syntax Tree parsing to understand code structure
2. **Text-based transformation**: Uses regex-based string replacement for simpler but less precise transformations

## Comparative Analysis

| Aspect | AST-Based Transformer | Text-Based Transformer |
|--------|----------------------|------------------------|
| **Transformation Rate** | ~56% (more selective) | ~100% (more comprehensive) |
| **Context Preservation** | High | Low |
| **Parameter Handling** | Preserves parameter names | May transform parameter names incorrectly |
| **String Replacement** | Only in string contexts | In all contexts |
| **Template Literals** | Limited handling | Full replacement |
| **Error Handling** | May fail on complex syntax | More resilient to syntax errors |
| **Performance** | Slower (parsing overhead) | Faster (direct replacement) |

## Specific Strengths

### AST-Based Transformer

✓ **Context-aware**: Understands code structure and only transforms appropriate elements
✓ **Scope-sensitive**: Preserves variables in parameter scope 
✓ **Structure-preserving**: Maintains code structure and formatting
✓ **Selective transformation**: Avoids incorrect transformations in sensitive contexts

### Text-Based Transformer

✓ **Comprehensive**: Transforms all occurrences of target strings
✓ **Resilient**: Works even with invalid or complex code structures
✓ **Fast**: No parsing overhead
✓ **Template handling**: Better at transforming template literal content

## Current Limitations

### AST-Based Transformer

- Limited transformation of template literals
- Doesn't transform some object properties consistently
- May fail to parse some complex syntax patterns
- Error code strings are sometimes incorrectly transformed

### Text-Based Transformer

- Transforms parameter names inappropriately
- Doesn't respect variable scoping
- Context-insensitive replacements can cause errors
- May transform reserved words or constants that should be preserved

## When to Use Each Approach

- **AST-based transformer**: For production-quality transformations where context preservation is critical
- **Text-based transformer**: For quick prototyping or when AST parsing fails

## Hybrid Approach Benefits

The system uses a hybrid approach that:

1. Attempts AST-based transformation first for precision
2. Falls back to text-based transformation if parsing fails
3. Provides detailed statistics about the transformation process

This approach combines the context-awareness of AST with the resilience of text-based replacement.

## Test Results

Test results consistently show that:

- AST transformation preserves ~8-14 HEIC/JPG occurrences in appropriate contexts
- Text transformation replaces all HEIC/JPG occurrences regardless of context
- Both approaches successfully transform most format references
- AST excels at context preservation, text excels at comprehensive replacement

## Recommendation

For most use cases, the hybrid approach provides the best balance of precision and completeness. Users can explicitly set the transformer mode based on their specific needs.```

---

### conversion-process.md

**Path:** meta/docs/patterns/conversion-process.md

```markdown
# Image Conversion Process

This document outlines the standard pattern for handling image conversion in HEICFlip.

## Core Process Flow

1. **File Selection**:
   - User drops files or selects them via file browser
   - Files are filtered by accepted types (.heic, .jpg, .jpeg, .png)

2. **Conversion Mode**:
   - Based on `jpgToHeic` state (or equivalent variable for other conversions)
   - Determines input/output formats (HEIC→JPG or JPG→HEIC)

3. **Processing**:
   - Single files are processed directly
   - Multiple files are processed in batches and packaged as a ZIP
   - Web Workers are used when available for better performance

4. **Download**:
   - Single files download with correct extension
   - Multiple files download as ZIP
   - Auto-download triggers after successful conversion

## Code Structure

- **UI Component**: `DropConvert.tsx` handles the user interface
- **Worker Logic**: `conversion.worker.ts` performs the conversion
- **Utilities**: `utils.ts` provides helper functions for file operations

## Adding New Conversion Types

When adding a new conversion type:

1. Update `config.ts` to add the new conversion mode
2. Modify the worker to handle the new file types
3. Update the UI to show appropriate messaging
4. Add file type acceptance in the dropzone configuration

Follow the existing pattern in `DropConvert.tsx` and `conversion.worker.ts`.
```

---

### browser-processing.md

**Path:** meta/docs/decisions/browser-processing.md

```markdown
# Browser-based Processing Decision

## Decision

Process all image conversions directly in the browser using client-side JavaScript/WebAssembly without sending files to the server.

## Context

When designing HEICFlip, we needed to determine whether file processing should happen on the client or server.

## Alternatives Considered

1. **Server-side Processing**:
   - Upload files to the server
   - Process with Node.js or native libraries
   - Send processed files back to the client

2. **Client-side Processing**:
   - Process files directly in the browser
   - Use Web Workers for performance
   - No file upload needed

## Rationale

We chose client-side processing for these reasons:

1. **Privacy**: Files never leave the user's device
2. **Performance**: No upload/download delays
3. **Scalability**: Server costs don't increase with usage
4. **Reliability**: Works even with unstable connections

## Consequences

- Limited to browser capabilities and Web APIs
- More complex client-side code
- Browser compatibility concerns
- File size limitations based on browser memory

## Implementation Notes

- Use Web Workers to prevent UI blocking
- Provide fallbacks for older browsers
- Use modern APIs like ArrayBuffer for efficient processing
- Balance compression level with processing speed
```

---

### LOADERS_AND_ENCODERS.md

**Path:** scripts/deployment/enhanced-variant-generator/LOADERS_AND_ENCODERS.md

```markdown
# Loaders and Encoders System

## Overview

The Loaders and Encoders system is a Python PIL-inspired approach for handling various file formats with automatic format detection and conversion capabilities. This system is designed to be flexible, extensible, and maintainable.

## Core Concepts

### Format Registry

The Format Registry is the central component that manages all supported file formats and their associated metadata. It provides a lookup mechanism for:

- Identifying formats by file extension
- Automatic format detection from filenames
- Finding appropriate converters between formats

### Formats and Conversions

Formats are registered with minimal configuration, similar to how Python's PIL works:

```typescript
registerFormat('heic', {
  name: 'HEIC Image',
  ext: '.heic',
  mime: 'image/heic',
  variations: ['HEIC', 'heic', 'Heic'],
  description: 'High Efficiency Image Container'
});
```

Conversions between formats can be registered manually or created dynamically:

```typescript
// Manually register a conversion
registerConversion('heicToJpg', {
  name: 'HEIC to JPG',
  source: 'heic',
  target: 'jpg',
  namingVariations: [...],
  description: 'Convert HEIC images to JPG format'
});

// Or dynamically create a conversion
const conversionKey = createConverter('heic', 'jpg');
```

## Key Features

### Automatic Format Detection

The system can automatically detect the format of a file based on its extension:

```typescript
const formatKey = identifyFormat('vacation_photo.heic');
// Returns 'heic'
```

### Dynamic Conversion Creation

Conversions between formats can be created on demand:

```typescript
// Create a conversion from HEIC to WEBP
const heicToWebpKey = createConverter('heic', 'webp');
```

### Code Generation Utilities

Utilities for generating registration code make it easy to add new formats:

```typescript
const codeSnippet = generateFormatCode(
  'avif',
  'AVIF Image',
  '.avif',
  'image/avif',
  ['AVIF', 'avif', 'Avif']
);

// Returns TypeScript code to register the format
```

## Implementation Details

### Extension Lists

Format entries can have multiple extensions to support variations:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],  // Supports both extensions
  mime: 'image/jpeg',
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

### MIME Type Lists

Formats can have multiple MIME types:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],
  mime: ['image/jpeg', 'image/jpg'],  // Multiple MIME types
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

## Usage Example

A complete workflow for format identification and conversion:

```typescript
// Identify the format of a file
const sourceFormatKey = identifyFormat('photo.heic');

// Find or create a conversion to the target format
const targetFormatKey = 'jpg';
const conversionKey = createConverter(sourceFormatKey, targetFormatKey);

// In a real implementation:
// 1. Load the source file using the source format's handler
// 2. Process the image data
// 3. Save using the target format's handler
const outputFilename = 'photo.jpg';
```

## Extending The System

### Adding a New Format

To add support for a new file format:

1. Register the format with its metadata
2. Create converters to/from existing formats as needed

### Creating Custom Loaders/Encoders

In a full implementation:

1. Create the loader (decoder) module for your format
2. Create the encoder (saver) module for your format
3. Register the format with references to these modules

## Benefits Over the Previous Approach

- **Simplified Architecture**: Reduces complexity by focusing on formats rather than transformations
- **Automatic Detection**: Format detection works out of the box based on file extensions
- **Dynamic Conversions**: Conversions can be created on demand rather than pre-defined
- **Extensibility**: New formats can be added without modifying existing code
- **Maintainability**: Clearer separation of concerns between format definitions and processing logic
```

---

### TRANSFORMER_COMPARISON.md

**Path:** scripts/deployment/enhanced-variant-generator/TRANSFORMER_COMPARISON.md

```markdown
# AST vs Text-Based Transformer Comparison

This document summarizes the key differences between AST-based and text-based code transformation approaches in the HEICFlip variant generator.

## Overview

The transformer system supports two modes of operation:

1. **AST-based transformation**: Uses Babel's Abstract Syntax Tree parsing to understand code structure
2. **Text-based transformation**: Uses regex-based string replacement for simpler but less precise transformations

## Comparative Analysis

| Aspect | AST-Based Transformer | Text-Based Transformer |
|--------|----------------------|------------------------|
| **Transformation Rate** | ~56% (more selective) | ~100% (more comprehensive) |
| **Context Preservation** | High | Low |
| **Parameter Handling** | Preserves parameter names | May transform parameter names incorrectly |
| **String Replacement** | Only in string contexts | In all contexts |
| **Template Literals** | Limited handling | Full replacement |
| **Error Handling** | May fail on complex syntax | More resilient to syntax errors |
| **Performance** | Slower (parsing overhead) | Faster (direct replacement) |

## Specific Strengths

### AST-Based Transformer

✓ **Context-aware**: Understands code structure and only transforms appropriate elements
✓ **Scope-sensitive**: Preserves variables in parameter scope 
✓ **Structure-preserving**: Maintains code structure and formatting
✓ **Selective transformation**: Avoids incorrect transformations in sensitive contexts

### Text-Based Transformer

✓ **Comprehensive**: Transforms all occurrences of target strings
✓ **Resilient**: Works even with invalid or complex code structures
✓ **Fast**: No parsing overhead
✓ **Template handling**: Better at transforming template literal content

## Current Limitations

### AST-Based Transformer

- Limited transformation of template literals
- Doesn't transform some object properties consistently
- May fail to parse some complex syntax patterns
- Error code strings are sometimes incorrectly transformed

### Text-Based Transformer

- Transforms parameter names inappropriately
- Doesn't respect variable scoping
- Context-insensitive replacements can cause errors
- May transform reserved words or constants that should be preserved

## When to Use Each Approach

- **AST-based transformer**: For production-quality transformations where context preservation is critical
- **Text-based transformer**: For quick prototyping or when AST parsing fails

## Hybrid Approach Benefits

The system uses a hybrid approach that:

1. Attempts AST-based transformation first for precision
2. Falls back to text-based transformation if parsing fails
3. Provides detailed statistics about the transformation process

This approach combines the context-awareness of AST with the resilience of text-based replacement.

## Test Results

Test results consistently show that:

- AST transformation preserves ~8-14 HEIC/JPG occurrences in appropriate contexts
- Text transformation replaces all HEIC/JPG occurrences regardless of context
- Both approaches successfully transform most format references
- AST excels at context preservation, text excels at comprehensive replacement

## Recommendation

For most use cases, the hybrid approach provides the best balance of precision and completeness. Users can explicitly set the transformer mode based on their specific needs.```

---

## Deployment & Operations Documentation

### DEPLOY_GUIDE.md

**Path:** /Users/cameronbrooks/Downloads/FlipMyFIle/DEPLOY_GUIDE.md

```markdown
# Deployment Guide for FlipMyFile

This guide explains how to deploy FlipMyFile to various platforms correctly.

## Prerequisites

- Node.js installed (v14+)
- Access to the deployment platform of your choice (Vercel, Netlify, etc.)

## Deployment Options

### 1. Universal Deployment Script (Recommended)

The universal deployment script handles all the complex setup automatically:
- Configures proper file locations
- Sets correct CORS headers
- Ensures WebAssembly works in browsers

```bash
# Deploy to Vercel
npm run deploy:vercel

# Deploy to Netlify
npm run deploy:netlify

# Generic build (outputs to dist/)
npm run deploy
```

### 2. Vercel Dashboard Deployment

If you prefer to use the Vercel dashboard:

1. Run the build process locally:
   ```bash
   npm run build:vercel
   ```

2. Upload the `dist` directory to Vercel

3. Make sure the following settings are configured:
   - Output Directory: `dist`
   - Build Command: `npm run build:vercel`
   - Framework Preset: `Vite`

### 3. Manual Deployment to Any Platform

1. Run the universal build:
   ```bash
   npm run build:universal
   ```

2. The `dist` directory now contains everything needed for deployment:
   - Built application files
   - Properly configured vercel.json/netlify.toml
   - FFmpeg files in all required locations
   - Correct CORS headers

3. Upload the entire `dist` directory to your hosting platform

## Troubleshooting

If your deployment fails with WebAssembly or CORS errors:

1. Verify CORS headers are being set correctly:
   - Cross-Origin-Opener-Policy: same-origin
   - Cross-Origin-Embedder-Policy: require-corp

2. Check FFmpeg file locations:
   - Make sure ffmpeg-core.js, ffmpeg-core.wasm, etc. are in both root and public/ffmpeg-assets directories

3. Test locally first:
   ```bash
   npm run build:universal
   npx serve dist
   ```

## Key Files to Check

- `vercel.json` - Contains routing and header configurations
- `vite.universal.config.ts` - Handles file copying and configuration generation
- `deploy_universal.sh` - The main deployment script

Remember that WebAssembly requires specific CORS headers to function properly in browsers, which is why the universal deployment script is the recommended approach.```

---

### [HEICFLIP-603]_vercel_deployment_guide.md

**Path:** meta/monorepo/[HEICFLIP-603]_vercel_deployment_guide.md

```markdown
# Vercel Deployment Guide for Monorepo Variants

This guide provides specific instructions for deploying multiple converter variants from a monorepo to Vercel, with domains managed through CloudFlare.

## Vercel Monorepo Configuration

Vercel has built-in support for monorepos, which makes it ideal for our multi-variant converter project.

## Prerequisites

- GitHub repository with the monorepo structure
- Vercel account connected to GitHub
- CloudFlare account with registered domains

## Setup Process for Each Variant

### 1. Create Vercel Configuration Files

Create a `vercel.json` file in each variant package:

**For HEICFlip (`packages/heicflip/vercel.json`):**
```json
{
  "buildCommand": "cd ../.. && npm run build:heicflip",
  "outputDirectory": "packages/heicflip/dist",
  "framework": "vite",
  "rewrites": [
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
```

**For JPGFlip (`packages/jpgflip/vercel.json`):**
```json
{
  "buildCommand": "cd ../.. && npm run build:jpgflip",
  "outputDirectory": "packages/jpgflip/dist",
  "framework": "vite",
  "rewrites": [
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
```

### 2. Set Up Projects on Vercel

For each variant:

1. Log in to the Vercel dashboard
2. Select "Add New..." → "Project"
3. Import your GitHub repository
4. Configure the project:
   - **Project Name**: `heicflip` (or variant name)
   - **Framework Preset**: Choose "Other"
   - **Root Directory**: Set to the specific variant directory (e.g., `packages/heicflip`)
   - **Build Command**: Leave empty (uses vercel.json)
   - **Output Directory**: Leave empty (uses vercel.json)
   - **Environment Variables**: Add any required env variables

5. Click "Deploy"

### 3. Configure Domains on Vercel

After the initial deployment:

1. Go to the project settings in Vercel dashboard
2. Select "Domains"
3. Add your domain (e.g., `heicflip.com`)
4. Vercel will provide DNS configuration instructions

### 4. Configure DNS on CloudFlare

1. Log in to your CloudFlare dashboard
2. Select your domain
3. Go to DNS settings
4. Add the DNS records provided by Vercel:
   - Usually a CNAME record pointing to `cname.vercel-dns.com`
   - For apex domains, you might need to use CloudFlare's CNAME flattening feature

### 5. SSL Configuration

1. In CloudFlare, set SSL/TLS encryption mode to "Full" or "Full (strict)"
2. In Vercel, ensure SSL is enabled for your domain

## Automated Deployment Process

Once set up, the deployment process becomes seamless:

1. Push changes to GitHub
2. Vercel automatically detects changes
3. Each variant project only rebuilds if its files changed
4. Deployment proceeds without disrupting other variants

## Efficient Preview Deployments

Vercel creates preview deployments for pull requests:

1. Create a branch for changes to a specific variant
2. Make changes and create a pull request
3. Vercel will create a preview deployment automatically
4. Test the variant on the preview URL before merging

## Managing Multiple Variant Deployments

To keep track of all your variant deployments:

1. Create a `deployments.md` file in your repo:
   ```markdown
   # Deployment URLs
   
   | Variant | Production URL | GitHub Repository | Vercel Dashboard |
   |---------|---------------|-------------------|------------------|
   | HEICFlip | [heicflip.com](https://heicflip.com) | [GitHub](https://github.com/yourusername/converter-monorepo) | [Vercel](https://vercel.com/yourusername/heicflip) |
   | JPGFlip | [jpgflip.com](https://jpgflip.com) | [GitHub](https://github.com/yourusername/converter-monorepo) | [Vercel](https://vercel.com/yourusername/jpgflip) |
   ```

2. Add each new variant to this table as you create it

## Adding a New Variant Deployment

When creating a new variant:

1. Create the variant in your monorepo
2. Add the appropriate `vercel.json` file
3. Push to GitHub
4. Create a new project in Vercel following the steps above
5. Configure the domain in Vercel and CloudFlare
6. Update your `deployments.md` file

## Handling Domain Configuration for Multiple Variants

When using multiple domains with CloudFlare:

1. Register each domain in CloudFlare
2. Set up DNS records for each domain pointing to the appropriate Vercel deployment
3. Configure SSL/TLS settings for each domain
4. Verify domain ownership in Vercel

## Troubleshooting Common Issues

### Build Fails for Specific Variant

If a build fails for a specific variant:

1. Check the Vercel build logs
2. Ensure the variant's build command works locally
3. Verify the `vercel.json` configuration is correct

### Domain Configuration Issues

If your domain isn't connecting properly:

1. Verify DNS records in CloudFlare match Vercel's requirements
2. Check for DNS propagation delays (can take up to 48 hours)
3. Ensure CloudFlare's proxy settings are configured correctly

---

Last updated: April 30, 2025```

---

### [HEICFLIP-621]_vercel_monorepo_benefits.md

**Path:** meta/monorepo/[HEICFLIP-621]_vercel_monorepo_benefits.md

```markdown
# Vercel and npm Workspaces: Perfect Integration

This document explains why Vercel's platform works exceptionally well with npm workspace-based monorepos and the specific benefits for your converter project.

## Vercel's Built-in Monorepo Support

Vercel has built-in, first-class support for monorepos using npm workspaces. Here's why:

### 1. Automatic Project Detection

Vercel automatically detects npm workspaces in your repository and offers to create separate projects for each workspace. This makes it easy to deploy multiple applications from a single repository.

### 2. Turborepo Integration

Vercel (which acquired Turborepo) has deep integration with modern monorepo tooling. While we're using basic npm workspaces, the platform is optimized for this exact structure.

### 3. Intelligent Build Caching

Vercel uses dependency analysis to:
- Only rebuild packages that have changed
- Cache build artifacts for faster deployments
- Optimize CI/CD pipelines for monorepos

### 4. Project-Specific Environment Variables

Each project (variant) can have its own environment variables, which is perfect for:
- Different ad network configurations per variant
- Domain-specific settings
- API keys that might differ between variants

## Deployment Benefits for Your Converters

For your specific project with multiple themed converters:

### 1. Domain Mapping

Each variant can be easily deployed to its own domain:
- heicflip.com → packages/heicflip
- jpgflip.com → packages/jpgflip
- aviflip.com → packages/aviflip

### 2. Independent Updates

You can update one converter variant without affecting others:
- Fix a bug in HEICFlip while JPGFlip remains untouched
- Roll out new features to one variant at a time
- Test changes in isolation

### 3. Shared Core Updates

When you update the core package:
- Vercel intelligently rebuilds all dependent projects
- Ensures consistent functionality across all variants
- Properly resolves dependencies

### 4. Preview Deployments

For each pull request:
- Vercel creates preview deployments for affected variants
- You can test changes on actual domains before merging
- Stakeholders can review changes with real URLs

## Vercel-Specific Configuration for npm Workspaces

Vercel uses the following key configurations that align perfectly with npm workspaces:

### 1. Project Settings

For each variant, Vercel will use:
- **Root Directory**: `packages/[variant-name]`
- **Build Command**: From the variant's package.json or vercel.json
- **Output Directory**: Default `dist` or from configuration

### 2. Vercel.json Configuration (Per Variant)

Each variant should have its own `vercel.json` file:

```json
{
  "buildCommand": "cd ../.. && npm run build:[variant-name]",
  "outputDirectory": "packages/[variant-name]/dist",
  "framework": "vite"
}
```

This allows Vercel to build the projects correctly, handling workspace dependencies.

## Practical Example

Here's how our monorepo will be deployed on Vercel:

1. Push the monorepo to GitHub
2. Connect Vercel to the GitHub repository
3. Vercel detects the workspace structure
4. Create projects for each variant:
   - HEICFlip project points to packages/heicflip
   - JPGFlip project points to packages/jpgflip
5. Configure domains for each project:
   - heicflip.com → HEICFlip project
   - jpgflip.com → JPGFlip project
6. When you push changes:
   - Changes to core → all projects rebuild
   - Changes to just one variant → only that project rebuilds

## Additional Vercel Optimizations

To further optimize your Vercel deployment with npm workspaces:

1. **Build Cache**: Add `.vercel/output` to `.gitignore`
2. **Dependency Installation**: Vercel will respect your workspace setup
3. **Edge Functions**: Available per-project for any variant-specific optimizations

---

Last updated: April 30, 2025```

---

### [HEICFLIP-604]_cloudflare_domain_configuration.md

**Path:** meta/monorepo/[HEICFLIP-604]_cloudflare_domain_configuration.md

```markdown
# CloudFlare Domain Configuration for Multiple Converters

This guide provides detailed instructions for managing multiple domains on CloudFlare and connecting them to your Vercel-hosted converter variants.

## Domain Management Strategy

For a multi-variant converter project, each variant needs its own domain:
- heicflip.com
- jpgflip.com
- aviflip.com
- etc.

## CloudFlare Setup Process

### 1. Register Domains

If you haven't already:

1. Log in to CloudFlare
2. Go to "Domains" → "Register"
3. Search for and register each domain you need
4. Complete the registration process

### 2. Add Existing Domains to CloudFlare

If you already have domains registered elsewhere:

1. Log in to CloudFlare
2. Click "Add Site"
3. Enter your domain name
4. Select a plan (Free plan is sufficient for most needs)
5. Follow the instructions to update nameservers with your registrar

### 3. Configure DNS for Vercel

For each domain:

1. Go to the domain in CloudFlare dashboard
2. Select "DNS" from the menu
3. Add the appropriate DNS records for Vercel:

**For apex domains (e.g., `heicflip.com`):**
```
Type: A
Name: @
Content: 76.76.21.21
TTL: Auto
Proxy status: Proxied
```

**For www subdomain:**
```
Type: CNAME
Name: www
Content: cname.vercel-dns.com
TTL: Auto
Proxy status: Proxied
```

### 4. SSL/TLS Configuration

For optimal security:

1. Go to "SSL/TLS" in CloudFlare
2. Set encryption mode to "Full (strict)"
3. Enable "Always Use HTTPS"
4. Set minimum TLS version to 1.2

### 5. Configure Page Rules (Optional)

To enforce HTTPS and redirect www to non-www (or vice versa):

1. Go to "Rules" → "Page Rules"
2. Create a rule for HTTP to HTTPS redirect:
   - URL pattern: `http://*yourdomain.com/*`
   - Setting: "Always Use HTTPS"

3. Create a rule for www to non-www redirect (if preferred):
   - URL pattern: `www.yourdomain.com/*`
   - Setting: "Forwarding URL"
   - Status: 301
   - Destination: `https://yourdomain.com/$1`

## Verifying Domain Ownership on Vercel

After configuring DNS in CloudFlare:

1. Go to your Vercel project settings
2. Select "Domains"
3. Add your domain
4. Vercel will verify ownership via the DNS records
5. If verification fails, check your CloudFlare configuration

## Managing Multiple Domains

When managing multiple domains for different variants:

1. Create a spreadsheet or document with all domain details:
   - Domain name
   - Registrar
   - Expiration date
   - DNS configuration
   - Associated variant

2. Set calendar reminders for domain renewals

3. Create a consistent naming pattern for DNS records to stay organized

## CloudFlare Features to Leverage

### Performance

1. Enable Auto Minify (HTML, CSS, JS)
2. Enable Brotli compression
3. Configure caching rules for static assets

### Security

1. Configure Web Application Firewall (WAF)
2. Enable Bot Fight Mode
3. Set up rate limiting rules

### Analytics

1. Enable CloudFlare Analytics to track visitor metrics
2. Set up notifications for unusual traffic patterns

## Troubleshooting CloudFlare Issues

### Domain Not Connecting to Vercel

1. Verify nameservers are correctly set to CloudFlare
2. Check DNS records match Vercel's requirements
3. Temporarily disable CloudFlare proxy to test direct connection
4. Look for error messages in Vercel domain settings

### SSL Certificate Issues

1. Verify SSL mode is set to "Full" or "Full (strict)"
2. Check for certificate validation errors in CloudFlare
3. Ensure DNS is properly configured
4. Allow up to 24 hours for SSL certificate issuance

### Domain Propagation Delays

1. Use tools like [whatsmydns.net](https://www.whatsmydns.net/) to check propagation
2. Remember that DNS changes can take up to 48 hours to fully propagate
3. Test from multiple locations and networks

## Domain Management Best Practices

1. **Auto-Renewal**: Enable auto-renewal for all domains
2. **Contact Info**: Keep registrant contact information up to date
3. **Domain Locking**: Enable domain locking to prevent unauthorized transfers
4. **Email Forwarding**: Set up email forwarding for domain-based emails
5. **Documentation**: Maintain documentation of all domain settings

---

Last updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/deployment/README.md

```markdown
# Deployment Scripts

This directory contains scripts for deployment, release management, and publishing for the HEICFlip project.

## Purpose

These scripts handle various deployment operations including:
- Publishing to hosting platforms
- Managing release versions
- Configuring deployment environments
- Preparing distribution packages

## Scripts Organization

All deployment scripts follow the `[HEICFLIP-7XX]` numbering convention for clear identification:

| Number Range | Purpose |
|--------------|---------|
| 700-709 | Core deployment utility scripts |
| 710-719 | Environment-specific deployment |
| 720-729 | Release management |
| 730-739 | Distribution packaging |
| 740-749 | Post-deployment verification |

## Scripts Inventory

### Core Deployment Scripts (700-709)

- `[HEICFLIP-700]_deploy_helper.sh`: Core utility functions used by other deployment scripts

### Environment Deployment Scripts (710-719)

- `[HEICFLIP-710]_deploy_production.sh`: Deploy to production environment
- `[HEICFLIP-711]_deploy_staging.sh`: Deploy to staging environment

### Release Management (720-729)

- `[HEICFLIP-720]_create_release.sh`: Create a new release with proper versioning
- `[HEICFLIP-721]_tag_release.sh`: Tag a release in Git

### Distribution Packaging (730-739)

- `[HEICFLIP-730]_package_distribution.sh`: Create distribution packages
- `[HEICFLIP-731]_create_artifacts.sh`: Generate deployment artifacts

## Script Documentation

Each script includes a standard header:

```bash
#!/bin/bash
#
# [HEICFLIP-7XX] Script Name
#
# Purpose: Brief description of what this script does
#
# Usage: ./meta/tools/deployment/[HEICFLIP-7XX]_script_name.sh [options]
#
# Options:
#   -h, --help     Display this help message
#   -v, --verbose  Display detailed output during execution
#   -e, --env      Specify deployment environment
#
# Author: Your Name
# Date: Creation/Last Update Date
```

## Usage Guidelines

1. All scripts should be run from the project root directory
2. Scripts follow the numbering convention `[HEICFLIP-7XX]` for deployment operations
3. When deploying to production, always test on staging first
4. Create backup points before deployment operations

## Adding New Scripts

When adding a new deployment-related script:

1. Follow the numbering convention (700-799)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### [HEICFLIP-501]_deployment_guide.md

**Path:** meta/variants/[HEICFLIP-501]_deployment_guide.md

```markdown
# Deployment Guide for Converter Variants

This document provides step-by-step instructions for creating and deploying new converter variants from the base project.

## Creating a New Deployment

### Step 1: Create a New Repository

1. Create a new private GitHub repository (e.g., `heicflip`, `jpgflip`, etc.)
2. Initialize it with a README file

### Step 2: Clone the Base Project

1. Clone your base project repository:
   ```bash
   git clone https://github.com/yourusername/base-converter.git new-variant
   cd new-variant
   ```

2. Remove the existing git history:
   ```bash
   rm -rf .git
   ```

3. Initialize a new git repository:
   ```bash
   git init
   git add .
   git commit -m "Initial commit: Base converter project"
   ```

4. Connect to your new repository:
   ```bash
   git remote add origin https://github.com/yourusername/new-variant.git
   git push -u origin main
   ```

### Step 3: Customize the Configuration

1. Update the `client/src/config.ts` file:
   - Ensure your variant configuration is defined
   - Verify the `getSiteConfig()` function will return the correct configuration

2. If needed, update the domain in `vercel.json` and any other deployment-specific files

### Step 4: Deploy the Application

1. Connect your GitHub repository to your deployment platform (Vercel, Cloudflare Pages, etc.)
2. Configure the build settings:
   - Build command: `npm run build`
   - Output directory: `dist`
3. Add any required environment variables
4. Deploy!

## Maintaining Multiple Variants

### Syncing Updates from Base Project

When you make improvements to the base conversion engine or shared components:

1. Save the changes to a specific directory or branch in your base project
2. In each variant repository, pull in these changes:
   ```bash
   # Option 1: Manual copy (for small changes)
   cp -r /path/to/base-project/updated-files /path/to/variant/destination
   
   # Option 2: Add base as a remote (for larger changes)
   git remote add base https://github.com/yourusername/base-converter.git
   git fetch base
   git cherry-pick <commit-hash> # or merge specific changes
   ```

### Variant-Specific Customizations

For features specific to a particular variant:

1. Create a branch for the custom feature
2. Implement and test the changes
3. Merge to the main branch only in that variant's repository

## Recommended Workflow

1. Develop and test core functionality in the base project
2. Once stable, deploy to variant-specific repositories
3. For each variant:
   - Customize configuration and branding
   - Perform variant-specific testing
   - Deploy to production

---

Last updated: April 30, 2025```

---

### LOADERS_AND_ENCODERS.md

**Path:** scripts/deployment/enhanced-variant-generator/LOADERS_AND_ENCODERS.md

```markdown
# Loaders and Encoders System

## Overview

The Loaders and Encoders system is a Python PIL-inspired approach for handling various file formats with automatic format detection and conversion capabilities. This system is designed to be flexible, extensible, and maintainable.

## Core Concepts

### Format Registry

The Format Registry is the central component that manages all supported file formats and their associated metadata. It provides a lookup mechanism for:

- Identifying formats by file extension
- Automatic format detection from filenames
- Finding appropriate converters between formats

### Formats and Conversions

Formats are registered with minimal configuration, similar to how Python's PIL works:

```typescript
registerFormat('heic', {
  name: 'HEIC Image',
  ext: '.heic',
  mime: 'image/heic',
  variations: ['HEIC', 'heic', 'Heic'],
  description: 'High Efficiency Image Container'
});
```

Conversions between formats can be registered manually or created dynamically:

```typescript
// Manually register a conversion
registerConversion('heicToJpg', {
  name: 'HEIC to JPG',
  source: 'heic',
  target: 'jpg',
  namingVariations: [...],
  description: 'Convert HEIC images to JPG format'
});

// Or dynamically create a conversion
const conversionKey = createConverter('heic', 'jpg');
```

## Key Features

### Automatic Format Detection

The system can automatically detect the format of a file based on its extension:

```typescript
const formatKey = identifyFormat('vacation_photo.heic');
// Returns 'heic'
```

### Dynamic Conversion Creation

Conversions between formats can be created on demand:

```typescript
// Create a conversion from HEIC to WEBP
const heicToWebpKey = createConverter('heic', 'webp');
```

### Code Generation Utilities

Utilities for generating registration code make it easy to add new formats:

```typescript
const codeSnippet = generateFormatCode(
  'avif',
  'AVIF Image',
  '.avif',
  'image/avif',
  ['AVIF', 'avif', 'Avif']
);

// Returns TypeScript code to register the format
```

## Implementation Details

### Extension Lists

Format entries can have multiple extensions to support variations:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],  // Supports both extensions
  mime: 'image/jpeg',
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

### MIME Type Lists

Formats can have multiple MIME types:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],
  mime: ['image/jpeg', 'image/jpg'],  // Multiple MIME types
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

## Usage Example

A complete workflow for format identification and conversion:

```typescript
// Identify the format of a file
const sourceFormatKey = identifyFormat('photo.heic');

// Find or create a conversion to the target format
const targetFormatKey = 'jpg';
const conversionKey = createConverter(sourceFormatKey, targetFormatKey);

// In a real implementation:
// 1. Load the source file using the source format's handler
// 2. Process the image data
// 3. Save using the target format's handler
const outputFilename = 'photo.jpg';
```

## Extending The System

### Adding a New Format

To add support for a new file format:

1. Register the format with its metadata
2. Create converters to/from existing formats as needed

### Creating Custom Loaders/Encoders

In a full implementation:

1. Create the loader (decoder) module for your format
2. Create the encoder (saver) module for your format
3. Register the format with references to these modules

## Benefits Over the Previous Approach

- **Simplified Architecture**: Reduces complexity by focusing on formats rather than transformations
- **Automatic Detection**: Format detection works out of the box based on file extensions
- **Dynamic Conversions**: Conversions can be created on demand rather than pre-defined
- **Extensibility**: New formats can be added without modifying existing code
- **Maintainability**: Clearer separation of concerns between format definitions and processing logic
```

---

### TRANSFORMER_COMPARISON.md

**Path:** scripts/deployment/enhanced-variant-generator/TRANSFORMER_COMPARISON.md

```markdown
# AST vs Text-Based Transformer Comparison

This document summarizes the key differences between AST-based and text-based code transformation approaches in the HEICFlip variant generator.

## Overview

The transformer system supports two modes of operation:

1. **AST-based transformation**: Uses Babel's Abstract Syntax Tree parsing to understand code structure
2. **Text-based transformation**: Uses regex-based string replacement for simpler but less precise transformations

## Comparative Analysis

| Aspect | AST-Based Transformer | Text-Based Transformer |
|--------|----------------------|------------------------|
| **Transformation Rate** | ~56% (more selective) | ~100% (more comprehensive) |
| **Context Preservation** | High | Low |
| **Parameter Handling** | Preserves parameter names | May transform parameter names incorrectly |
| **String Replacement** | Only in string contexts | In all contexts |
| **Template Literals** | Limited handling | Full replacement |
| **Error Handling** | May fail on complex syntax | More resilient to syntax errors |
| **Performance** | Slower (parsing overhead) | Faster (direct replacement) |

## Specific Strengths

### AST-Based Transformer

✓ **Context-aware**: Understands code structure and only transforms appropriate elements
✓ **Scope-sensitive**: Preserves variables in parameter scope 
✓ **Structure-preserving**: Maintains code structure and formatting
✓ **Selective transformation**: Avoids incorrect transformations in sensitive contexts

### Text-Based Transformer

✓ **Comprehensive**: Transforms all occurrences of target strings
✓ **Resilient**: Works even with invalid or complex code structures
✓ **Fast**: No parsing overhead
✓ **Template handling**: Better at transforming template literal content

## Current Limitations

### AST-Based Transformer

- Limited transformation of template literals
- Doesn't transform some object properties consistently
- May fail to parse some complex syntax patterns
- Error code strings are sometimes incorrectly transformed

### Text-Based Transformer

- Transforms parameter names inappropriately
- Doesn't respect variable scoping
- Context-insensitive replacements can cause errors
- May transform reserved words or constants that should be preserved

## When to Use Each Approach

- **AST-based transformer**: For production-quality transformations where context preservation is critical
- **Text-based transformer**: For quick prototyping or when AST parsing fails

## Hybrid Approach Benefits

The system uses a hybrid approach that:

1. Attempts AST-based transformation first for precision
2. Falls back to text-based transformation if parsing fails
3. Provides detailed statistics about the transformation process

This approach combines the context-awareness of AST with the resilience of text-based replacement.

## Test Results

Test results consistently show that:

- AST transformation preserves ~8-14 HEIC/JPG occurrences in appropriate contexts
- Text transformation replaces all HEIC/JPG occurrences regardless of context
- Both approaches successfully transform most format references
- AST excels at context preservation, text excels at comprehensive replacement

## Recommendation

For most use cases, the hybrid approach provides the best balance of precision and completeness. Users can explicitly set the transformer mode based on their specific needs.```

---

### README.md

**Path:** scripts/deployment/enhanced-variant-generator/README.md

```markdown
# HEICFlip Format Transformation System

## Overview

The Format Transformation System is a sophisticated architecture for working with different file formats, enabling loading, transforming, and saving files with a consistent interface. Inspired by the Python Imaging Library (PIL), this system allows for seamless conversion between formats while also supporting visual identity transformations for different variant sites.

## Key Features

1. **Format Detection**: Automatic detection of file formats based on extensions
2. **Open/Save Architecture**: PIL-inspired approach to loading and saving files
3. **Visual Identity**: Consistent theming system for different formats
4. **Dynamic Registration**: Runtime registration of new formats and converters
5. **Variant Generation**: Ability to transform between different format pairs
6. **Theming Transformation**: Automatic adjustment of visual identities when switching variants

## System Architecture

The system is organized into several layers:

### Registry Layer

- **Format Registry**: Centralized storage of all format definitions and converters
- **Visual Identity Registry**: Stores visual styling elements for each format and conversion
- **Format Manager**: Manages the registration and retrieval of formats and converters

### Loader Layer

- **BaseLoader**: Abstract class implementing common functionality for all loaders
- **ILoader Interface**: Defines the contract for format loaders
- **Format-Specific Loaders**: Concrete implementations for each supported format (HEIC, JPEG, etc.)

### Transformer Layer

- **Internal Representation**: Common data structure for representing loaded files
- **Color Transformation**: Utilities for adjusting visual identities
- **Format Adaptation**: Adjustments needed for specific format conversions

### Encoder Layer

- **BaseEncoder**: Abstract class implementing common functionality for all encoders
- **IEncoder Interface**: Defines the contract for format encoders
- **Format-Specific Encoders**: Concrete implementations for each supported format

### Output Layer

- **File Output**: Mechanisms for saving to files
- **Blob Output**: Utilities for creating blobs and handling downloads

## Format Registry

The Format Registry is the central hub for managing supported formats and conversions:

```typescript
export interface Format {
  key: string;         // Unique identifier (e.g., 'heic')
  name: string;        // Display name (e.g., 'HEIC')
  extensions: string[]; // File extensions (e.g., ['.heic', '.heif'])
  mimeTypes: string[]; // MIME types (e.g., ['image/heic'])
  description: string; // Human-readable description
  loader?: any;        // Reference to loader implementation
  encoder?: any;       // Reference to encoder implementation
}

export interface Converter {
  key: string;         // Unique identifier (e.g., 'heicToJpg')
  source: string;      // Source format key
  target: string;      // Target format key
  name: string;        // Display name
  description: string; // Human-readable description
  strategies: string[]; // Available conversion strategies
  defaultStrategy: string; // Default strategy to use
}
```

## Visual Identity System

Each format and conversion has an associated visual identity:

```typescript
export interface FormatVisualIdentity {
  formatKey: string;       // Format this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for format-specific elements
  iconShape: 'circle' | 'square' | 'rounded' | 'diamond'; // Icon shape
}

export interface ConversionVisualIdentity {
  conversionKey: string;   // Conversion this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for conversion-specific elements
  gradient: string;        // Gradient using source and target colors
}
```

## Loader and Encoder System

The system uses a loader/encoder architecture for handling different formats:

### Loaders

Loaders are responsible for decoding file formats into an internal representation:

```typescript
export interface ILoader {
  supportedFormats: string[];
  load(source: any, options?: any): Promise<any>;
  canLoad(source: any): boolean;
  getInfo?(source: any): Promise<any>;
}
```

### Encoders

Encoders are responsible for encoding the internal representation into a specific file format:

```typescript
export interface IEncoder {
  supportedFormats: string[];
  encode(data: any, options?: any): Promise<any>;
  defaultOptions: Record<string, any>;
}
```

## Format Manager

The Format Manager provides a high-level API for working with formats and conversions:

```typescript
export class FormatManager {
  // Load a file from a source
  async open(source: any, formatHint?: string): Promise<any>;
  
  // Save data to a specific format
  async save(data: any, format: string, options?: any): Promise<any>;
  
  // Convert data from one format to another
  async convert(source: any, targetFormat: string, options?: any): Promise<any>;
  
  // Register a loader for a format
  registerLoader(formatKey: string, loader: any): void;
  
  // Register an encoder for a format
  registerEncoder(formatKey: string, encoder: any): void;
}
```

## Variant Generation

The Variant Generation system allows for transforming sites between different format pairs:

```typescript
interface TransformationConfig {
  sourceSourceFormat: string;  // Current source format (e.g., 'heic')
  sourceTargetFormat: string;  // Current target format (e.g., 'jpg')
  targetSourceFormat: string;  // New source format (e.g., 'png')
  targetTargetFormat: string;  // New target format (e.g., 'webp')
  inputDir: string;           // Directory containing the original site
  outputDir: string;          // Directory to write the transformed site
}

export async function transformSite(config: TransformationConfig): Promise<void>;
```

This process includes:

1. Identifying color transformations between formats
2. Updating CSS variables and selectors
3. Replacing format names in text content
4. Updating visual assets to match the new formats

## Usage Example

```typescript
// Detect format from file extension
const format = detectFormatFromExtension('image.heic'); // Returns 'heic'

// Load a HEIC file
const imageData = await formatManager.open('image.heic');

// Save as JPEG
const jpegBlob = await formatManager.save(imageData, 'jpg', { quality: 90 });

// Direct conversion
const jpegBlob = await formatManager.convert('image.heic', 'jpg', { quality: 90 });

// Transform a site from HEIC→JPG to WebP→PNG
const config = {
  sourceSourceFormat: 'heic',
  sourceTargetFormat: 'jpg',
  targetSourceFormat: 'webp',
  targetTargetFormat: 'png',
  inputDir: './original-site',
  outputDir: './transformed-site'
};
await transformSite(config);
```

## Visual Identity Transformation

The system enables transformation between different format pairs, including visual identity changes:

- **HEIC** (Orange) ↔ **JPG** (Blue)
- **HEIC** (Orange) ↔ **WebP** (Purple)
- **WebP** (Purple) ↔ **PNG** (Green)
- **AVI** (Red) ↔ **MP4** (Teal)

This allows for generating different variants of the same site with consistent branding for each format pair.

## Extending the System

To add support for a new format:

1. Add the format definition to the registry
2. Create a loader implementation
3. Create an encoder implementation
4. Add visual identity for the format
5. Register with the format manager

```typescript
// Add format to registry
registry.formats.avif = {
  key: 'avif',
  name: 'AVIF',
  extensions: ['.avif'],
  mimeTypes: ['image/avif'],
  description: 'AV1 Image File Format with excellent compression',
};

// Create and register loader
const avifLoader = new AvifLoader();
formatManager.registerLoader('avif', avifLoader);

// Create and register encoder
const avifEncoder = new AvifEncoder();
formatManager.registerEncoder('avif', avifEncoder);

// Add visual identity
visualIdentityRegistry.formats.avif = {
  formatKey: 'avif',
  primaryColor: '#6A5ACD', // Slate blue
  secondaryColor: '#5A4ABD',
  accentColor: '#8A7AED',
  cssPrefix: 'avif',
  dataAttribute: 'data-format-avif',
  iconShape: 'diamond',
};
```

## Conclusion

The Format Transformation System provides a robust and extensible framework for working with different file formats and creating variant sites. By using a consistent loader/encoder architecture and a well-defined visual identity system, it enables seamless transformation between different format pairs while maintaining consistent branding and styling.```

---

## Architecture & Design Documentation

### [HEICFLIP-610]_implementation_plan.md

**Path:** meta/monorepo/[HEICFLIP-610]_implementation_plan.md

```markdown
# Comprehensive Monorepo Implementation Plan

This document outlines the complete step-by-step process for implementing the monorepo structure for the converter applications.

## Phase 1: Preparation and Analysis

### 1. Analyze Current Codebase
- Review existing files and structure
- Identify components that can be shared across variants
- Make an inventory of dependencies

### 2. Create Directory Structure
- Create `packages` directory at the root level
- Create subdirectories for core and variants
- Set up initial configuration files

### 3. Install Required Tools
- Update npm/Node.js if needed
- Install workspace-compatible tools

## Phase 2: Core Package Extraction

### 4. Extract Core Functionality
- Move shared UI components to core package
- Extract conversion engine to core package
- Create theme system in core package
- Set up type definitions in core package

### 5. Create Build System for Core
- Set up TypeScript configuration
- Create build scripts
- Implement proper exports

## Phase 3: Create HEICFlip Variant

### 6. Move Current App to HEICFlip Variant
- Copy relevant files to the `packages/heicflip` directory
- Update imports to use core package
- Configure variant-specific settings

### 7. Update Theme Configuration
- Create theme file for HEICFlip
- Implement overrides of base theme
- Apply theme throughout the application

## Phase 4: Setup Build System

### 8. Create Root Package.json
- Configure workspaces
- Set up scripts for development and building
- Define common dependencies

### 9. Create Build Scripts
- Implement build-all script
- Create individual variant build scripts
- Set up development server configurations

## Phase 5: Create JPGFlip Variant

### 10. Create Variant Generator Script
- Implement script to create new variants
- Add color and mode configuration options
- Include proper file copying and customization

### 11. Generate JPGFlip Variant
- Run variant generator script
- Customize for JPG to HEIC conversion
- Test the new variant

## Phase 6: Deployment Configuration

### 12. Create Vercel Configuration
- Add vercel.json files for each variant
- Configure build and output settings
- Set up API endpoints if needed

### 13. Set Up Domain Configuration
- Configure CloudFlare DNS settings
- Create domain mapping for each variant
- Set up SSL certificates

## Phase 7: Testing

### 14. Test Local Development
- Verify all variants work locally
- Check that core changes propagate to variants
- Ensure proper isolation between variants

### 15. Test Build Process
- Verify all variants build correctly
- Check bundled output for optimization
- Test build script reliability

## Phase 8: Documentation

### 16. Create Developer Documentation
- Document monorepo structure
- Create guides for adding new variants
- Explain theme customization

### 17. Create Deployment Documentation
- Document Vercel deployment process
- Explain domain configuration
- Create troubleshooting guide

## Implementation Timeline

| Phase | Task | Estimated Time | Dependencies |
|-------|------|----------------|--------------|
| 1 | Preparation and Analysis | 2-3 hours | None |
| 2 | Core Package Extraction | 4-6 hours | Phase 1 |
| 3 | Create HEICFlip Variant | 2-3 hours | Phase 2 |
| 4 | Setup Build System | 2-3 hours | Phase 3 |
| 5 | Create JPGFlip Variant | 1-2 hours | Phase 4 |
| 6 | Deployment Configuration | 2-3 hours | Phase 5 |
| 7 | Testing | 3-4 hours | Phase 6 |
| 8 | Documentation | 2-3 hours | Phase 7 |

Total estimated time: 18-27 hours

## Implementation Execution Plan

### Day 1: Foundation
- Complete Phases 1-3
- Verify core functionality works in HEICFlip variant

### Day 2: Expansion
- Complete Phases 4-5
- Create at least one additional variant
- Test all variants locally

### Day 3: Deployment and Polish
- Complete Phases 6-8
- Deploy all variants
- Finalize documentation
- Conduct final testing

## Required Credentials and Information

To complete the implementation, we'll need:

1. GitHub repository access
2. Vercel account credentials (or access to deploy)
3. CloudFlare domain management access
4. Any API keys needed for external services
5. Color schemes for each variant
6. Domain names for each variant

## Approval Checkpoints

We'll seek your approval at these key stages:

1. After analyzing the current codebase and creating the directory structure
2. After extracting the core package
3. After creating the first variant (HEICFlip)
4. Before creating additional variants
5. Before deploying to Vercel
6. After deployment is complete

---

Last updated: April 30, 2025```

---

### [HEICFLIP-700]_secrets_management.md

**Path:** meta/security/[HEICFLIP-700]_secrets_management.md

```markdown
# Secure Secrets Management Guide

This document outlines best practices for securely storing and using sensitive information (API keys, passwords, etc.) in your development and deployment environments.

## Never Store Secrets in Code or Git Repositories

The most important rule: **Never store any secrets or credentials directly in your code or push them to GitHub**. This includes:

- API keys
- Database credentials
- Authentication tokens
- Passwords
- Private keys
- Environment files (.env)

## Secure Options for Storing Secrets

### 1. Vercel Environment Variables (Recommended for Production)

Vercel provides a secure way to store environment variables:

1. Go to your Vercel project dashboard
2. Navigate to "Settings" → "Environment Variables"
3. Add each secret as a key-value pair
4. Optionally scope variables to specific environments (production, preview, development)

These variables are encrypted at rest and securely injected into your application at runtime.

### 2. GitHub Secrets (For GitHub Actions)

If using GitHub Actions for CI/CD:

1. Go to your GitHub repository
2. Navigate to "Settings" → "Secrets and variables" → "Actions"
3. Add repository secrets
4. Reference them in workflows using `${{ secrets.SECRET_NAME }}`

### 3. Environment Files (.env) for Local Development

For local development:

1. Create a `.env` file in your project root
2. Add your secrets in KEY=VALUE format
3. Add `.env` to your `.gitignore` file to prevent accidental commits
4. Create a `.env.example` file with placeholder values for documentation

Example `.env` file:
```
API_KEY=your_actual_key_here
DATABASE_URL=postgresql://username:password@localhost:5432/database
```

Example `.env.example` file (safe to commit):
```
API_KEY=your_api_key_here
DATABASE_URL=postgresql://username:password@localhost:5432/database
```

### 4. For Replit Development Environment

When using Replit:

1. Go to the "Secrets" tab (lock icon) in your Replit project
2. Add your secrets as key-value pairs
3. Access them in your code via environment variables

## Accessing Secrets in Your Application

### In JavaScript/TypeScript:

```javascript
// Access environment variables
const apiKey = process.env.API_KEY;
const databaseUrl = process.env.DATABASE_URL;

// For client-side code (must be prefixed with VITE_ for Vite projects)
// Only include public/non-sensitive keys here
const publicApiKey = import.meta.env.VITE_PUBLIC_API_KEY;
```

> **IMPORTANT**: Only environment variables prefixed with `VITE_` are exposed to client-side code. Never prefix sensitive variables with `VITE_`.

## Managing Different Environment Variables Across Variants

For your monorepo with multiple variants, you may need different secrets for each:

### Variant-Specific Variables in Vercel

1. Create separate Vercel projects for each variant
2. Configure environment variables specific to each project
3. Use naming conventions to keep variables organized:
   ```
   HEICFLIP_API_KEY=xxxxx
   JPGFLIP_API_KEY=yyyyy
   ```

## External API Operations

When performing operations that require sensitive data:

1. Store API keys and credentials securely using methods above
2. Create backend API routes that use these credentials server-side
3. Call these routes from frontend code instead of directly calling external APIs
4. Implement proper authentication for your API routes

Example backend route (server-side):
```javascript
app.post("/api/external-operation", async (req, res) => {
  // Get the API key from environment variables (not exposed to client)
  const apiKey = process.env.EXTERNAL_API_KEY;
  
  try {
    // Use the API key to call external service
    const result = await callExternalService(apiKey, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: "Operation failed" });
  }
});
```

## Periodic Secret Rotation

Improve security by regularly updating your secrets:

1. Set calendar reminders to update API keys every 90-180 days
2. Use different keys for development and production environments
3. Document the rotation process for each type of secret

## Security Checklist

- [ ] No secrets in code or GitHub repositories
- [ ] Environment variables configured in Vercel
- [ ] `.env` files added to `.gitignore`
- [ ] Provided `.env.example` with placeholder values
- [ ] Client-side code only accesses non-sensitive environment variables
- [ ] Backend routes created for operations requiring sensitive data
- [ ] Secret rotation schedule established

---

Last updated: April 30, 2025```

---

### [HEICFLIP-900]_BACKUP_SYSTEM.md

**Path:** meta/docs/backup-system/[HEICFLIP-900]_BACKUP_SYSTEM.md

```markdown
# [HEICFLIP-900] Backup System

This document describes the backup and restore system for the HEICFlip project, designed to provide a simple way to save and restore project states.

## Overview

The backup system consists of two main scripts:
- `[HEICFLIP-910]_save_version.sh` - Creates a backup of the current project state
- `[HEICFLIP-911]_restore_version.sh` - Restores the project from a saved backup

These scripts provide a safety net during development, allowing quick recovery if something goes wrong.

## Script Locations

The backup system scripts are located in:
```
meta/tools/backup/
```

However, for convenience, shortcut scripts are available in the project root:
- `save_current_version.sh` (calls the [HEICFLIP-910] script)
- `restore_from_save.sh` (calls the [HEICFLIP-911] script)

## Creating a Backup

To create a backup of the current project state:

```bash
# Preferred method (direct)
./meta/tools/backup/[HEICFLIP-910]_save_version.sh

# Alternative (using shortcut script)
./save_current_version.sh
```

### What Gets Backed Up

The backup includes:
- All code in `client/`, `server/`, and `shared/` directories
- Documentation in `meta/` and `docs/` directories
- Configuration files (*.json, *.ts, *.js, etc.)
- Documentation files (README.md, [HEICFLIP-XXX]*.md)
- Build output in `dist/` (if present)

### Backup Location

Files are saved to the `restore_point/` directory in the project root. This directory serves as a single restore point, which is overwritten each time you create a new backup.

### Backup Timestamp

Each backup includes a timestamp file (`SAVE_TIMESTAMP.txt`) that records when the backup was created, making it easy to identify the backup's age.

## Restoring from a Backup

To restore the project from a saved backup:

```bash
# Preferred method (direct)
./meta/tools/backup/[HEICFLIP-911]_restore_version.sh

# Alternative (using shortcut script)
./restore_from_save.sh
```

### Restore Process

The restore process:
1. Creates a temporary backup of the current state (in case restoration fails)
2. Copies all files from `restore_point/` back to their original locations
3. Notifies you when the restore is complete

### Safety Features

Before restoring, the system:
- Checks if a restore point exists
- Creates a pre-restore backup as a fallback (in the `backups/` directory)
- Shows the creation date of the backup being restored

## Best Practices

1. **Create Regular Backups**:
   - Before making significant changes
   - After completing a feature
   - When the project is in a known good state

2. **Document Your Backups**:
   - Note what was working when you created the backup
   - Consider adding comments to indicate the state of the project

3. **Test Restored Versions**:
   - After restoring, verify that the application works correctly
   - Restart the development server to ensure changes take effect

## Common Use Cases

- **Before Refactoring**: Save a backup before major refactoring work
- **Development Milestones**: Save backups at key milestones
- **Troubleshooting**: Create backups during debugging to try different approaches
- **Feature Branches**: Use backups as lightweight alternatives to git branches

## Limitations

- The system only maintains a single restore point
- Node modules are not backed up (run `npm install` after restoring if needed)
- Environment variables are not included in backups

## For AI Assistants

When a user requests:
- "Please save this current version to the restore file" → Run `./meta/tools/backup/[HEICFLIP-910]_save_version.sh`
- "Please restore from the saved restore point" → Run `./meta/tools/backup/[HEICFLIP-911]_restore_version.sh`

Last Updated: April 30, 2025```

---

### [HEICFLIP-900]_BACKUP_SYSTEM.md

**Path:** meta/docs/[HEICFLIP-900]_BACKUP_SYSTEM.md

```markdown
# [HEICFLIP-900] Backup System Guide

This document explains HEICFlip's backup and restore system, which provides a safety net during development and helps preserve AI context across conversations.

## Overview

The backup system consists of two main scripts:

1. `[HEICFLIP-910]_save_version.sh` - Saves the current project state
2. `[HEICFLIP-911]_restore_version.sh` - Restores from a saved project state

These scripts are designed to be run **manually** before making significant changes or when you want to preserve the current project state for future reference.

## When to Create Backups

Create a backup in these situations:

- **Before major changes**: Save a restore point before making significant code changes
- **After completing features**: Save a working state when you've completed a feature
- **To preserve AI context**: Save before ending a session to help the AI remember progress
- **Before testing risky changes**: Save before experimenting with changes that might break functionality
- **Once per active development day**: A daily backup provides a good fallback point

## How to Use the Backup System

### Creating a Backup

To save the current project state:

```bash
./meta/tools/backup/[HEICFLIP-910]_save_version.sh
```

Or simply ask the AI:

```
Please save the current version to the restore point
```

### Restoring from a Backup

To restore from a previously saved state:

```bash
./meta/tools/backup/[HEICFLIP-911]_restore_version.sh
```

Or simply ask the AI:

```
Please restore from the saved restore point
```

## Preserving AI Context

One of the key benefits of the backup system is preserving AI context across conversations. Here's how to make the most of it:

1. **Save state at session end**:
   Before ending a conversation with the AI, create a backup to save the current state.

2. **Document progress in AI_GUIDE.md**:
   Ask the AI to update the AI_GUIDE.md file with a summary of what has been done so far.

3. **Restore at session start**:
   When starting a new session, restore the backup to help the AI recall the context.

4. **Reference the navigation index**:
   Direct the AI to check the `[HEICFLIP-000]_AI_NAVIGATION_INDEX.md` file for orientation.

## What Gets Backed Up

The backup system saves:

- All source code in `client/`, `server/`, and `shared/` directories
- Configuration files (package.json, tsconfig.json, etc.)
- Documentation in `meta/docs/`
- Tools and scripts in `meta/tools/`
- Essential root-level files like README.md

## Recovery from Failed Restoration

If a restore operation fails or causes problems, a temporary backup is automatically created before restoration begins. The path to this backup is displayed at the end of the restore operation.

## Keeping the System Updated

As the project evolves:

1. Update the backup scripts if new directories or essential files are added
2. Ensure all new documentation follows the [HEICFLIP-XXX] naming convention
3. Keep the AI_GUIDE.md updated with the latest project status

## Troubleshooting

If you encounter issues with the backup system:

1. **Backup seems empty**:
   Check that you're running the script from the project root directory.

2. **Restoration doesn't include recent files**:
   Ensure you've created a fresh backup before trying to restore.

3. **Script permissions issues**:
   Run `chmod +x meta/tools/backup/*.sh` to ensure the scripts are executable.

Last Updated: April 30, 2025```

---

## Format Support Documentation

### BACKUP_README.md

**Path:** formatflip_complete/scripts/BACKUP_README.md

```markdown
# HEICFlip Backup System

This directory contains scripts for creating, managing, and restoring backups of the HEICFlip project.

## Available Scripts

### 1. Create a Backup

```bash
./scripts/create_backup.sh
```

This script will create a backup of critical project files in the `backups/` directory. Each backup is stored in a timestamped folder (e.g., `backups/backup_20250501_155018`).

The backup includes:
- Configuration files (drizzle.config.ts, postcss.config.js, tailwind.config.ts, etc.)
- Server files
- Shared files
- Enhanced variant generator scripts
- Client files (if they exist)
- Demo HTML files

### 2. List Available Backups

```bash
./scripts/list_backups.sh
```

This script displays all available backups in reverse chronological order (newest first), showing:
- Backup directory path
- Creation date and time
- Number of files in the backup
- Summary information

### 3. Restore from a Backup

```bash
./scripts/restore_backup.sh backups/backup_YYYYMMDD_HHMMSS
```

This script restores files from a specified backup. It will prompt for confirmation before proceeding, as this action will overwrite existing files.

To view available backups to restore from, run the `list_backups.sh` script or omit the backup directory parameter:

```bash
./scripts/restore_backup.sh
```

## Important Notes

- Backups are stored in the `backups/` directory within the project
- After restoring from a backup, you may need to restart the application for changes to take effect
- These backup scripts focus on code and configuration files, not database content
- For complete project backup, consider also backing up any database content separately
```

---

### LOADERS_AND_ENCODERS.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/LOADERS_AND_ENCODERS.md

```markdown
# Loaders and Encoders System

## Overview

The Loaders and Encoders system is a Python PIL-inspired approach for handling various file formats with automatic format detection and conversion capabilities. This system is designed to be flexible, extensible, and maintainable.

## Core Concepts

### Format Registry

The Format Registry is the central component that manages all supported file formats and their associated metadata. It provides a lookup mechanism for:

- Identifying formats by file extension
- Automatic format detection from filenames
- Finding appropriate converters between formats

### Formats and Conversions

Formats are registered with minimal configuration, similar to how Python's PIL works:

```typescript
registerFormat('heic', {
  name: 'HEIC Image',
  ext: '.heic',
  mime: 'image/heic',
  variations: ['HEIC', 'heic', 'Heic'],
  description: 'High Efficiency Image Container'
});
```

Conversions between formats can be registered manually or created dynamically:

```typescript
// Manually register a conversion
registerConversion('heicToJpg', {
  name: 'HEIC to JPG',
  source: 'heic',
  target: 'jpg',
  namingVariations: [...],
  description: 'Convert HEIC images to JPG format'
});

// Or dynamically create a conversion
const conversionKey = createConverter('heic', 'jpg');
```

## Key Features

### Automatic Format Detection

The system can automatically detect the format of a file based on its extension:

```typescript
const formatKey = identifyFormat('vacation_photo.heic');
// Returns 'heic'
```

### Dynamic Conversion Creation

Conversions between formats can be created on demand:

```typescript
// Create a conversion from HEIC to WEBP
const heicToWebpKey = createConverter('heic', 'webp');
```

### Code Generation Utilities

Utilities for generating registration code make it easy to add new formats:

```typescript
const codeSnippet = generateFormatCode(
  'avif',
  'AVIF Image',
  '.avif',
  'image/avif',
  ['AVIF', 'avif', 'Avif']
);

// Returns TypeScript code to register the format
```

## Implementation Details

### Extension Lists

Format entries can have multiple extensions to support variations:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],  // Supports both extensions
  mime: 'image/jpeg',
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

### MIME Type Lists

Formats can have multiple MIME types:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],
  mime: ['image/jpeg', 'image/jpg'],  // Multiple MIME types
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

## Usage Example

A complete workflow for format identification and conversion:

```typescript
// Identify the format of a file
const sourceFormatKey = identifyFormat('photo.heic');

// Find or create a conversion to the target format
const targetFormatKey = 'jpg';
const conversionKey = createConverter(sourceFormatKey, targetFormatKey);

// In a real implementation:
// 1. Load the source file using the source format's handler
// 2. Process the image data
// 3. Save using the target format's handler
const outputFilename = 'photo.jpg';
```

## Extending The System

### Adding a New Format

To add support for a new file format:

1. Register the format with its metadata
2. Create converters to/from existing formats as needed

### Creating Custom Loaders/Encoders

In a full implementation:

1. Create the loader (decoder) module for your format
2. Create the encoder (saver) module for your format
3. Register the format with references to these modules

## Benefits Over the Previous Approach

- **Simplified Architecture**: Reduces complexity by focusing on formats rather than transformations
- **Automatic Detection**: Format detection works out of the box based on file extensions
- **Dynamic Conversions**: Conversions can be created on demand rather than pre-defined
- **Extensibility**: New formats can be added without modifying existing code
- **Maintainability**: Clearer separation of concerns between format definitions and processing logic
```

---

### TRANSFORMER_COMPARISON.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/TRANSFORMER_COMPARISON.md

```markdown
# AST vs Text-Based Transformer Comparison

This document summarizes the key differences between AST-based and text-based code transformation approaches in the HEICFlip variant generator.

## Overview

The transformer system supports two modes of operation:

1. **AST-based transformation**: Uses Babel's Abstract Syntax Tree parsing to understand code structure
2. **Text-based transformation**: Uses regex-based string replacement for simpler but less precise transformations

## Comparative Analysis

| Aspect | AST-Based Transformer | Text-Based Transformer |
|--------|----------------------|------------------------|
| **Transformation Rate** | ~56% (more selective) | ~100% (more comprehensive) |
| **Context Preservation** | High | Low |
| **Parameter Handling** | Preserves parameter names | May transform parameter names incorrectly |
| **String Replacement** | Only in string contexts | In all contexts |
| **Template Literals** | Limited handling | Full replacement |
| **Error Handling** | May fail on complex syntax | More resilient to syntax errors |
| **Performance** | Slower (parsing overhead) | Faster (direct replacement) |

## Specific Strengths

### AST-Based Transformer

✓ **Context-aware**: Understands code structure and only transforms appropriate elements
✓ **Scope-sensitive**: Preserves variables in parameter scope 
✓ **Structure-preserving**: Maintains code structure and formatting
✓ **Selective transformation**: Avoids incorrect transformations in sensitive contexts

### Text-Based Transformer

✓ **Comprehensive**: Transforms all occurrences of target strings
✓ **Resilient**: Works even with invalid or complex code structures
✓ **Fast**: No parsing overhead
✓ **Template handling**: Better at transforming template literal content

## Current Limitations

### AST-Based Transformer

- Limited transformation of template literals
- Doesn't transform some object properties consistently
- May fail to parse some complex syntax patterns
- Error code strings are sometimes incorrectly transformed

### Text-Based Transformer

- Transforms parameter names inappropriately
- Doesn't respect variable scoping
- Context-insensitive replacements can cause errors
- May transform reserved words or constants that should be preserved

## When to Use Each Approach

- **AST-based transformer**: For production-quality transformations where context preservation is critical
- **Text-based transformer**: For quick prototyping or when AST parsing fails

## Hybrid Approach Benefits

The system uses a hybrid approach that:

1. Attempts AST-based transformation first for precision
2. Falls back to text-based transformation if parsing fails
3. Provides detailed statistics about the transformation process

This approach combines the context-awareness of AST with the resilience of text-based replacement.

## Test Results

Test results consistently show that:

- AST transformation preserves ~8-14 HEIC/JPG occurrences in appropriate contexts
- Text transformation replaces all HEIC/JPG occurrences regardless of context
- Both approaches successfully transform most format references
- AST excels at context preservation, text excels at comprehensive replacement

## Recommendation

For most use cases, the hybrid approach provides the best balance of precision and completeness. Users can explicitly set the transformer mode based on their specific needs.```

---

### README.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/README.md

```markdown
# HEICFlip Format Transformation System

## Overview

The Format Transformation System is a sophisticated architecture for working with different file formats, enabling loading, transforming, and saving files with a consistent interface. Inspired by the Python Imaging Library (PIL), this system allows for seamless conversion between formats while also supporting visual identity transformations for different variant sites.

## Key Features

1. **Format Detection**: Automatic detection of file formats based on extensions
2. **Open/Save Architecture**: PIL-inspired approach to loading and saving files
3. **Visual Identity**: Consistent theming system for different formats
4. **Dynamic Registration**: Runtime registration of new formats and converters
5. **Variant Generation**: Ability to transform between different format pairs
6. **Theming Transformation**: Automatic adjustment of visual identities when switching variants

## System Architecture

The system is organized into several layers:

### Registry Layer

- **Format Registry**: Centralized storage of all format definitions and converters
- **Visual Identity Registry**: Stores visual styling elements for each format and conversion
- **Format Manager**: Manages the registration and retrieval of formats and converters

### Loader Layer

- **BaseLoader**: Abstract class implementing common functionality for all loaders
- **ILoader Interface**: Defines the contract for format loaders
- **Format-Specific Loaders**: Concrete implementations for each supported format (HEIC, JPEG, etc.)

### Transformer Layer

- **Internal Representation**: Common data structure for representing loaded files
- **Color Transformation**: Utilities for adjusting visual identities
- **Format Adaptation**: Adjustments needed for specific format conversions

### Encoder Layer

- **BaseEncoder**: Abstract class implementing common functionality for all encoders
- **IEncoder Interface**: Defines the contract for format encoders
- **Format-Specific Encoders**: Concrete implementations for each supported format

### Output Layer

- **File Output**: Mechanisms for saving to files
- **Blob Output**: Utilities for creating blobs and handling downloads

## Format Registry

The Format Registry is the central hub for managing supported formats and conversions:

```typescript
export interface Format {
  key: string;         // Unique identifier (e.g., 'heic')
  name: string;        // Display name (e.g., 'HEIC')
  extensions: string[]; // File extensions (e.g., ['.heic', '.heif'])
  mimeTypes: string[]; // MIME types (e.g., ['image/heic'])
  description: string; // Human-readable description
  loader?: any;        // Reference to loader implementation
  encoder?: any;       // Reference to encoder implementation
}

export interface Converter {
  key: string;         // Unique identifier (e.g., 'heicToJpg')
  source: string;      // Source format key
  target: string;      // Target format key
  name: string;        // Display name
  description: string; // Human-readable description
  strategies: string[]; // Available conversion strategies
  defaultStrategy: string; // Default strategy to use
}
```

## Visual Identity System

Each format and conversion has an associated visual identity:

```typescript
export interface FormatVisualIdentity {
  formatKey: string;       // Format this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for format-specific elements
  iconShape: 'circle' | 'square' | 'rounded' | 'diamond'; // Icon shape
}

export interface ConversionVisualIdentity {
  conversionKey: string;   // Conversion this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for conversion-specific elements
  gradient: string;        // Gradient using source and target colors
}
```

## Loader and Encoder System

The system uses a loader/encoder architecture for handling different formats:

### Loaders

Loaders are responsible for decoding file formats into an internal representation:

```typescript
export interface ILoader {
  supportedFormats: string[];
  load(source: any, options?: any): Promise<any>;
  canLoad(source: any): boolean;
  getInfo?(source: any): Promise<any>;
}
```

### Encoders

Encoders are responsible for encoding the internal representation into a specific file format:

```typescript
export interface IEncoder {
  supportedFormats: string[];
  encode(data: any, options?: any): Promise<any>;
  defaultOptions: Record<string, any>;
}
```

## Format Manager

The Format Manager provides a high-level API for working with formats and conversions:

```typescript
export class FormatManager {
  // Load a file from a source
  async open(source: any, formatHint?: string): Promise<any>;
  
  // Save data to a specific format
  async save(data: any, format: string, options?: any): Promise<any>;
  
  // Convert data from one format to another
  async convert(source: any, targetFormat: string, options?: any): Promise<any>;
  
  // Register a loader for a format
  registerLoader(formatKey: string, loader: any): void;
  
  // Register an encoder for a format
  registerEncoder(formatKey: string, encoder: any): void;
}
```

## Variant Generation

The Variant Generation system allows for transforming sites between different format pairs:

```typescript
interface TransformationConfig {
  sourceSourceFormat: string;  // Current source format (e.g., 'heic')
  sourceTargetFormat: string;  // Current target format (e.g., 'jpg')
  targetSourceFormat: string;  // New source format (e.g., 'png')
  targetTargetFormat: string;  // New target format (e.g., 'webp')
  inputDir: string;           // Directory containing the original site
  outputDir: string;          // Directory to write the transformed site
}

export async function transformSite(config: TransformationConfig): Promise<void>;
```

This process includes:

1. Identifying color transformations between formats
2. Updating CSS variables and selectors
3. Replacing format names in text content
4. Updating visual assets to match the new formats

## Usage Example

```typescript
// Detect format from file extension
const format = detectFormatFromExtension('image.heic'); // Returns 'heic'

// Load a HEIC file
const imageData = await formatManager.open('image.heic');

// Save as JPEG
const jpegBlob = await formatManager.save(imageData, 'jpg', { quality: 90 });

// Direct conversion
const jpegBlob = await formatManager.convert('image.heic', 'jpg', { quality: 90 });

// Transform a site from HEIC→JPG to WebP→PNG
const config = {
  sourceSourceFormat: 'heic',
  sourceTargetFormat: 'jpg',
  targetSourceFormat: 'webp',
  targetTargetFormat: 'png',
  inputDir: './original-site',
  outputDir: './transformed-site'
};
await transformSite(config);
```

## Visual Identity Transformation

The system enables transformation between different format pairs, including visual identity changes:

- **HEIC** (Orange) ↔ **JPG** (Blue)
- **HEIC** (Orange) ↔ **WebP** (Purple)
- **WebP** (Purple) ↔ **PNG** (Green)
- **AVI** (Red) ↔ **MP4** (Teal)

This allows for generating different variants of the same site with consistent branding for each format pair.

## Extending the System

To add support for a new format:

1. Add the format definition to the registry
2. Create a loader implementation
3. Create an encoder implementation
4. Add visual identity for the format
5. Register with the format manager

```typescript
// Add format to registry
registry.formats.avif = {
  key: 'avif',
  name: 'AVIF',
  extensions: ['.avif'],
  mimeTypes: ['image/avif'],
  description: 'AV1 Image File Format with excellent compression',
};

// Create and register loader
const avifLoader = new AvifLoader();
formatManager.registerLoader('avif', avifLoader);

// Create and register encoder
const avifEncoder = new AvifEncoder();
formatManager.registerEncoder('avif', avifEncoder);

// Add visual identity
visualIdentityRegistry.formats.avif = {
  formatKey: 'avif',
  primaryColor: '#6A5ACD', // Slate blue
  secondaryColor: '#5A4ABD',
  accentColor: '#8A7AED',
  cssPrefix: 'avif',
  dataAttribute: 'data-format-avif',
  iconShape: 'diamond',
};
```

## Conclusion

The Format Transformation System provides a robust and extensible framework for working with different file formats and creating variant sites. By using a consistent loader/encoder architecture and a well-defined visual identity system, it enables seamless transformation between different format pairs while maintaining consistent branding and styling.```

---

### [HEICFLIP-645]_ast_transformation.md

**Path:** meta/variant-creation/[HEICFLIP-645]_ast_transformation.md

```markdown
# AST-Based Code Transformation

This document details how the Enhanced Variant Generator uses Abstract Syntax Tree (AST) parsing to perform intelligent, context-aware format transformations across the codebase.

## Why AST-Based Transformation Is Superior

When creating new format variants, a naive approach using simple string replacement would lead to numerous problems:

1. **Over-replacement**: Turning unrelated occurrences (like "cheaper" becoming "cmpvper" when replacing "heic" with "mpv")
2. **Under-replacement**: Missing format references in complex contexts like template strings or JSX
3. **Context loss**: Failing to preserve code structure and formatting during replacement
4. **Case preservation**: Not matching the right case pattern in different contexts

The AST-based approach solves these problems by parsing code into a structured tree representation, allowing for precise, context-aware transformations.

## Implementation Details

The AST transformation process works in three stages:

### 1. Parsing

```javascript
// Parse the source code to generate an AST
const ast = parser.parse(sourceCode, {
  sourceType: 'module',
  plugins: ['jsx', 'typescript', 'classProperties', 'decorators-legacy'],
  attachComments: true
});
```

This creates a complete tree representation of the code, including:
- Variable and function declarations
- Class definitions
- Import/export statements
- JSX elements
- Comments (both block and line comments)

### 2. Tree Traversal and Transformation

The transformer uses Babel's traverse API to visit different node types and apply context-appropriate transformations:

```javascript
// Example: Transform identifiers (variable names, function names, etc.)
Identifier(path) {
  const name = path.node.name;
  
  // Only match whole words or parts of camelCase/PascalCase identifiers
  const regex = new RegExp(
    `(^|[^a-zA-Z0-9])${escapeRegExp(variant)}($|[^a-zA-Z0-9])|` +
    `([a-z])${escapeRegExp(variant)}([A-Z]|$)|` +
    `([A-Z])${escapeRegExp(variant)}([A-Z]|$)`,
    'g'
  );
  
  if (regex.test(name)) {
    // Apply transformation with case-preservation
    if (variant === variant.toUpperCase()) {
      // All uppercase: HEIC → MKV
      newName = newName.replace(
        new RegExp(escapeRegExp(variant), 'g'),
        targetVariant.toUpperCase()
      );
    } else if (variant[0] === variant[0].toUpperCase()) {
      // Pascal case: Heic → Mkv
      newName = newName.replace(
        new RegExp(escapeRegExp(variant), 'g'),
        targetVariant[0].toUpperCase() + targetVariant.slice(1)
      );
    } else {
      // Camel case: heic → mkv
      newName = newName.replace(
        new RegExp(escapeRegExp(variant), 'g'),
        targetVariant.toLowerCase()
      );
    }
  }
}
```

The system processes various node types:

| Node Type | Description | Examples | Transformation Approach |
|-----------|-------------|----------|-------------------------|
| Identifier | Variable/function/class names | `heicFile`, `HeicToJpgConverter` | Case-aware replacement with word boundary detection |
| StringLiteral | String constants | `"Convert your HEIC files"` | Direct replacement with context preservation |
| TemplateLiteral | Template strings | `` `Process ${count} HEIC files` `` | Replace in both static and dynamic parts |
| JSXText | Text in JSX elements | `<p>HEIC to JPG converter</p>` | Format-aware replacement |
| Comments | Code comments | `// Convert HEIC to JPG` | Context-aware replacement |

### 3. Code Generation

After transformation, the modified AST is converted back to code with formatting preserved:

```javascript
// Generate code from the transformed AST
const output = generate(ast, {
  comments: true,
  retainLines: true,
  compact: false
});

// Format the code using prettier
const formattedCode = prettier.format(output.code, {
  parser: 'babel',
  singleQuote: true,
  trailingComma: 'es5',
  bracketSpacing: true,
  semi: true,
  printWidth: 100
});
```

## Fallback Strategy

Since not all files can be parsed as valid JavaScript/TypeScript (e.g., JSON, MD files), the system includes a fallback to simpler text-based replacement:

```javascript
function textBasedTransform(sourceCode, sourceMode, targetMode) {
  // Get format information from registry
  const registry = loadFormatRegistry();
  // ...
  
  // Apply transformations with proper escaping
  sourceFormat.variations.forEach((variant, index) => {
    const targetVariant = index < targetFormat.variations.length
      ? targetFormat.variations[index]
      : targetFormat.variations[0];
    
    transformedCode = transformedCode.replace(
      new RegExp(escapeRegExp(variant), 'g'),
      targetVariant
    );
  });
  
  // ...
}
```

This ensures that all files can be processed, even if the optimal AST-based approach isn't applicable.

## Real-World Example: Converting HeicToJpgConverter to MkvToMp4Converter

### Original Code

```typescript
/**
 * HeicToJpgConverter class
 * Converts HEIC images to the more widely supported JPG format.
 */
export class HeicToJpgConverter extends BaseConverter {
  /**
   * Process a HEIC file and convert it to JPG
   * @param heicFile The input HEIC file to convert
   * @returns Promise containing the converted JPG file
   */
  async convert(heicFile: File): Promise<File> {
    console.log(`Converting ${heicFile.name} from HEIC to JPG format`);
    
    // Check if the input is actually a HEIC file
    if (!this.isHeicFile(heicFile)) {
      throw new Error("Input is not a valid HEIC file");
    }
    
    // Convert using HEIC-specific settings
    const jpgBlob = await this.processHeicToJpg(heicFile);
    return new File(
      [jpgBlob], 
      heicFile.name.replace(".heic", ".jpg"),
      { type: "image/jpeg" }
    );
  }
  
  /**
   * Check if a file is in HEIC format
   */
  private isHeicFile(file: File): boolean {
    return file.type === "image/heic" || 
           file.name.toLowerCase().endsWith(".heic");
  }
}
```

### Transformed Code

```typescript
/**
 * MkvToMp4Converter class
 * Converts MKV videos to the more widely supported MP4 format.
 */
export class MkvToMp4Converter extends BaseConverter {
  /**
   * Process a MKV file and convert it to MP4
   * @param mkvFile The input MKV file to convert
   * @returns Promise containing the converted MP4 file
   */
  async convert(mkvFile: File): Promise<File> {
    console.log(`Converting ${mkvFile.name} from MKV to MP4 format`);
    
    // Check if the input is actually a MKV file
    if (!this.isMkvFile(mkvFile)) {
      throw new Error("Input is not a valid MKV file");
    }
    
    // Convert using MKV-specific settings
    const mp4Blob = await this.processMkvToMp4(mkvFile);
    return new File(
      [mp4Blob], 
      mkvFile.name.replace(".mkv", ".mp4"),
      { type: "video/mp4" }
    );
  }
  
  /**
   * Check if a file is in MKV format
   */
  private isMkvFile(file: File): boolean {
    return file.type === "video/x-matroska" || 
           file.name.toLowerCase().endsWith(".mkv");
  }
}
```

Notice how the transformation correctly handled:
- Class name: `HeicToJpgConverter` → `MkvToMp4Converter`
- Method names: `processHeicToJpg` → `processMkvToMp4`
- Variable names: `heicFile` → `mkvFile`, `jpgBlob` → `mp4Blob`
- Comment text: "HEIC images" → "MKV videos"
- String literals: "Input is not a valid HEIC file" → "Input is not a valid MKV file"
- File extensions: ".heic" → ".mkv", ".jpg" → ".mp4"
- MIME types: "image/heic" → "video/x-matroska", "image/jpeg" → "video/mp4"

## Benefits of the AST Approach

1. **Precision**: Only transforms format-specific elements, not unrelated code
2. **Context awareness**: Understands the role of each code element (variable, string, comment)
3. **Case preservation**: Maintains appropriate casing for identifiers
4. **Structure preservation**: Keeps code structure and formatting intact
5. **Comment handling**: Properly transforms format references in comments
6. **Comprehensive coverage**: Catches all format references in various contexts
7. **Fallback capability**: Provides simpler transformations when AST parsing isn't possible

## Limitations and Edge Cases

While the AST approach is powerful, it has some limitations:

1. **Dynamic code**: Code generated at runtime (via eval or Function constructor) can't be transformed
2. **Non-standard syntax**: Some experimental JS/TS features might not parse correctly
3. **Embedded formats in strings**: Format references within larger strings might be missed
4. **Generated code quality**: Very complex transformations might result in slightly different formatting

The system addresses these with:
- Fallback mechanisms for unparseable files
- Comprehensive format registry with variations
- Careful regex patterns for string replacement
- Code formatting with Prettier post-transformation

---

Last updated: April 30, 2025```

---

### [HEICFLIP-642]_comprehensive_format_replacement.md

**Path:** meta/variant-creation/[HEICFLIP-642]_comprehensive_format_replacement.md

```markdown
# Comprehensive Format Reference Replacement

## The Problem

The current approach to variant creation has several critical weaknesses:

1. **Hidden Format References**: Format-specific strings may be embedded throughout the codebase in:
   - Variable and function names
   - Type definitions and interfaces
   - Comments and documentation 
   - Helper methods and utility functions
   - Error messages and user-facing text

2. **Inconsistent Replacement**: Simple string replacement is inadequate because:
   - It fails to understand code context
   - It might replace portions of unrelated words
   - It misses references in camelCase or other variations
   - It doesn't handle format combinations correctly

3. **Documentation/Code Mismatch**: Even if the code works functionally, having documentation reference the wrong formats leads to:
   - Developer confusion
   - Debugging difficulties
   - Maintenance problems
   - Loss of trust in the codebase

## Comprehensive Solution

We will implement a more sophisticated format replacement system that operates at multiple levels:

### 1. AST-Based Code Analysis and Transformation

Rather than simple string replacement, we'll use Abstract Syntax Tree (AST) analysis to understand code context:

```javascript
// Using a JavaScript parser like babel or typescript to parse code into an AST
const ast = parser.parse(sourceCode);

// Use AST traversal to find identifiers in context
traverse(ast, {
  Identifier(path) {
    // Check if identifier contains format reference
    if (containsFormatReference(path.node.name)) {
      // Replace with appropriate variant while preserving casing and context
      path.node.name = transformFormatReference(path.node.name, sourceFormat, targetFormat);
    }
  },
  StringLiteral(path) {
    // Handle string literals that might contain format references
    if (containsFormatReference(path.node.value)) {
      path.node.value = transformFormatReference(path.node.value, sourceFormat, targetFormat);
    }
  },
  // Add handlers for JSDoc, comments, etc.
});
```

### 2. Comment and Documentation Scanning

We'll specifically scan comments and documentation, understanding their context:

```javascript
// Process comments in the AST
ast.comments.forEach(comment => {
  // Replace format references in comments while preserving structure
  comment.value = replaceFormatReferencesInText(
    comment.value,
    sourceFormat,
    targetFormat,
    { preserveCodeBlocks: true }
  );
});
```

### 3. Comprehensive Format Registry

We'll maintain a comprehensive registry of format-related terms and their variations:

```json
{
  "heic": {
    "variations": ["HEIC", "heic", "Heic", "HEIF", "heif"],
    "compounds": ["heicToJpg", "HeicToJpg", "HEIC_TO_JPG"],
    "codeReferences": ["HeicConverter", "processHeic"],
    "naturalLanguage": ["HEIC file", "High Efficiency Image Container"]
  }
}
```

### 4. Context-Aware Replacement Rules

Different replacement strategies for different contexts:

- **Type Names**: Follow PascalCase convention (`HeicToJpgConverter` → `MkvToMp4Converter`)
- **Variables**: Follow camelCase convention (`heicFile` → `mkvFile`)
- **Comments**: Preserve sentence structure and formatting
- **String Literals**: Maintain quotes and escaping

### 5. Verification Stage

After transformation, perform verification to catch missed replacements:

```javascript
// Scan generated code for any remaining source format references
const remainingReferences = findAllFormatReferences(generatedCode, sourceFormat);

if (remainingReferences.length > 0) {
  console.warn("Warning: Found potential missed format references:", remainingReferences);
  // Provide detailed location information for manual review
}
```

### 6. Test Case Generation

For each variant, automatically generate tests that verify:

- All references to the original format are gone
- The new format is correctly referenced throughout 
- Documentation accurately describes the current format
- Error messages mention the correct formats

## Implementation Plan

1. **Create Format Reference Database**:
   - Document all format names and variations
   - Map relationships between formats
   - Identify context-specific patterns

2. **Build AST Transformation Tools**:
   - Implement AST-based code scanning
   - Create context-aware replacement rules
   - Build a verification system

3. **Enhance Variant Creation Script**:
   - Integrate AST transformation
   - Add verification stage
   - Generate variant-specific tests

4. **Documentation Update**:
   - Document the transformation process
   - Provide guidelines for adding new formats
   - Create troubleshooting guide for edge cases

## Conclusion

This comprehensive approach ensures that when creating a new variant (e.g., MP4ToMOV), all references to the original formats are properly replaced throughout the codebase, including code, comments, and documentation. This significantly reduces the risk of confusion, bugs, and maintenance issues in the future.

---

Last updated: April 30, 2025```

---

### [HEICFLIP-644]_visual_identity_transformation.md

**Path:** meta/variant-creation/[HEICFLIP-644]_visual_identity_transformation.md

```markdown
# Visual Identity Transformation System

This document details how the Enhanced Variant Generator handles visual identity elements to ensure complete replacement across all formats.

## Visual Identity Components

The following elements comprise the visual identity of a converter variant and require comprehensive transformation:

### 1. Theme-Specific CSS Values

| Element Type | HEICFlip Elements | Transformation Approach |
|--------------|-------------------|-------------------------|
| **Primary Colors** | Orange (#F28500, #DD7230) | Direct color replacement via theme configuration |
| **Secondary Colors** | Darker oranges (#D67E00, #B85A25) | Generated from primary via color relationships |
| **Accent Colors** | Lighter oranges (#FFA033, #F39C6B) | Generated from primary via color relationships |
| **RGBA Variations** | rgba(242, 133, 0, 0.x) | Parsed and rebuilt with new RGB values |
| **Named Colors** | .orange-button, .orange-highlight | Class name replacement using color name extraction |
| **Gradients** | linear-gradient(to right, #F28500, #FFA033) | Pattern matching and component replacement |
| **Shadows** | box-shadow: 0 2px 8px rgba(242, 133, 0, 0.4) | Pattern matching with opacity preservation |
| **Borders** | border: 2px dashed #F28500 | Direct property replacement |

### 2. SVG/Icon Assets

| Element Type | HEICFlip Elements | Transformation Approach |
|--------------|-------------------|-------------------------|
| **Logo SVG** | Orange circular icon | AST-based color and shape modification |
| **UI Icons** | Conversion direction arrows | Color replacement and optional shape modification |
| **Decorative Elements** | Stylized drop zone borders | Color and pattern replacement |
| **Embedded Text** | "HEIC → JPG" in SVGs | Text node replacement in SVG AST |
| **CSS Classes in SVGs** | .heic-icon, .jpg-output | Class name replacement with format detection |
| **SVG Patterns** | Pattern fills using orange colors | Pattern reconfiguration with new colors |

### 3. Image Assets with Embedded Text

| Element Type | HEICFlip Elements | Transformation Approach |
|--------------|-------------------|-------------------------|
| **Raster Logos** | PNG/JPG logos with "HEICFlip" text | OCR detection and regeneration |
| **Tutorial Images** | Screenshots with format references | OCR analysis and flagging for manual review |
| **Marketing Images** | Feature illustrations with format labels | OCR analysis and regeneration or flagging |
| **Favicons** | Browser icons using orange theme | Automatic regeneration with new colors |

## Comprehensive Visual Identity Transformation Process

Our enhanced system applies a multi-layered approach to ensure complete visual identity transformation:

### 1. CSS/SCSS Processing

The `processStylesheet` function in `asset-transformer.js` handles:

```javascript
// Original HEICFlip theme colors (all variations)
const originalColors = {
  // Primary orange color and variations
  primary: ['#F28500', '#DD7230', '#f28500', '#dd7230', 'rgb(242, 133, 0)', 'rgb(221, 114, 48)'],
  // Secondary darker orange
  secondary: ['#D67E00', '#B85A25', '#d67e00', '#b85a25', 'rgb(214, 126, 0)', 'rgb(184, 90, 37)'],
  // Accent lighter orange
  accent: ['#FFA033', '#F39C6B', '#ffa033', '#f39c6b', 'rgb(255, 160, 51)', 'rgb(243, 156, 107)']
};

// RGBA variations with any opacity
const rgbaPatterns = [
  /rgba\(\s*242\s*,\s*133\s*,\s*0\s*,\s*([\d.]+)\s*\)/g, // Primary
  /rgba\(\s*221\s*,\s*114\s*,\s*48\s*,\s*([\d.]+)\s*\)/g, // Primary alt
  // ...
];
```

The system:
- Identifies all color formats (hex, RGB, RGBA, named)
- Preserves opacity values in RGBA transformations
- Updates CSS variables and custom properties
- Handles gradients by decomposing them and replacing components

Special handling is provided for:
- Shadow effects (box-shadow, text-shadow, drop-shadow)
- Border colors and styles (especially dashed borders used in drop zones)
- Format-specific class names (.heic-container → .mkv-container)
- Animation keyframes that reference theme colors

### 2. SVG Transformation

The `transformSvgAsset` function performs AST-based SVG transformation:

```javascript
// Process the SVG recursively
function processNode(node) {
  // If this is a text node, check for format references
  if (node.type === 'text' && node.value) {
    // Replace format references in text
    node.value = replaceFormatReferences(node.value, formatConfig);
  }
  
  // Process attributes
  if (node.attributes) {
    // Replace colors in attributes
    Object.keys(node.attributes).forEach(attr => {
      if (['fill', 'stroke'].includes(attr)) {
        const value = node.attributes[attr];
        if (originalColors.includes(value)) {
          // Determine which color to use
          if (value.toLowerCase() === '#f28500' || value.toLowerCase() === '#dd7230') {
            node.attributes[attr] = newColors.primary;
          // ...
```

This approach:
- Preserves SVG structure while updating colors and format references
- Handles SVG path data to modify shapes based on format type (image vs. video)
- Processes embedded text nodes within SVGs
- Updates IDs and classes that might have format-specific names

### 3. Image Content Analysis

For raster images that might contain embedded text references to formats:

```javascript
// Extract text from image using OCR
const config = {
  lang: 'eng',
  oem: 1,
  psm: 3,
};

const text = await tesseract.recognize(filePath, config);

// Check for format references
const { sourceFormat, targetFormat, sourceTargetFormat, targetTargetFormat } = formatConfig;

const foundReferences = [];

// Check for format variations
[...sourceFormat.variations, ...sourceTargetFormat.variations].forEach(variant => {
  if (text.includes(variant)) {
    foundReferences.push({
      type: 'imageText',
      value: variant,
      file: filePath
    });
  }
});
```

This system:
- Uses OCR (Tesseract) to detect text in images
- Identifies format-specific references
- Flags images that require manual attention
- Can optionally regenerate simple images (like logos) with new formats and colors

### 4. Dynamic Asset Generation

For core branding elements, the system can generate new assets specific to each variant:

```javascript
async function generateVariantLogo(outputPath, themeConfig, formatConfig) {
  // Create a blank canvas
  const canvas = createCanvas(200, 200);
  const ctx = canvas.getContext('2d');
  
  // Fill background with primary theme color
  ctx.fillStyle = themeConfig.primaryColor;
  ctx.beginPath();
  ctx.arc(100, 100, 80, 0, Math.PI * 2);
  ctx.fill();
  
  // Add format-specific text
  const sourceName = formatConfig.sourceFormat.name.slice(0, 4);
  const targetName = formatConfig.targetTargetFormat.name.slice(0, 4);
  
  ctx.fillText(`${sourceName}`, 100, 80);
  ctx.fillText('→', 100, 100);
  ctx.fillText(`${targetName}`, 100, 120);
  
  // Save to file
  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync(outputPath, buffer);
}
```

This approach:
- Creates consistent, format-appropriate logos and icons
- Ensures visual consistency across variants
- Eliminates manual graphics work for new variants

## Verification and Quality Assurance

To ensure all visual identity elements are properly transformed:

1. **Visual Diffing**: Automated screenshot comparison between original and transformed pages
2. **Color Extraction**: Analysis of rendered pages to identify any remaining original theme colors
3. **OCR Verification**: Checking rendered pages for any remaining textual format references
4. **Manual Review Queue**: Flagging complex images or SVGs that need human verification

## Future Enhancements

Planned enhancements to the visual identity transformation system:

1. **Machine Learning Image Generation**: Using ML to generate more sophisticated variant-specific imagery
2. **Animation Transformation**: Handling CSS and SVG animations that might contain format-specific elements
3. **Custom Font Support**: Handling variants that might use different typography as part of their branding
4. **Theme Relationship Preservation**: Ensuring color relationships are maintained across different color schemes

---

Last updated: April 30, 2025```

---

### [HEICFLIP-643]_comprehensive_ui_branding_replacement.md

**Path:** meta/variant-creation/[HEICFLIP-643]_comprehensive_ui_branding_replacement.md

```markdown
# Comprehensive UI and Branding Replacement

This document addresses how the variant creation system handles format-specific UI and branding elements to ensure complete replacement across all aspects of the application.

## Format-Specific UI Elements Identified

Based on a review of the deployed HEICFlip application, we've identified several categories of format-specific elements that must be transformed when creating new variants:

### 1. Visual Theme Elements

| Element | HEICFlip Example | Transformation Approach |
|---------|------------------|-------------------------|
| Primary Color | Bright orange (#F28500) | Direct replacement via theme variables |
| Accent Colors | Orange variants for hover, focus states | Generated from primary color via HSL adjustments |
| Drop Shadows | Orange-hued shadows | CSS variable replacement |
| SVG Icons | Orange circular play button | SVG content replacement with color transforms |
| Drop Zone Border | Orange dashed border | CSS variable replacement |
| Conversion Direction Toggle | Orange highlight for active state | Component theme property replacement |

### 2. Format-Specific Text Content

| Element | HEICFlip Example | Transformation Approach |
|---------|------------------|-------------------------|
| Main Headlines | "Convert HEIC to JPG" | Template strings with format placeholders |
| Instructions | "Convert HEIC to widely-compatible JPG format" | Template strings with format placeholders |
| Success Messages | "Your HEIC files have been converted to JPG" | Template strings with format placeholders |
| FAQ Content | "What is a HEIC file and why would I need to convert it?" | Format-specific content blocks with replacements |
| Feature References | "batch HEIC conversion", "HEIC privacy" | Regex with context-aware boundaries |
| File Extension References | ".heic", ".jpg" | Direct string replacement |
| Copyright/Footer | "© 2025 HEICFlip" | Template variable replacement |

### 3. Technical References

| Element | HEICFlip Example | Transformation Approach |
|---------|------------------|-------------------------|
| Supported Formats Text | "Currently, we support HEIC, JPG, JPEG, and PNG" | Generated from format configuration |
| Format Education Content | "HEIC is Apple's proprietary format..." | Format-specific content blocks |
| Format Comparison Tables | Size/quality comparisons between HEIC and JPG | Dynamic content generation from format data |
| Developer Documentation | Format-specific API examples | Template transformation with format variables |

## Enhanced Transformation System

To address all these elements, we've expanded our transformation system:

### 1. UI Component Templating

For React components, we now use a combination of AST transformation and templating:

```javascript
// Original HEICFlip component
function ConversionToggle() {
  return (
    <div className="toggle-container">
      <span className={isHeicToJpg ? "active" : ""}>HEIC to JPG</span>
      <Switch
        checked={isHeicToJpg}
        onChange={toggleDirection}
        className="orange-switch"
      />
      <span className={!isHeicToJpg ? "active" : ""}>JPG to HEIC</span>
    </div>
  );
}

// Transformed to template with format variables
function ConversionToggle() {
  return (
    <div className="toggle-container">
      <span className={is{{SourceFormat}}To{{TargetFormat}} ? "active" : ""}>
        {{SOURCE_FORMAT}} to {{TARGET_FORMAT}}
      </span>
      <Switch
        checked={is{{SourceFormat}}To{{TargetFormat}}}
        onChange={toggleDirection}
        className="{{primaryColorName}}-switch"
      />
      <span className={!is{{SourceFormat}}To{{TargetFormat}} ? "active" : ""}>
        {{TARGET_FORMAT}} to {{SOURCE_FORMAT}}
      </span>
    </div>
  );
}
```

### 2. CSS and Theme Variable Processing

CSS files and theme definitions are processed to replace format-specific colors and styles:

```javascript
// Before: HEICFlip theme
const theme = {
  primary: '#F28500',     // Orange
  secondary: '#D67E00',   // Darker orange
  accent: '#FFA033',      // Lighter orange
  dropZoneBorder: '2px dashed #F28500',
  siteName: 'HEICFlip',
  // ...
};

// After: Template with format-specific customization
const theme = {
  primary: '{{PRIMARY_COLOR}}',
  secondary: '{{SECONDARY_COLOR}}',
  accent: '{{ACCENT_COLOR}}',
  dropZoneBorder: '2px dashed {{PRIMARY_COLOR}}',
  siteName: '{{SITE_NAME}}',
  // ...
};
```

### 3. SVG and Image Asset Transformation

Format-specific graphics, such as icons and illustrations, are processed to replace colors and format-specific imagery:

```javascript
// Process SVG content to replace colors and format-specific elements
function transformSvgAsset(svgContent, formatConfig) {
  // Replace color values
  let transformed = svgContent.replace(/#F28500/g, formatConfig.primaryColor);
  
  // Replace format-specific imagery based on variant type
  if (formatConfig.formatType === 'video') {
    // Use video-specific icon elements instead of image elements
    transformed = transformed.replace(
      /<path d="M12 8v8m4-4H8" stroke="#000"/>,
      '<path d="M10 8l6 4-6 4V8z" fill="#000"/>'
    );
  }
  
  return transformed;
}
```

### 4. Content Block Transformation for Documentation and FAQs

Format-specific documentation blocks are transformed with knowledge of the content's meaning:

```javascript
// Format-specific FAQ blocks
const faqBlocks = {
  'heicToJpg': [
    {
      question: "What is a HEIC file and why would I need to convert it?",
      answer: "HEIC is Apple's proprietary image format introduced in iOS 11. While it offers better compression than JPEG, it's not widely supported outside of Apple devices, which is why you might need to convert it to JPG for broader compatibility."
    },
    // ...
  ],
  'mkvToMp4': [
    {
      question: "What is an MKV file and why would I need to convert it?",
      answer: "MKV (Matroska Video) is an open-source container format that can hold multiple audio, video and subtitle tracks. While it's popular among video enthusiasts, it's not as widely supported as MP4, especially on mobile devices and some streaming platforms."
    },
    // ...
  ],
  // Templates for other variants
  '_template': {
    question: "What is a {{SOURCE_FORMAT}} file and why would I need to convert it?",
    answer: "{{SOURCE_FORMAT_DESCRIPTION}}. While it {{SOURCE_FORMAT_BENEFITS}}, it's {{SOURCE_FORMAT_LIMITATIONS}}, which is why you might need to convert it to {{TARGET_FORMAT}} for {{TARGET_FORMAT_BENEFITS}}."
  }
};
```

### 5. Dynamic Content Generation Engine

For some content that needs to be unique per variant, we implement a content generation engine that creates appropriate format-specific text:

```javascript
function generateFormatEducationContent(sourceFormat, targetFormat) {
  const formatData = loadFormatRegistry();
  const sourceInfo = formatData.formats[sourceFormat];
  const targetInfo = formatData.formats[targetFormat];
  
  return {
    title: `About ${sourceInfo.name} and ${targetInfo.name} Formats`,
    intro: `${sourceInfo.name} (${sourceInfo.fullName}) is ${sourceInfo.description}. 
            ${targetInfo.name} (${targetInfo.fullName}) is ${targetInfo.description}.`,
    comparison: `While ${sourceInfo.name} ${sourceInfo.advantages}, 
                 ${targetInfo.name} offers ${targetInfo.advantages}.`,
    useCases: generateUseCases(sourceInfo, targetInfo),
    formatTable: generateFormatComparisonTable(sourceInfo, targetInfo)
  };
}
```

## Implementation in the Variant Creation Script

The enhanced variant creation script now:

1. **Identifies UI Components**: Scans React components for format-specific UI elements
2. **Processes Theme Files**: Transforms color schemes and styling variables
3. **Transforms Text Content**: Replaces format references in all user-facing text
4. **Generates Format-Specific Content**: Creates appropriate documentation and FAQ content
5. **Transforms SVG Assets**: Modifies colors and format-specific imagery
6. **Updates Metadata**: Changes site name, descriptions, and SEO content
7. **Verifies Completeness**: Checks for missed references in all asset types

## Verification Process

A comprehensive verification process ensures all format-specific elements are properly transformed:

1. **Visual Verification**: Automated screenshot comparison to check UI elements
2. **Text Content Scan**: NLP-based scanning for format-specific terminology
3. **Color Usage Analysis**: Check for hardcoded colors that match the source theme
4. **Format Term Verification**: Cross-reference all text content against format registry
5. **SEO Metadata Check**: Ensure all meta tags match the target format

This multi-layered approach ensures new variants have a consistent and appropriate UI/UX that accurately reflects their specific format pair, with no leakage of references from the original HEICFlip implementation.

---

Last updated: April 30, 2025```

---

### [HEICFLIP-640]_dynamic_format_support.md

**Path:** meta/variant-creation/[HEICFLIP-640]_dynamic_format_support.md

```markdown
# Dynamic Format Support in HEICFlip Monorepo

This document explains how the monorepo structure enables adding new conversion formats without modifying core code.

## Extensible Type System

The core package defines an extensible type system that allows each variant to register its own conversion modes:

```typescript
// Base conversion modes supported in core package
export type CoreConversionMode = 
  | 'heicToJpg'  // HEIC to JPG conversion
  | 'jpgToHeic'  // JPG to HEIC conversion 
  | 'aviToMp4'   // AVI to MP4 conversion
  | 'mp4ToAvi';  // MP4 to AVI conversion

// Extension point for additional conversion modes
export interface ExtendedConversionModes {}

// Combined type for all conversion modes
export type ConversionMode = CoreConversionMode | keyof ExtendedConversionModes;
```

## Dynamic Converter Registry

A factory pattern allows registering new converters at runtime:

```typescript
// Register a new converter in a variant package
import { registerConverter } from '@flip/core';
import { MKVToMP4Converter } from './MKVToMP4Converter';

// Register the converter for the specific conversion mode
registerConverter('mkvToMp4', MKVToMP4Converter);
```

## Template-Based Code Generation

The variant creation script uses templates to generate format-specific code:

1. **Format Configuration**: A central `formats.json` file defines all supported formats and conversion modes, including FFmpeg parameters
2. **Converter Template**: A template file defines the converter structure with placeholders for format-specific details
3. **Type Extension**: Each variant extends the core types to add its specific conversion mode

## Example: Creating an MKVFlip Variant

When creating a new variant like MKVFlip:

1. Run the variant creation script with specific parameters:
   ```
   node scripts/create-variant.js --name=mkvflip --mode=mkvToMp4 --color=#00A878
   ```

2. The script automatically:
   - Creates a directory structure for the variant
   - Generates an `MKVToMP4Converter.ts` class using the template
   - Sets up proper type extensions for TypeScript
   - Registers the converter with the core registry
   - Updates the variant's UI to show MKV-specific details

3. The variant works without any HEIC/JPG references in its code

## Adding New Formats

To add support for a new format (e.g., TIFF):

1. Update `scripts/converter-templates/formats.json` to add the format:
   ```json
   "tiff": {
     "name": "TIFF",
     "mimeTypes": ["image/tiff"],
     "extensions": [".tiff", ".tif"]
   }
   ```

2. Define new conversion modes:
   ```json
   "tiffToJpg": {
     "source": "tiff",
     "target": "jpg",
     "ffmpegOptions": ["-quality", "90"],
     "description": "Convert TIFF images to JPG format"
   }
   ```

3. Create a variant with the new mode:
   ```
   node scripts/create-variant.js --name=tiffflip --mode=tiffToJpg --color=#4B296B
   ```

## Format-Specific FFmpeg Parameters

Each conversion mode includes custom FFmpeg parameters optimized for that specific format:

```json
"mkvToMp4": {
  "source": "mkv",
  "target": "mp4",
  "ffmpegOptions": [
    "-c:v", "libx264",
    "-crf", "Math.round(30 - (quality * 0.2)).toString()",
    "-preset", "medium", 
    "-c:a", "aac",
    "-b:a", "128k"
  ],
  "description": "Convert MKV videos to MP4 format"
}
```

This ensures each converter uses the optimal settings for its specific format pair.

## Benefits

This architecture provides several advantages:

1. **No Cross-Contamination**: Each variant only contains code for its specific formats
2. **Easy Extension**: Adding new formats requires no changes to existing code
3. **Optimal Parameters**: Each conversion pair uses format-specific FFmpeg parameters
4. **Type Safety**: TypeScript ensures proper type checking across the monorepo
5. **Dynamic Registration**: The registry system handles format discovery at runtime

---

Last updated: April 30, 2025```

---

### [HEICFLIP-641]_supported_formats.md

**Path:** meta/variant-creation/[HEICFLIP-641]_supported_formats.md

```markdown
# Supported Formats in HEICFlip Monorepo

This document lists all the formats and conversion modes currently supported in the project.

## Image Formats

| Format | MIME Types | Extensions | Description |
|--------|------------|------------|-------------|
| HEIC | image/heic, image/heif | .heic, .heif | High Efficiency Image Format used by Apple devices |
| JPG | image/jpeg, image/jpg | .jpg, .jpeg | Standard JPEG image format |
| PNG | image/png | .png | Portable Network Graphics format with alpha channel support |
| WebP | image/webp | .webp | Google's WebP format with good compression and quality |
| GIF | image/gif | .gif | Graphics Interchange Format, supports animations |

## Video Formats

| Format | MIME Types | Extensions | Description |
|--------|------------|------------|-------------|
| AVI | video/x-msvideo, video/avi | .avi | Audio Video Interleave, older Microsoft format |
| MP4 | video/mp4 | .mp4 | MPEG-4 container format, widely supported |
| MKV | video/x-matroska | .mkv | Matroska container format, supports many codecs |
| MOV | video/quicktime | .mov | QuickTime container format used by Apple |
| WebM | video/webm | .webm | Google's WebM format based on VP8/VP9 |

## Supported Conversion Modes

### Image Conversions

| Mode | Source | Target | Description |
|------|--------|--------|-------------|
| heicToJpg | HEIC | JPG | Convert HEIC/HEIF images to JPG format |
| jpgToHeic | JPG | HEIC | Convert JPG images to HEIC format |
| pngToWebp | PNG | WebP | Convert PNG images to WebP format |
| webpToPng | WebP | PNG | Convert WebP images to PNG format |

### Video Conversions

| Mode | Source | Target | Description |
|------|--------|--------|-------------|
| aviToMp4 | AVI | MP4 | Convert AVI videos to MP4 format |
| mp4ToAvi | MP4 | AVI | Convert MP4 videos to AVI format |
| mkvToMp4 | MKV | MP4 | Convert MKV videos to MP4 format |
| mp4ToMkv | MP4 | MKV | Convert MP4 videos to MKV format |
| gifToMp4 | GIF | MP4 | Convert GIF animations to MP4 videos |
| movToMp4 | MOV | MP4 | Convert MOV videos to MP4 format |

## FFmpeg Parameter Optimizations

Each conversion mode uses format-specific FFmpeg parameters optimized for quality and performance:

### Image Conversion Parameters

- **HEIC to JPG**: Uses quality scaling from 1-10 based on user quality setting
- **JPG to HEIC**: Uses CRF (Constant Rate Factor) and hvc1 tag for Apple compatibility
- **PNG to WebP**: Uses direct quality parameter mapping
- **WebP to PNG**: Uses lossless conversion

### Video Conversion Parameters

- **AVI to MP4**: Uses H.264 codec with quality-based CRF and AAC audio
- **MP4 to AVI**: Uses Xvid codec with quality parameter and MP3 audio
- **MKV to MP4**: Uses H.264 codec with quality-based CRF and AAC audio
- **MP4 to MKV**: Uses direct stream copy for maximum speed
- **GIF to MP4**: Uses H.264 codec with special settings for animations
- **MOV to MP4**: Uses H.264 codec with quality-based CRF and AAC audio

## Adding New Formats

To add a new format to the system:

1. Update `scripts/converter-templates/formats.json` with format details
2. Define any new conversion modes
3. Create variants using the variant creation script

For format-specific optimization guidance, see the FFmpeg documentation.

---

Last updated: April 30, 2025```

---

### format_specific_pages.md

**Path:** docs/format_specific_pages.md

```markdown
# Format-Specific Conversion Pages Documentation

## Overview

While the multi-format converter provides a comprehensive solution for returning visitors, we're implementing format-specific landing pages to optimize for SEO and provide a simpler experience for new users. This document outlines the implementation approach.

## Implementation Strategy

### URL Structure

Format-specific pages will follow a consistent URL pattern:

```
/convert/{source-format}-to-{target-format}
```

Examples:
- `/convert/heic-to-jpg`
- `/convert/mp4-to-webm`
- `/convert/png-to-webp`

### Component Structure

Each format-specific page will use a specialized version of the converter component focused only on the specific conversion pair. This ensures:

1. Clear user messaging specific to the conversion type
2. Simplified UI with fewer options
3. Targeted help content for the specific formats
4. Optimized SEO metadata

### SEO Benefits

This approach provides several SEO advantages:

- URL matches common search queries like "convert heic to jpg"
- Page title and meta description can be highly targeted
- Content focuses specifically on one conversion type
- FAQ sections can address format-specific questions

## Format Registry

We maintain a registry of supported formats and their conversion paths. This registry is used to:

1. Generate the format-specific pages
2. Create a sitemap for search engines
3. Validate which conversions are possible

The registry includes metadata such as:

```typescript
interface FormatInfo {
  extension: string;
  name: string;        // Display name (e.g., "JPEG")
  mimeType: string;    // e.g., "image/jpeg"
  category: "image" | "video" | "audio" | "document";
  description: string; // Brief description of the format
}

interface ConversionPath {
  source: string;      // Format extension (e.g., "heic")
  target: string;      // Format extension (e.g., "jpg")
  priority: number;    // SEO/marketing priority (higher = more important)
  enabled: boolean;    // Whether this conversion path is enabled
}
```

## Development Plan

1. Complete the multi-format converter UI and functionality
2. Create the format registry with initial image and video formats
3. Implement template for format-specific pages
4. Generate first set of high-priority format-specific pages
5. Add analytics to track which conversions are most popular
6. Expand registry with additional formats based on user demand

## Future Extensions

- Bulk conversion options for each format pair
- Format-specific optimization settings
- Specialized previews for each format type
- Recommended settings for specific use cases
```

---

### [HEICFLIP-644]_visual_identity_transformation.md

**Path:** attached_assets/[HEICFLIP-644]_visual_identity_transformation.md

```markdown
# Visual Identity Transformation System

This document details how the Enhanced Variant Generator handles visual identity elements to ensure complete replacement across all formats.

## Visual Identity Components

The following elements comprise the visual identity of a converter variant and require comprehensive transformation:

### 1. Theme-Specific CSS Values

| Element Type | HEICFlip Elements | Transformation Approach |
|--------------|-------------------|-------------------------|
| **Primary Colors** | Orange (#F28500, #DD7230) | Direct color replacement via theme configuration |
| **Secondary Colors** | Darker oranges (#D67E00, #B85A25) | Generated from primary via color relationships |
| **Accent Colors** | Lighter oranges (#FFA033, #F39C6B) | Generated from primary via color relationships |
| **RGBA Variations** | rgba(242, 133, 0, 0.x) | Parsed and rebuilt with new RGB values |
| **Named Colors** | .orange-button, .orange-highlight | Class name replacement using color name extraction |
| **Gradients** | linear-gradient(to right, #F28500, #FFA033) | Pattern matching and component replacement |
| **Shadows** | box-shadow: 0 2px 8px rgba(242, 133, 0, 0.4) | Pattern matching with opacity preservation |
| **Borders** | border: 2px dashed #F28500 | Direct property replacement |

### 2. SVG/Icon Assets

| Element Type | HEICFlip Elements | Transformation Approach |
|--------------|-------------------|-------------------------|
| **Logo SVG** | Orange circular icon | AST-based color and shape modification |
| **UI Icons** | Conversion direction arrows | Color replacement and optional shape modification |
| **Decorative Elements** | Stylized drop zone borders | Color and pattern replacement |
| **Embedded Text** | "HEIC → JPG" in SVGs | Text node replacement in SVG AST |
| **CSS Classes in SVGs** | .heic-icon, .jpg-output | Class name replacement with format detection |
| **SVG Patterns** | Pattern fills using orange colors | Pattern reconfiguration with new colors |

### 3. Image Assets with Embedded Text

| Element Type | HEICFlip Elements | Transformation Approach |
|--------------|-------------------|-------------------------|
| **Raster Logos** | PNG/JPG logos with "HEICFlip" text | OCR detection and regeneration |
| **Tutorial Images** | Screenshots with format references | OCR analysis and flagging for manual review |
| **Marketing Images** | Feature illustrations with format labels | OCR analysis and regeneration or flagging |
| **Favicons** | Browser icons using orange theme | Automatic regeneration with new colors |

## Comprehensive Visual Identity Transformation Process

Our enhanced system applies a multi-layered approach to ensure complete visual identity transformation:

### 1. CSS/SCSS Processing

The `processStylesheet` function in `asset-transformer.js` handles:

```javascript
// Original HEICFlip theme colors (all variations)
const originalColors = {
  // Primary orange color and variations
  primary: ['#F28500', '#DD7230', '#f28500', '#dd7230', 'rgb(242, 133, 0)', 'rgb(221, 114, 48)'],
  // Secondary darker orange
  secondary: ['#D67E00', '#B85A25', '#d67e00', '#b85a25', 'rgb(214, 126, 0)', 'rgb(184, 90, 37)'],
  // Accent lighter orange
  accent: ['#FFA033', '#F39C6B', '#ffa033', '#f39c6b', 'rgb(255, 160, 51)', 'rgb(243, 156, 107)']
};

// RGBA variations with any opacity
const rgbaPatterns = [
  /rgba\(\s*242\s*,\s*133\s*,\s*0\s*,\s*([\d.]+)\s*\)/g, // Primary
  /rgba\(\s*221\s*,\s*114\s*,\s*48\s*,\s*([\d.]+)\s*\)/g, // Primary alt
  // ...
];
```

The system:
- Identifies all color formats (hex, RGB, RGBA, named)
- Preserves opacity values in RGBA transformations
- Updates CSS variables and custom properties
- Handles gradients by decomposing them and replacing components

Special handling is provided for:
- Shadow effects (box-shadow, text-shadow, drop-shadow)
- Border colors and styles (especially dashed borders used in drop zones)
- Format-specific class names (.heic-container → .mkv-container)
- Animation keyframes that reference theme colors

### 2. SVG Transformation

The `transformSvgAsset` function performs AST-based SVG transformation:

```javascript
// Process the SVG recursively
function processNode(node) {
  // If this is a text node, check for format references
  if (node.type === 'text' && node.value) {
    // Replace format references in text
    node.value = replaceFormatReferences(node.value, formatConfig);
  }
  
  // Process attributes
  if (node.attributes) {
    // Replace colors in attributes
    Object.keys(node.attributes).forEach(attr => {
      if (['fill', 'stroke'].includes(attr)) {
        const value = node.attributes[attr];
        if (originalColors.includes(value)) {
          // Determine which color to use
          if (value.toLowerCase() === '#f28500' || value.toLowerCase() === '#dd7230') {
            node.attributes[attr] = newColors.primary;
          // ...
```

This approach:
- Preserves SVG structure while updating colors and format references
- Handles SVG path data to modify shapes based on format type (image vs. video)
- Processes embedded text nodes within SVGs
- Updates IDs and classes that might have format-specific names

### 3. Image Content Analysis

For raster images that might contain embedded text references to formats:

```javascript
// Extract text from image using OCR
const config = {
  lang: 'eng',
  oem: 1,
  psm: 3,
};

const text = await tesseract.recognize(filePath, config);

// Check for format references
const { sourceFormat, targetFormat, sourceTargetFormat, targetTargetFormat } = formatConfig;

const foundReferences = [];

// Check for format variations
[...sourceFormat.variations, ...sourceTargetFormat.variations].forEach(variant => {
  if (text.includes(variant)) {
    foundReferences.push({
      type: 'imageText',
      value: variant,
      file: filePath
    });
  }
});
```

This system:
- Uses OCR (Tesseract) to detect text in images
- Identifies format-specific references
- Flags images that require manual attention
- Can optionally regenerate simple images (like logos) with new formats and colors

### 4. Dynamic Asset Generation

For core branding elements, the system can generate new assets specific to each variant:

```javascript
async function generateVariantLogo(outputPath, themeConfig, formatConfig) {
  // Create a blank canvas
  const canvas = createCanvas(200, 200);
  const ctx = canvas.getContext('2d');
  
  // Fill background with primary theme color
  ctx.fillStyle = themeConfig.primaryColor;
  ctx.beginPath();
  ctx.arc(100, 100, 80, 0, Math.PI * 2);
  ctx.fill();
  
  // Add format-specific text
  const sourceName = formatConfig.sourceFormat.name.slice(0, 4);
  const targetName = formatConfig.targetTargetFormat.name.slice(0, 4);
  
  ctx.fillText(`${sourceName}`, 100, 80);
  ctx.fillText('→', 100, 100);
  ctx.fillText(`${targetName}`, 100, 120);
  
  // Save to file
  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync(outputPath, buffer);
}
```

This approach:
- Creates consistent, format-appropriate logos and icons
- Ensures visual consistency across variants
- Eliminates manual graphics work for new variants

## Verification and Quality Assurance

To ensure all visual identity elements are properly transformed:

1. **Visual Diffing**: Automated screenshot comparison between original and transformed pages
2. **Color Extraction**: Analysis of rendered pages to identify any remaining original theme colors
3. **OCR Verification**: Checking rendered pages for any remaining textual format references
4. **Manual Review Queue**: Flagging complex images or SVGs that need human verification

## Future Enhancements

Planned enhancements to the visual identity transformation system:

1. **Machine Learning Image Generation**: Using ML to generate more sophisticated variant-specific imagery
2. **Animation Transformation**: Handling CSS and SVG animations that might contain format-specific elements
3. **Custom Font Support**: Handling variants that might use different typography as part of their branding
4. **Theme Relationship Preservation**: Ensuring color relationships are maintained across different color schemes

---

Last updated: April 30, 2025```

---

## Monorepo Structure Documentation

### [HEICFLIP-600]_monorepo_structure.md

**Path:** meta/monorepo/[HEICFLIP-600]_monorepo_structure.md

```markdown
# Monorepo Structure for Conversion Tools

This document outlines the structure and organization of our monorepo, which houses multiple file conversion tools under a unified codebase.

## Directory Structure

```
/
├── package.json             # Root package.json with workspaces config
├── tsconfig.json            # Base TypeScript configuration
├── packages/
│   ├── core/                # Shared core functionality
│   │   ├── package.json
│   │   ├── src/
│   │   │   ├── conversion/  # Conversion engines
│   │   │   ├── ui/          # Shared UI components
│   │   │   └── utils/       # Shared utilities
│   │
│   ├── heicflip/            # HEIC to JPG converter (default theme)
│   │   ├── package.json
│   │   ├── vite.config.ts
│   │   ├── src/
│   │   │   ├── config.ts    # HEICFlip-specific configuration
│   │   │   ├── themes/      # Theme definitions
│   │   │   └── main.tsx     # Entry point
│   │
│   ├── jpgflip/             # JPG to HEIC converter
│   │   ├── package.json
│   │   ├── vite.config.ts
│   │   ├── src/
│   │   │   ├── config.ts    # JPGFlip-specific configuration
│   │   │   └── main.tsx     # Entry point
│   │
│   └── other-variants/      # Additional converter variants
│
├── scripts/                 # Build and deployment scripts
│   ├── create-variant.js    # Script to create a new variant
│   ├── build-all.js         # Build all packages
│   └── deploy.js            # Deploy specific or all variants
│
└── shared/                  # Truly shared code across all packages
    ├── schema.ts            # Database schema definitions
    └── types.ts             # Shared TypeScript types
```

## Package Structure

### Core Package

The `core` package contains all shared functionality that is used across all variants:

- Conversion engines for different file formats
- Base UI components 
- Design system
- Utility functions
- API interfaces

This package is imported by all variant packages.

### Variant Packages

Each variant package (heicflip, jpgflip, etc.) contains:

- Specific configuration (theme colors, conversion settings)
- Custom assets (logos, icons)
- Variant-specific pages or components (if needed)
- Independent deployment configuration

Each variant imports the core package and customizes it through configuration.

## Theme System

HEICFlip serves as the default theme and foundation. The theme system includes:

1. **Base Theme Definition**: Located in `packages/core/src/ui/themes/base.ts`
2. **Variant Overrides**: Each variant can override specific theme values
3. **Style Isolation**: CSS modules or CSS-in-JS ensures styles don't leak between variants

## Configuration System

The configuration system is designed to be:

1. **Type-Safe**: All configuration options have TypeScript definitions
2. **Hierarchical**: Default values that can be overridden by variants
3. **Feature-Flagged**: Easily turn features on/off for specific variants

## Build & Deployment

Each variant can be:

1. **Built Independently**: `npm run build --workspace=packages/heicflip`
2. **Deployed to a Unique URL**: Using deployment platform configurations
3. **Tested in Isolation**: `npm run test --workspace=packages/heicflip`

## Development Workflow

1. Make changes to shared code in the `core` package
2. Test changes by running a specific variant
3. Build and deploy individual variants as needed

## Adding a New Variant

To add a new variant:

1. Run `node scripts/create-variant.js --name=newvariant`
2. Modify the generated configuration in `packages/newvariant/src/config.ts`
3. Test locally with `npm run dev --workspace=packages/newvariant`
4. Deploy with `node scripts/deploy.js --variant=newvariant`

---

Last updated: April 30, 2025```

---

### [HEICFLIP-602]_step_by_step_implementation.md

**Path:** meta/monorepo/[HEICFLIP-602]_step_by_step_implementation.md

```markdown
# Comprehensive Step-by-Step Monorepo Implementation Guide

This guide provides a detailed, executable plan to transform the current project into a monorepo structure and create new themed variants with different conversion types.

## Phase 1: Analyze Current Structure

### Step 1: Examine the current project structure
- Review file organization
- Identify shared code vs. variant-specific code
- Map theme-related code and configuration

### Step 2: Create inventory of current dependencies
- Document all npm packages used
- Note which packages are essential for core functionality
- Identify UI/theme-related packages

## Phase 2: Create Monorepo Foundation

### Step 3: Create the basic directory structure
```bash
# Create root directory structure
mkdir -p packages/core/src
mkdir -p packages/heicflip/src
mkdir -p scripts
```

### Step 4: Create root package.json with workspaces
```bash
# Create root package.json with workspace configuration
cat > package.json << 'EOF'
{
  "name": "flip-converters",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev:heicflip": "npm run dev --workspace=packages/heicflip",
    "build:all": "node scripts/build-all.js",
    "build:heicflip": "npm run build --workspace=packages/heicflip",
    "create-variant": "node scripts/create-variant.js"
  }
}
EOF
```

## Phase 3: Extract Core Package

### Step 5: Identify core functionality
- Conversion logic
- Base UI components
- Utility functions
- Type definitions

### Step 6: Create core package structure
```bash
# Create core package.json
cat > packages/core/package.json << 'EOF'
{
  "name": "@flip/core",
  "version": "1.0.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}
EOF

# Create core tsconfig
cat > packages/core/tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "declaration": true,
    "outDir": "./dist",
    "strict": true,
    "jsx": "react-jsx",
    "esModuleInterop": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
EOF
```

### Step 7: Extract core conversion functionality
```bash
# Create conversion module structure
mkdir -p packages/core/src/conversion
```

### Step 8: Extract theme system
```bash
# Create theme system structure
mkdir -p packages/core/src/ui/themes

# Create base theme definition file
cat > packages/core/src/ui/themes/base.ts << 'EOF'
export interface BaseTheme {
  siteName: string;
  defaultConversionMode: string;
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  logoText: string;
  domain: string;
}

export const baseTheme: BaseTheme = {
  siteName: "HEICFlip",
  defaultConversionMode: "heicToJpg",
  primaryColor: "#DD7230",
  secondaryColor: "#B85A25",
  accentColor: "#F39C6B",
  logoText: "HEICFlip",
  domain: "heicflip.com"
};

export type ThemeOverrides = Partial<BaseTheme>;

export function createTheme(overrides: ThemeOverrides = {}): BaseTheme {
  return {
    ...baseTheme,
    ...overrides
  };
}
EOF
```

### Step 9: Create core exports
```bash
# Create index file to export all core functionality
cat > packages/core/src/index.ts << 'EOF'
// Re-export everything from the theme system
export * from './ui/themes/base';

// Add other exports as they are created
EOF
```

## Phase 4: Create HEICFlip Variant

### Step 10: Setup HEICFlip package
```bash
# Create heicflip package.json
cat > packages/heicflip/package.json << 'EOF'
{
  "name": "@flip/heicflip",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@flip/core": "1.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.0.0",
    "typescript": "^5.0.0",
    "vite": "^4.0.0"
  }
}
EOF

# Create vite configuration
cat > packages/heicflip/vite.config.ts << 'EOF'
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
});
EOF
```

### Step 11: Create HEICFlip theme configuration
```bash
# Create theme configuration
mkdir -p packages/heicflip/src/config

cat > packages/heicflip/src/config/theme.ts << 'EOF'
import { createTheme, ThemeOverrides } from '@flip/core';

const heicflipTheme: ThemeOverrides = {
  siteName: "HEICFlip",
  defaultConversionMode: "heicToJpg",
  primaryColor: "#DD7230",
  secondaryColor: "#B85A25",
  accentColor: "#F39C6B",
  logoText: "HEICFlip",
  domain: "heicflip.com"
};

export const theme = createTheme(heicflipTheme);
EOF
```

### Step 12: Create HEICFlip entry point
```bash
# Create main entry file
cat > packages/heicflip/src/main.tsx << 'EOF'
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { theme } from './config/theme';

console.log('Running in HEICFlip mode with configuration:', theme);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
EOF

# Create a placeholder App component
cat > packages/heicflip/src/App.tsx << 'EOF'
import React from 'react';
import { theme } from './config/theme';

function App() {
  return (
    <div style={{ 
      color: theme.primaryColor,
      fontFamily: 'Arial, sans-serif',
      maxWidth: '800px',
      margin: '0 auto',
      padding: '2rem'
    }}>
      <h1>{theme.siteName}</h1>
      <p>Convert your {theme.defaultConversionMode === 'heicToJpg' ? 'HEIC files to JPG' : 'files'} easily.</p>
    </div>
  );
}

export default App;
EOF
```

## Phase 5: Create Build and Helper Scripts

### Step 13: Create build script
```bash
# Create build script
mkdir -p scripts

cat > scripts/build-all.js << 'EOF'
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const packagesDir = path.join(__dirname, '../packages');
const packages = fs.readdirSync(packagesDir)
  .filter(dir => fs.statSync(path.join(packagesDir, dir)).isDirectory());

// Build core package first
console.log('Building @flip/core...');
execSync('npm run build', { cwd: path.join(packagesDir, 'core'), stdio: 'inherit' });

// Build variant packages
for (const pkg of packages.filter(p => p !== 'core')) {
  console.log(`Building @flip/${pkg}...`);
  execSync('npm run build', { cwd: path.join(packagesDir, pkg), stdio: 'inherit' });
}

console.log('All packages built successfully!');
EOF
```

### Step 14: Create variant generator script
```bash
# Create script to generate new variants
cat > scripts/create-variant.js << 'EOF'
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Parse command line arguments
const args = process.argv.slice(2);
const nameArg = args.find(arg => arg.startsWith('--name='));
const modeArg = args.find(arg => arg.startsWith('--mode='));
const colorArg = args.find(arg => arg.startsWith('--color='));

if (!nameArg) {
  console.error('Error: Missing --name parameter');
  console.log('Usage: node create-variant.js --name=variantname --mode=conversionMode --color=#HEXCOLOR');
  process.exit(1);
}

const variantName = nameArg.split('=')[1];
const conversionMode = modeArg ? modeArg.split('=')[1] : 'jpgToHeic'; // Default mode
const primaryColor = colorArg ? colorArg.split('=')[1] : '#3066BE'; // Default color

const variantDir = path.join(__dirname, '../packages', variantName);

// Create variant directory structure
console.log(`Creating new variant: ${variantName}`);
fs.mkdirSync(variantDir);
fs.mkdirSync(path.join(variantDir, 'src'));
fs.mkdirSync(path.join(variantDir, 'src', 'config'));

// Create package.json
const packageJson = {
  name: `@flip/${variantName}`,
  version: "1.0.0",
  private: true,
  scripts: {
    dev: "vite",
    build: "vite build",
    preview: "vite preview"
  },
  dependencies: {
    "@flip/core": "1.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  devDependencies: {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.0.0",
    "typescript": "^5.0.0",
    "vite": "^4.0.0"
  }
};

fs.writeFileSync(
  path.join(variantDir, 'package.json'),
  JSON.stringify(packageJson, null, 2)
);

// Copy vite.config.ts from heicflip
fs.copyFileSync(
  path.join(__dirname, '../packages/heicflip/vite.config.ts'),
  path.join(variantDir, 'vite.config.ts')
);

// Create theme configuration
const themeContent = `import { createTheme, ThemeOverrides } from '@flip/core';

const ${variantName}Theme: ThemeOverrides = {
  siteName: "${variantName.charAt(0).toUpperCase() + variantName.slice(1)}",
  defaultConversionMode: "${conversionMode}",
  primaryColor: "${primaryColor}",
  secondaryColor: "${adjustColor(primaryColor, -20)}", // Darker version
  accentColor: "${adjustColor(primaryColor, 20)}", // Lighter version
  logoText: "${variantName.charAt(0).toUpperCase() + variantName.slice(1)}",
  domain: "${variantName}.com"
};

export const theme = createTheme(${variantName}Theme);

// Helper function to compute secondary/accent colors
function adjustColor(hex, percent) {
  // Simple color adjustment function
  // In a real implementation, this would properly lighten/darken colors
  return hex;
}`;

fs.writeFileSync(
  path.join(variantDir, 'src', 'config', 'theme.ts'),
  themeContent
);

// Create main.tsx
const mainContent = `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { theme } from './config/theme';

console.log('Running in ${variantName.charAt(0).toUpperCase() + variantName.slice(1)} mode with configuration:', theme);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);`;

fs.writeFileSync(
  path.join(variantDir, 'src', 'main.tsx'),
  mainContent
);

// Create App.tsx
const appContent = `import React from 'react';
import { theme } from './config/theme';

function App() {
  return (
    <div style={{ 
      color: theme.primaryColor,
      fontFamily: 'Arial, sans-serif',
      maxWidth: '800px',
      margin: '0 auto',
      padding: '2rem'
    }}>
      <h1>{theme.siteName}</h1>
      <p>Convert your ${getConversionDescription(conversionMode)} easily.</p>
    </div>
  );
}

function getConversionDescription(mode) {
  switch(mode) {
    case 'jpgToHeic': return 'JPG files to HEIC';
    case 'heicToJpg': return 'HEIC files to JPG';
    case 'aviToMp4': return 'AVI files to MP4';
    default: return 'files';
  }
}

export default App;`;

fs.writeFileSync(
  path.join(variantDir, 'src', 'App.tsx'),
  appContent
);

// Update root package.json to add scripts for the new variant
const rootPackageJsonPath = path.join(__dirname, '../package.json');
const rootPackageJson = JSON.parse(fs.readFileSync(rootPackageJsonPath, 'utf8'));

rootPackageJson.scripts[`dev:${variantName}`] = `npm run dev --workspace=packages/${variantName}`;
rootPackageJson.scripts[`build:${variantName}`] = `npm run build --workspace=packages/${variantName}`;

fs.writeFileSync(
  rootPackageJsonPath,
  JSON.stringify(rootPackageJson, null, 2)
);

console.log(`Variant "${variantName}" created successfully!`);
console.log(`Run "npm run dev:${variantName}" to start development server.`);

// Helper function to adjust colors
function adjustColor(hex, percent) {
  // This is a simplified version
  // In a real implementation, this would convert hex to RGB, adjust, and convert back
  return hex;
}
EOF
```

## Phase 6: Testing the Monorepo Structure

### Step 15: Setup npm workspaces and install dependencies
```bash
# Install dependencies
npm install
```

### Step 16: Build the core package
```bash
# Build the core package
cd packages/core
npm run build
cd ../..
```

### Step 17: Run HEICFlip development server
```bash
# Start the HEICFlip variant
npm run dev:heicflip
```

## Phase 7: Creating a New Variant

### Step 18: Use the create-variant script to generate a new variant
```bash
# Create a new JPGFlip variant
node scripts/create-variant.js --name=jpgflip --mode=jpgToHeic --color=#3066BE
```

### Step 19: Customize the new variant
- Adjust colors if needed
- Modify conversion specific UI elements
- Test specific conversion functionality

### Step 20: Run the new variant
```bash
# Start the JPGFlip variant
npm run dev:jpgflip
```

## Finishing Touches

### Step 21: Create deployment configurations
- Create vercel.json (or other deployment platform configs) for each variant
- Set up custom domain configurations

### Step 22: Document the process
- Update README files
- Create developer documentation

---

## Summary: Creating a New Clone with Different Colors and Conversion Pair

To create a new clone with different colors and conversion type:

1. **Run the variant creator script**:
   ```bash
   node scripts/create-variant.js --name=aviflip --mode=aviToMp4 --color=#119DA4
   ```

2. **Customize the theme** (optional):
   ```bash
   # Edit packages/aviflip/src/config/theme.ts to fine-tune colors
   ```

3. **Test the new variant**:
   ```bash
   npm run dev:aviflip
   ```

4. **Deploy to a unique URL**:
   ```bash
   npm run build:aviflip
   # Deploy the build output in packages/aviflip/dist to your hosting provider
   ```

Following these steps creates a new variant with its own conversion type and theme, while sharing the core functionality with all other variants in the monorepo.

---

Last updated: April 30, 2025```

---

### [HEICFLIP-603]_vercel_deployment_guide.md

**Path:** meta/monorepo/[HEICFLIP-603]_vercel_deployment_guide.md

```markdown
# Vercel Deployment Guide for Monorepo Variants

This guide provides specific instructions for deploying multiple converter variants from a monorepo to Vercel, with domains managed through CloudFlare.

## Vercel Monorepo Configuration

Vercel has built-in support for monorepos, which makes it ideal for our multi-variant converter project.

## Prerequisites

- GitHub repository with the monorepo structure
- Vercel account connected to GitHub
- CloudFlare account with registered domains

## Setup Process for Each Variant

### 1. Create Vercel Configuration Files

Create a `vercel.json` file in each variant package:

**For HEICFlip (`packages/heicflip/vercel.json`):**
```json
{
  "buildCommand": "cd ../.. && npm run build:heicflip",
  "outputDirectory": "packages/heicflip/dist",
  "framework": "vite",
  "rewrites": [
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
```

**For JPGFlip (`packages/jpgflip/vercel.json`):**
```json
{
  "buildCommand": "cd ../.. && npm run build:jpgflip",
  "outputDirectory": "packages/jpgflip/dist",
  "framework": "vite",
  "rewrites": [
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
```

### 2. Set Up Projects on Vercel

For each variant:

1. Log in to the Vercel dashboard
2. Select "Add New..." → "Project"
3. Import your GitHub repository
4. Configure the project:
   - **Project Name**: `heicflip` (or variant name)
   - **Framework Preset**: Choose "Other"
   - **Root Directory**: Set to the specific variant directory (e.g., `packages/heicflip`)
   - **Build Command**: Leave empty (uses vercel.json)
   - **Output Directory**: Leave empty (uses vercel.json)
   - **Environment Variables**: Add any required env variables

5. Click "Deploy"

### 3. Configure Domains on Vercel

After the initial deployment:

1. Go to the project settings in Vercel dashboard
2. Select "Domains"
3. Add your domain (e.g., `heicflip.com`)
4. Vercel will provide DNS configuration instructions

### 4. Configure DNS on CloudFlare

1. Log in to your CloudFlare dashboard
2. Select your domain
3. Go to DNS settings
4. Add the DNS records provided by Vercel:
   - Usually a CNAME record pointing to `cname.vercel-dns.com`
   - For apex domains, you might need to use CloudFlare's CNAME flattening feature

### 5. SSL Configuration

1. In CloudFlare, set SSL/TLS encryption mode to "Full" or "Full (strict)"
2. In Vercel, ensure SSL is enabled for your domain

## Automated Deployment Process

Once set up, the deployment process becomes seamless:

1. Push changes to GitHub
2. Vercel automatically detects changes
3. Each variant project only rebuilds if its files changed
4. Deployment proceeds without disrupting other variants

## Efficient Preview Deployments

Vercel creates preview deployments for pull requests:

1. Create a branch for changes to a specific variant
2. Make changes and create a pull request
3. Vercel will create a preview deployment automatically
4. Test the variant on the preview URL before merging

## Managing Multiple Variant Deployments

To keep track of all your variant deployments:

1. Create a `deployments.md` file in your repo:
   ```markdown
   # Deployment URLs
   
   | Variant | Production URL | GitHub Repository | Vercel Dashboard |
   |---------|---------------|-------------------|------------------|
   | HEICFlip | [heicflip.com](https://heicflip.com) | [GitHub](https://github.com/yourusername/converter-monorepo) | [Vercel](https://vercel.com/yourusername/heicflip) |
   | JPGFlip | [jpgflip.com](https://jpgflip.com) | [GitHub](https://github.com/yourusername/converter-monorepo) | [Vercel](https://vercel.com/yourusername/jpgflip) |
   ```

2. Add each new variant to this table as you create it

## Adding a New Variant Deployment

When creating a new variant:

1. Create the variant in your monorepo
2. Add the appropriate `vercel.json` file
3. Push to GitHub
4. Create a new project in Vercel following the steps above
5. Configure the domain in Vercel and CloudFlare
6. Update your `deployments.md` file

## Handling Domain Configuration for Multiple Variants

When using multiple domains with CloudFlare:

1. Register each domain in CloudFlare
2. Set up DNS records for each domain pointing to the appropriate Vercel deployment
3. Configure SSL/TLS settings for each domain
4. Verify domain ownership in Vercel

## Troubleshooting Common Issues

### Build Fails for Specific Variant

If a build fails for a specific variant:

1. Check the Vercel build logs
2. Ensure the variant's build command works locally
3. Verify the `vercel.json` configuration is correct

### Domain Configuration Issues

If your domain isn't connecting properly:

1. Verify DNS records in CloudFlare match Vercel's requirements
2. Check for DNS propagation delays (can take up to 48 hours)
3. Ensure CloudFlare's proxy settings are configured correctly

---

Last updated: April 30, 2025```

---

### [HEICFLIP-605]_monorepo_sample_files.md

**Path:** meta/monorepo/[HEICFLIP-605]_monorepo_sample_files.md

```markdown
# Monorepo Sample Files

This document provides example files for key components of the monorepo structure. These can be used as templates when implementing the monorepo conversion.

## Root Package.json

```json
{
  "name": "flip-converters",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev:heicflip": "npm run dev --workspace=packages/heicflip",
    "dev:jpgflip": "npm run dev --workspace=packages/jpgflip",
    "dev:aviflip": "npm run dev --workspace=packages/aviflip",
    "build:all": "node scripts/build-all.js",
    "build:heicflip": "npm run build --workspace=packages/heicflip",
    "build:jpgflip": "npm run build --workspace=packages/jpgflip",
    "build:aviflip": "npm run build --workspace=packages/aviflip",
    "create-variant": "node scripts/create-variant.js"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

## Core Package Files

### packages/core/package.json

```json
{
  "name": "@flip/core",
  "version": "1.0.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "@ffmpeg/core": "^0.11.0",
    "@ffmpeg/ffmpeg": "^0.11.0",
    "@ffmpeg/util": "^0.12.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "typescript": "^5.0.0"
  }
}
```

### packages/core/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "declaration": true,
    "outDir": "./dist",
    "esModuleInterop": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
```

### packages/core/src/index.ts

```typescript
// Theme System
export * from './ui/themes/base';

// Conversion Utilities
export * from './conversion/types';
export * from './conversion/converters';

// UI Components
export * from './ui/components';
```

### packages/core/src/ui/themes/base.ts

```typescript
export interface BaseTheme {
  siteName: string;
  defaultConversionMode: string;
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  logoText: string;
  domain: string;
}

export const baseTheme: BaseTheme = {
  siteName: "HEICFlip",
  defaultConversionMode: "heicToJpg",
  primaryColor: "#DD7230",
  secondaryColor: "#B85A25",
  accentColor: "#F39C6B",
  logoText: "HEICFlip",
  domain: "heicflip.com"
};

export type ThemeOverrides = Partial<BaseTheme>;

export function createTheme(overrides: ThemeOverrides = {}): BaseTheme {
  return {
    ...baseTheme,
    ...overrides
  };
}
```

### packages/core/src/conversion/types.ts

```typescript
export type ConversionMode = 
  | 'heicToJpg' 
  | 'jpgToHeic' 
  | 'aviToMp4' 
  | 'mp4ToAvi'
  | 'pngToJpg'
  | 'jpgToPng';

export interface ConversionOptions {
  quality?: number;
  preserveMetadata?: boolean;
  outputFormat?: string;
}

export interface ConversionResult {
  success: boolean;
  outputFile?: File;
  error?: string;
}

export interface ConverterInterface {
  convert(file: File, options?: ConversionOptions): Promise<ConversionResult>;
  getSupportedInputFormats(): string[];
  getOutputFormat(): string;
}
```

## HEICFlip Variant Files

### packages/heicflip/package.json

```json
{
  "name": "@flip/heicflip",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@flip/core": "1.0.0",
    "@ffmpeg/core": "^0.11.0",
    "@ffmpeg/ffmpeg": "^0.11.0",
    "@ffmpeg/util": "^0.12.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-dropzone": "^14.2.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.0.3",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.27",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.0.2",
    "vite": "^4.4.5"
  }
}
```

### packages/heicflip/vite.config.ts

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  server: {
    port: 3000,
    host: '0.0.0.0',
    headers: {
      "Cross-Origin-Embedder-Policy": "require-corp",
      "Cross-Origin-Opener-Policy": "same-origin"
    }
  },
  build: {
    outDir: 'dist',
    sourcemap: true
  }
});
```

### packages/heicflip/src/config/theme.ts

```typescript
import { createTheme, ThemeOverrides } from '@flip/core';

const heicflipTheme: ThemeOverrides = {
  siteName: "HEICFlip",
  defaultConversionMode: "heicToJpg",
  primaryColor: "#DD7230",
  secondaryColor: "#B85A25",
  accentColor: "#F39C6B",
  logoText: "HEICFlip",
  domain: "heicflip.com"
};

export const theme = createTheme(heicflipTheme);
```

### packages/heicflip/vercel.json

```json
{
  "buildCommand": "cd ../.. && npm run build:heicflip",
  "outputDirectory": "packages/heicflip/dist",
  "framework": "vite",
  "rewrites": [
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
```

## Script Examples

### scripts/build-all.js

```javascript
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const packagesDir = path.join(__dirname, '../packages');
const packages = fs.readdirSync(packagesDir)
  .filter(dir => fs.statSync(path.join(packagesDir, dir)).isDirectory());

// Build core package first
console.log('Building @flip/core...');
execSync('npm run build', { cwd: path.join(packagesDir, 'core'), stdio: 'inherit' });

// Build variant packages
for (const pkg of packages.filter(p => p !== 'core')) {
  console.log(`Building @flip/${pkg}...`);
  execSync('npm run build', { cwd: path.join(packagesDir, pkg), stdio: 'inherit' });
}

console.log('All packages built successfully!');
```

### scripts/create-variant.js

```javascript
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Parse command line arguments
const args = process.argv.slice(2);
const nameArg = args.find(arg => arg.startsWith('--name='));
const modeArg = args.find(arg => arg.startsWith('--mode='));
const colorArg = args.find(arg => arg.startsWith('--color='));

if (!nameArg) {
  console.error('Error: Missing --name parameter');
  console.log('Usage: node create-variant.js --name=variantname --mode=conversionMode --color=#HEXCOLOR');
  process.exit(1);
}

const variantName = nameArg.split('=')[1];
const conversionMode = modeArg ? modeArg.split('=')[1] : 'jpgToHeic'; // Default mode
const primaryColor = colorArg ? colorArg.split('=')[1] : '#3066BE'; // Default color

const variantDir = path.join(__dirname, '../packages', variantName);

// Create variant directory structure
console.log(`Creating new variant: ${variantName}`);
fs.mkdirSync(variantDir);
fs.mkdirSync(path.join(variantDir, 'src'));
fs.mkdirSync(path.join(variantDir, 'src', 'config'));

// Create package.json
const packageJson = {
  name: `@flip/${variantName}`,
  version: "1.0.0",
  private: true,
  scripts: {
    dev: "vite",
    build: "vite build",
    preview: "vite preview"
  },
  dependencies: {
    "@flip/core": "1.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  devDependencies: {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.0.0",
    "typescript": "^5.0.0",
    "vite": "^4.0.0"
  }
};

fs.writeFileSync(
  path.join(variantDir, 'package.json'),
  JSON.stringify(packageJson, null, 2)
);

// Copy vite.config.ts from heicflip
fs.copyFileSync(
  path.join(__dirname, '../packages/heicflip/vite.config.ts'),
  path.join(variantDir, 'vite.config.ts')
);

// Create theme configuration
const themeContent = `import { createTheme, ThemeOverrides } from '@flip/core';

const ${variantName}Theme: ThemeOverrides = {
  siteName: "${variantName.charAt(0).toUpperCase() + variantName.slice(1)}",
  defaultConversionMode: "${conversionMode}",
  primaryColor: "${primaryColor}",
  secondaryColor: "${adjustColor(primaryColor, -20)}", // Darker version
  accentColor: "${adjustColor(primaryColor, 20)}", // Lighter version
  logoText: "${variantName.charAt(0).toUpperCase() + variantName.slice(1)}",
  domain: "${variantName}.com"
};

export const theme = createTheme(${variantName}Theme);

// Helper function to compute secondary/accent colors
function adjustColor(hex, percent) {
  // Simple color adjustment function
  // In a real implementation, this would properly lighten/darken colors
  return hex;
}`;

fs.writeFileSync(
  path.join(variantDir, 'src', 'config', 'theme.ts'),
  themeContent
);

// Create main.tsx
const mainContent = `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { theme } from './config/theme';

console.log('Running in ${variantName.charAt(0).toUpperCase() + variantName.slice(1)} mode with configuration:', theme);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);`;

fs.writeFileSync(
  path.join(variantDir, 'src', 'main.tsx'),
  mainContent
);

// Create Vercel config
const vercelConfig = {
  "buildCommand": `cd ../.. && npm run build:${variantName}`,
  "outputDirectory": `packages/${variantName}/dist`,
  "framework": "vite",
  "rewrites": [
    { "source": "/(.*)", "destination": "/index.html" }
  ]
};

fs.writeFileSync(
  path.join(variantDir, 'vercel.json'),
  JSON.stringify(vercelConfig, null, 2)
);

// Update root package.json to add scripts for the new variant
const rootPackageJsonPath = path.join(__dirname, '../package.json');
const rootPackageJson = JSON.parse(fs.readFileSync(rootPackageJsonPath, 'utf8'));

rootPackageJson.scripts[`dev:${variantName}`] = `npm run dev --workspace=packages/${variantName}`;
rootPackageJson.scripts[`build:${variantName}`] = `npm run build --workspace=packages/${variantName}`;

fs.writeFileSync(
  rootPackageJsonPath,
  JSON.stringify(rootPackageJson, null, 2)
);

console.log(`Variant "${variantName}" created successfully!`);
console.log(`Run "npm run dev:${variantName}" to start development server.`);

// Helper function to adjust colors
function adjustColor(hex, percent) {
  // This is a simplified version that doesn't actually modify the color
  // In a real implementation, this would convert hex to RGB, adjust, and convert back
  return hex;
}
```

---

Last updated: April 30, 2025```

---

### [HEICFLIP-611]_monorepo_checklist.md

**Path:** meta/monorepo/[HEICFLIP-611]_monorepo_checklist.md

```markdown
# Monorepo Implementation Checklist

This checklist covers all the necessary steps to implement a fully-functional monorepo structure for the converter applications.

## Initial Setup

- [ ] Create directory structure
  - [ ] /packages
  - [ ] /packages/core
  - [ ] /packages/heicflip
  - [ ] /packages/jpgflip
  - [ ] /scripts

- [ ] Configure workspace
  - [ ] Create root package.json with workspaces
  - [ ] Set up initial scripts
  - [ ] Configure TypeScript

## Core Package 

- [ ] Extract core functionality
  - [ ] Create core package.json
  - [ ] Set up core tsconfig.json
  - [ ] Create src directory structure

- [ ] Implement theme system
  - [ ] Create BaseTheme interface
  - [ ] Define base theme values
  - [ ] Create theme overrides mechanism
  - [ ] Implement createTheme function

- [ ] Extract conversion logic
  - [ ] Create conversion module
  - [ ] Define conversion interfaces
  - [ ] Extract HEIC to JPG converter
  - [ ] Extract JPG to HEIC converter

- [ ] Build setup for core
  - [ ] Configure build script
  - [ ] Set up TypeScript compilation
  - [ ] Create proper exports

## HEICFlip Variant

- [ ] Set up basic structure
  - [ ] Create package.json
  - [ ] Configure TypeScript
  - [ ] Set up Vite configuration

- [ ] Implement theme
  - [ ] Create theme configuration
  - [ ] Apply theme to components
  - [ ] Set up variant-specific assets

- [ ] Create entry point
  - [ ] Set up main.tsx
  - [ ] Create App component
  - [ ] Configure routing

- [ ] Add Vercel configuration
  - [ ] Create vercel.json
  - [ ] Configure build settings
  - [ ] Set up routing rules

## JPGFlip Variant

- [ ] Set up basic structure
  - [ ] Create package.json
  - [ ] Configure TypeScript
  - [ ] Set up Vite configuration

- [ ] Implement theme
  - [ ] Create theme with different colors
  - [ ] Configure for JPG to HEIC conversion
  - [ ] Set up variant-specific assets

- [ ] Create entry point
  - [ ] Set up main.tsx
  - [ ] Create App component
  - [ ] Configure routing

- [ ] Add Vercel configuration
  - [ ] Create vercel.json
  - [ ] Configure build settings
  - [ ] Set up routing rules

## Build and Development Scripts

- [ ] Create build-all.js script
  - [ ] Implement core package building
  - [ ] Add variant package building
  - [ ] Set up proper build order

- [ ] Create create-variant.js script
  - [ ] Implement command line parsing
  - [ ] Add template file creation
  - [ ] Configure theme generation
  - [ ] Set up proper package.json generation

- [ ] Configure development environment
  - [ ] Set up dev scripts for each variant
  - [ ] Configure hot reloading
  - [ ] Ensure proper dependency resolution

## Deployment Configuration

- [ ] Vercel setup
  - [ ] Create projects for each variant
  - [ ] Configure build settings
  - [ ] Set up environment variables

- [ ] CloudFlare configuration
  - [ ] Configure DNS for each domain
  - [ ] Set up SSL certificates
  - [ ] Configure caching rules

- [ ] GitHub integration
  - [ ] Configure repository
  - [ ] Set up CI/CD workflows if needed
  - [ ] Configure branch protection

## Testing

- [ ] Local testing
  - [ ] Test core package functionality
  - [ ] Verify variant-specific features
  - [ ] Check theme application

- [ ] Build testing
  - [ ] Test build process for all variants
  - [ ] Verify output files
  - [ ] Check for optimization issues

- [ ] Deployment testing
  - [ ] Test each variant on its domain
  - [ ] Verify functionality in production
  - [ ] Check for cross-origin issues

## Documentation

- [ ] Developer documentation
  - [ ] Document monorepo structure
  - [ ] Create guide for adding new variants
  - [ ] Document theme system

- [ ] Deployment documentation
  - [ ] Document Vercel deployment process
  - [ ] Create CloudFlare configuration guide
  - [ ] Add troubleshooting information

- [ ] User documentation
  - [ ] Update any user-facing documentation
  - [ ] Document differences between variants

## Final Steps

- [ ] Cleanup
  - [ ] Remove unused files
  - [ ] Optimize dependencies
  - [ ] Check for duplicated code

- [ ] Performance optimization
  - [ ] Review bundle sizes
  - [ ] Check for unnecessary dependencies
  - [ ] Optimize shared code

- [ ] Security review
  - [ ] Ensure secrets are properly stored
  - [ ] Check for vulnerable dependencies
  - [ ] Review permission settings

---

Last updated: April 30, 2025```

---

### [HEICFLIP-601]_migration_guide.md

**Path:** meta/monorepo/[HEICFLIP-601]_migration_guide.md

```markdown
# Migration Guide: Converting to Monorepo Structure

This document provides step-by-step instructions for migrating the current project to a monorepo structure that supports multiple converter variants.

## Migration Process Overview

1. Create the monorepo directory structure
2. Extract shared code into the core package
3. Create the HEICFlip variant (using current code as base)
4. Establish the theme system
5. Set up build and deployment configurations
6. Add additional variants (JPGFlip, AVIFlip, etc.)

## Detailed Steps

### Step 1: Create Base Directory Structure

```bash
# Create the monorepo structure
mkdir -p packages/{core,heicflip,jpgflip}/src
mkdir -p scripts
mkdir -p shared

# Copy shared schema
cp shared/schema.ts shared/
```

### Step 2: Set Up Root Configuration

Create a root `package.json` with workspaces configuration:

```json
{
  "name": "flip-converters",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev:heicflip": "npm run dev --workspace=packages/heicflip",
    "dev:jpgflip": "npm run dev --workspace=packages/jpgflip",
    "build:all": "node scripts/build-all.js",
    "build:heicflip": "npm run build --workspace=packages/heicflip",
    "build:jpgflip": "npm run build --workspace=packages/jpgflip",
    "create-variant": "node scripts/create-variant.js"
  }
}
```

### Step 3: Extract Core Functionality

1. Identify shared code:
   - Conversion logic
   - UI components
   - Utilities
   - Types

2. Move them to the core package:
   ```bash
   # Create core package.json
   echo '{
     "name": "@flip/core",
     "version": "1.0.0",
     "private": true,
     "main": "dist/index.js",
     "types": "dist/index.d.ts",
     "dependencies": {
       # Copy dependencies from current package.json
     }
   }' > packages/core/package.json
   
   # Create index.ts to export all core functionality
   touch packages/core/src/index.ts
   ```

### Step 4: Create HEICFlip Variant

1. Use the current codebase as the foundation:
   ```bash
   # Copy current client code to the heicflip package
   cp -r client/src/* packages/heicflip/src/
   
   # Create heicflip package.json
   echo '{
     "name": "@flip/heicflip",
     "version": "1.0.0",
     "private": true,
     "dependencies": {
       "@flip/core": "1.0.0",
       # Other dependencies...
     }
   }' > packages/heicflip/package.json
   
   # Copy vite configuration
   cp vite.config.ts packages/heicflip/
   ```

2. Update imports to use the core package:
   ```typescript
   // Before
   import { someUtil } from '../../utils';
   
   // After
   import { someUtil } from '@flip/core';
   ```

### Step 5: Establish Theme System

1. Extract theme configuration:
   ```bash
   mkdir -p packages/core/src/ui/themes
   touch packages/core/src/ui/themes/base.ts
   ```

2. Create theme system in the core:
   ```typescript
   // packages/core/src/ui/themes/base.ts
   export interface BaseTheme {
     siteName: string;
     defaultConversionMode: string;
     primaryColor: string;
     secondaryColor: string;
     accentColor: string;
     logoText: string;
     domain: string;
   }
   
   export const baseTheme: BaseTheme = {
     siteName: "HEICFlip",
     defaultConversionMode: "heicToJpg",
     primaryColor: "#DD7230",
     secondaryColor: "#B85A25",
     accentColor: "#F39C6B",
     logoText: "HEICFlip",
     domain: "heicflip.com"
   };
   ```

### Step 6: Set Up Build and Deployment Scripts

Create scripts for building and deploying:

```javascript
// scripts/build-all.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const packagesDir = path.join(__dirname, '../packages');
const packages = fs.readdirSync(packagesDir)
  .filter(dir => fs.statSync(path.join(packagesDir, dir)).isDirectory());

// Build core package first
console.log('Building @flip/core...');
execSync('npm run build', { cwd: path.join(packagesDir, 'core'), stdio: 'inherit' });

// Build variant packages
for (const pkg of packages.filter(p => p !== 'core')) {
  console.log(`Building @flip/${pkg}...`);
  execSync('npm run build', { cwd: path.join(packagesDir, pkg), stdio: 'inherit' });
}

console.log('All packages built successfully!');
```

### Step 7: Create Additional Variants

1. Create a script to generate new variants:
   ```javascript
   // scripts/create-variant.js
   const fs = require('fs');
   const path = require('path');
   const { execSync } = require('child_process');
   
   const args = process.argv.slice(2);
   const nameArg = args.find(arg => arg.startsWith('--name='));
   
   if (!nameArg) {
     console.error('Error: Missing --name parameter');
     console.log('Usage: node create-variant.js --name=variantname');
     process.exit(1);
   }
   
   const variantName = nameArg.split('=')[1];
   const variantDir = path.join(__dirname, '../packages', variantName);
   
   // Create variant directory structure
   fs.mkdirSync(variantDir);
   fs.mkdirSync(path.join(variantDir, 'src'));
   
   // Copy template files from heicflip
   // ... code to copy and modify template files
   
   console.log(`Variant "${variantName}" created successfully!`);
   ```

2. Create JPGFlip variant as an example:
   ```bash
   node scripts/create-variant.js --name=jpgflip
   ```

## Testing the Migration

1. Test the core package:
   ```bash
   cd packages/core
   npm test
   ```

2. Test each variant:
   ```bash
   npm run dev:heicflip
   # In another terminal
   npm run dev:jpgflip
   ```

## Deployment Strategy

For deployment, each variant will need:

1. A unique deployment configuration (vercel.json, etc.)
2. Custom domain settings
3. Environment variables if needed

Example Vercel configuration for HEICFlip:

```json
// packages/heicflip/vercel.json
{
  "name": "heicflip",
  "buildCommand": "cd ../.. && npm run build:heicflip",
  "outputDirectory": "packages/heicflip/dist"
}
```

## Rollback Plan

If the migration encounters issues:

1. Keep the original codebase functional and untouched
2. Develop the monorepo structure in parallel
3. Only switch over when fully tested

---

Last updated: April 30, 2025```

---

### [HEICFLIP-620]_monorepo_approach_comparison.md

**Path:** meta/monorepo/[HEICFLIP-620]_monorepo_approach_comparison.md

```markdown
# Monorepo Implementation Approaches: Npm Workspaces vs. Subdirectories

This document compares the two primary approaches for implementing a monorepo structure and explains why npm workspaces is the recommended approach for this project.

## Approach 1: Simple Subdirectories

### Overview
In this approach, you organize code into subdirectories, but each directory isn't treated as a separate package. There's typically one package.json at the root level.

### Example Structure
```
/
├── package.json
├── tsconfig.json
├── heicflip/
│   ├── src/
│   └── ...
├── jpgflip/
│   ├── src/
│   └── ...
└── shared/
    ├── src/
    └── ...
```

### Pros
- Simpler initial setup
- No need to manage multiple package.json files
- Easier to understand for developers unfamiliar with workspaces
- Single node_modules folder

### Cons
- No clear boundaries between packages
- Harder to manage dependencies for specific variants
- Can't build or run variants independently
- Can't publish variants as separate packages
- No isolation of package dependencies

## Approach 2: Npm Workspaces

### Overview
Npm workspaces treat each subdirectory as a separate package with its own package.json, while sharing a single node_modules folder at the root.

### Example Structure
```
/
├── package.json (with "workspaces" field)
├── packages/
│   ├── core/
│   │   ├── package.json
│   │   └── src/
│   ├── heicflip/
│   │   ├── package.json
│   │   └── src/
│   └── jpgflip/
│       ├── package.json
│       └── src/
└── shared/
    └── schema.ts
```

### Pros
- Clear package boundaries and ownership
- Can run commands on specific variants (`npm run build --workspace=packages/heicflip`)
- Proper dependency management between packages
- Single node_modules folder (avoids duplication)
- Can deploy variants independently
- Better support for scaling with many variants
- Each variant can specify its own dependencies

### Cons
- Slightly more complex setup
- Multiple package.json files to maintain
- More complex build configuration

## Recommended Approach: Npm Workspaces

For the converter monorepo project, **npm workspaces** is strongly recommended for these reasons:

1. **Independent Deployments**: Each variant can be built and deployed independently to different domains.

2. **Dependency Isolation**: Each variant can specify different dependencies if needed (e.g., if JPGFlip needs a specific library that HEICFlip doesn't).

3. **Clear Boundaries**: The core shared functionality is clearly separated from variant-specific code.

4. **Scalability**: As you add more converter variants, the workspace structure scales more effectively.

5. **Vercel Compatibility**: Vercel has excellent support for monorepos using workspaces, making deployment simpler.

6. **Better Development Experience**: Developers can work on one variant without affecting others.

## Implementation Details

For npm workspaces:

1. **Root package.json**:
```json
{
  "name": "flip-converters",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev:heicflip": "npm run dev --workspace=packages/heicflip",
    "dev:jpgflip": "npm run dev --workspace=packages/jpgflip",
    "build:all": "node scripts/build-all.js",
    "build:heicflip": "npm run build --workspace=packages/heicflip",
    "build:jpgflip": "npm run build --workspace=packages/jpgflip"
  }
}
```

2. **Package references**: Packages can reference each other:
```json
// packages/heicflip/package.json
{
  "name": "@flip/heicflip",
  "dependencies": {
    "@flip/core": "1.0.0"
  }
}
```

3. **Import statements**: Import directly from packages:
```typescript
// In packages/heicflip/src/App.tsx
import { AdBanner } from '@flip/core';
```

## Specific Benefits for Your Project

1. **Multi-domain Deployment**: With npm workspaces, deploying to different domains (heicflip.com, jpgflip.com, etc.) becomes much simpler.

2. **Maintenance**: When you need to update shared functionality, you make changes in one place (core package) and all variants benefit.

3. **Ad Configuration**: Each variant can have its own ad configuration while using shared ad components.

4. **Version Control**: Easier to track changes across variants.

5. **Development Efficiency**: Focus on developing or fixing one variant without affecting others.

---

Last updated: April 30, 2025```

---

### [HEICFLIP-621]_vercel_monorepo_benefits.md

**Path:** meta/monorepo/[HEICFLIP-621]_vercel_monorepo_benefits.md

```markdown
# Vercel and npm Workspaces: Perfect Integration

This document explains why Vercel's platform works exceptionally well with npm workspace-based monorepos and the specific benefits for your converter project.

## Vercel's Built-in Monorepo Support

Vercel has built-in, first-class support for monorepos using npm workspaces. Here's why:

### 1. Automatic Project Detection

Vercel automatically detects npm workspaces in your repository and offers to create separate projects for each workspace. This makes it easy to deploy multiple applications from a single repository.

### 2. Turborepo Integration

Vercel (which acquired Turborepo) has deep integration with modern monorepo tooling. While we're using basic npm workspaces, the platform is optimized for this exact structure.

### 3. Intelligent Build Caching

Vercel uses dependency analysis to:
- Only rebuild packages that have changed
- Cache build artifacts for faster deployments
- Optimize CI/CD pipelines for monorepos

### 4. Project-Specific Environment Variables

Each project (variant) can have its own environment variables, which is perfect for:
- Different ad network configurations per variant
- Domain-specific settings
- API keys that might differ between variants

## Deployment Benefits for Your Converters

For your specific project with multiple themed converters:

### 1. Domain Mapping

Each variant can be easily deployed to its own domain:
- heicflip.com → packages/heicflip
- jpgflip.com → packages/jpgflip
- aviflip.com → packages/aviflip

### 2. Independent Updates

You can update one converter variant without affecting others:
- Fix a bug in HEICFlip while JPGFlip remains untouched
- Roll out new features to one variant at a time
- Test changes in isolation

### 3. Shared Core Updates

When you update the core package:
- Vercel intelligently rebuilds all dependent projects
- Ensures consistent functionality across all variants
- Properly resolves dependencies

### 4. Preview Deployments

For each pull request:
- Vercel creates preview deployments for affected variants
- You can test changes on actual domains before merging
- Stakeholders can review changes with real URLs

## Vercel-Specific Configuration for npm Workspaces

Vercel uses the following key configurations that align perfectly with npm workspaces:

### 1. Project Settings

For each variant, Vercel will use:
- **Root Directory**: `packages/[variant-name]`
- **Build Command**: From the variant's package.json or vercel.json
- **Output Directory**: Default `dist` or from configuration

### 2. Vercel.json Configuration (Per Variant)

Each variant should have its own `vercel.json` file:

```json
{
  "buildCommand": "cd ../.. && npm run build:[variant-name]",
  "outputDirectory": "packages/[variant-name]/dist",
  "framework": "vite"
}
```

This allows Vercel to build the projects correctly, handling workspace dependencies.

## Practical Example

Here's how our monorepo will be deployed on Vercel:

1. Push the monorepo to GitHub
2. Connect Vercel to the GitHub repository
3. Vercel detects the workspace structure
4. Create projects for each variant:
   - HEICFlip project points to packages/heicflip
   - JPGFlip project points to packages/jpgflip
5. Configure domains for each project:
   - heicflip.com → HEICFlip project
   - jpgflip.com → JPGFlip project
6. When you push changes:
   - Changes to core → all projects rebuild
   - Changes to just one variant → only that project rebuilds

## Additional Vercel Optimizations

To further optimize your Vercel deployment with npm workspaces:

1. **Build Cache**: Add `.vercel/output` to `.gitignore`
2. **Dependency Installation**: Vercel will respect your workspace setup
3. **Edge Functions**: Available per-project for any variant-specific optimizations

---

Last updated: April 30, 2025```

---

### [HEICFLIP-630]_implementation_timeline.md

**Path:** meta/monorepo/[HEICFLIP-630]_implementation_timeline.md

```markdown
# Monorepo Implementation Timeline

This document outlines the planned sequence for implementing the monorepo structure, with each phase building upon the previous one.

## Phase 1: Core Infrastructure Setup (Current)

- [x] Create directory structure
- [x] Set up package.json files with workspaces
- [x] Configure TypeScript
- [x] Implement core theme system
- [x] Create build scripts
- [x] Create variant generator script

## Phase 2: Core Package Population

- [ ] Extract common UI components to core
- [ ] Move conversion logic to core
- [ ] Implement shared utilities
- [ ] Set up proper TypeScript path aliases
- [ ] Add shared type definitions

## Phase 3: First Variant Creation

- [ ] Configure HEICFlip as the primary variant
- [ ] Move current app code to HEICFlip variant
- [ ] Update imports to use core package
- [ ] Configure Vite for proper bundling
- [ ] Test basic functionality

## Phase 4: Database Integration

- [ ] Configure shared schema definitions
- [ ] Implement proper database connections
- [ ] Set up environment variables for database access
- [ ] Test database persistence

## Phase 5: Ad Framework Implementation

- [ ] Create shared ad components
- [ ] Set up ad configuration system
- [ ] Add placeholder ads for testing
- [ ] Create ads.txt generation
- [ ] Implement cookie consent for GDPR compliance

## Phase 6: Second Variant Creation

- [ ] Create JPGFlip variant
- [ ] Configure theme with different colors
- [ ] Customize for JPG to HEIC conversion
- [ ] Set up variant-specific features
- [ ] Test conversion functionality

## Phase 7: Deployment Configuration

- [ ] Create Vercel configuration files
- [ ] Set up GitHub integration
- [ ] Configure custom domains
- [ ] Set up CloudFlare DNS
- [ ] Create deployment documentation

## Phase 8: Variant Creation Testing

- [ ] Test variant creation script
- [ ] Create a test variant (e.g., AVIFlip)
- [ ] Verify theme updates
- [ ] Confirm conversion functionality
- [ ] Test deployment process

## Phase 9: Documentation and Finalization

- [ ] Update all documentation
- [ ] Create developer guides
- [ ] Document maintenance procedures
- [ ] Create backups
- [ ] Final testing across all variants

## Estimated Timeline

| Phase | Description | Estimated Time |
|-------|-------------|----------------|
| 1 | Core Infrastructure | 4-6 hours |
| 2 | Core Package Population | 6-8 hours |
| 3 | First Variant Creation | 4-6 hours |
| 4 | Database Integration | 2-3 hours |
| 5 | Ad Framework | 3-4 hours |
| 6 | Second Variant Creation | 2-3 hours |
| 7 | Deployment Configuration | 2-3 hours |
| 8 | Variant Creation Testing | 1-2 hours |
| 9 | Documentation and Finalization | 2-3 hours |

Total estimated time: 26-38 hours of development work

## Current Focus (Phase 2)

We're currently focusing on extracting common functionality to the core package while maintaining the ability to customize each variant. Once the core package is fully populated, we'll move on to creating the first variant (HEICFlip) using the extracted core functionality.

The variant creation script has been created early to establish the patterns and requirements for our variants, but testing it will be done in Phase 8 after all the core functionality is working properly.

---

Last updated: April 30, 2025```

---

### [HEICFLIP-610]_implementation_plan.md

**Path:** meta/monorepo/[HEICFLIP-610]_implementation_plan.md

```markdown
# Comprehensive Monorepo Implementation Plan

This document outlines the complete step-by-step process for implementing the monorepo structure for the converter applications.

## Phase 1: Preparation and Analysis

### 1. Analyze Current Codebase
- Review existing files and structure
- Identify components that can be shared across variants
- Make an inventory of dependencies

### 2. Create Directory Structure
- Create `packages` directory at the root level
- Create subdirectories for core and variants
- Set up initial configuration files

### 3. Install Required Tools
- Update npm/Node.js if needed
- Install workspace-compatible tools

## Phase 2: Core Package Extraction

### 4. Extract Core Functionality
- Move shared UI components to core package
- Extract conversion engine to core package
- Create theme system in core package
- Set up type definitions in core package

### 5. Create Build System for Core
- Set up TypeScript configuration
- Create build scripts
- Implement proper exports

## Phase 3: Create HEICFlip Variant

### 6. Move Current App to HEICFlip Variant
- Copy relevant files to the `packages/heicflip` directory
- Update imports to use core package
- Configure variant-specific settings

### 7. Update Theme Configuration
- Create theme file for HEICFlip
- Implement overrides of base theme
- Apply theme throughout the application

## Phase 4: Setup Build System

### 8. Create Root Package.json
- Configure workspaces
- Set up scripts for development and building
- Define common dependencies

### 9. Create Build Scripts
- Implement build-all script
- Create individual variant build scripts
- Set up development server configurations

## Phase 5: Create JPGFlip Variant

### 10. Create Variant Generator Script
- Implement script to create new variants
- Add color and mode configuration options
- Include proper file copying and customization

### 11. Generate JPGFlip Variant
- Run variant generator script
- Customize for JPG to HEIC conversion
- Test the new variant

## Phase 6: Deployment Configuration

### 12. Create Vercel Configuration
- Add vercel.json files for each variant
- Configure build and output settings
- Set up API endpoints if needed

### 13. Set Up Domain Configuration
- Configure CloudFlare DNS settings
- Create domain mapping for each variant
- Set up SSL certificates

## Phase 7: Testing

### 14. Test Local Development
- Verify all variants work locally
- Check that core changes propagate to variants
- Ensure proper isolation between variants

### 15. Test Build Process
- Verify all variants build correctly
- Check bundled output for optimization
- Test build script reliability

## Phase 8: Documentation

### 16. Create Developer Documentation
- Document monorepo structure
- Create guides for adding new variants
- Explain theme customization

### 17. Create Deployment Documentation
- Document Vercel deployment process
- Explain domain configuration
- Create troubleshooting guide

## Implementation Timeline

| Phase | Task | Estimated Time | Dependencies |
|-------|------|----------------|--------------|
| 1 | Preparation and Analysis | 2-3 hours | None |
| 2 | Core Package Extraction | 4-6 hours | Phase 1 |
| 3 | Create HEICFlip Variant | 2-3 hours | Phase 2 |
| 4 | Setup Build System | 2-3 hours | Phase 3 |
| 5 | Create JPGFlip Variant | 1-2 hours | Phase 4 |
| 6 | Deployment Configuration | 2-3 hours | Phase 5 |
| 7 | Testing | 3-4 hours | Phase 6 |
| 8 | Documentation | 2-3 hours | Phase 7 |

Total estimated time: 18-27 hours

## Implementation Execution Plan

### Day 1: Foundation
- Complete Phases 1-3
- Verify core functionality works in HEICFlip variant

### Day 2: Expansion
- Complete Phases 4-5
- Create at least one additional variant
- Test all variants locally

### Day 3: Deployment and Polish
- Complete Phases 6-8
- Deploy all variants
- Finalize documentation
- Conduct final testing

## Required Credentials and Information

To complete the implementation, we'll need:

1. GitHub repository access
2. Vercel account credentials (or access to deploy)
3. CloudFlare domain management access
4. Any API keys needed for external services
5. Color schemes for each variant
6. Domain names for each variant

## Approval Checkpoints

We'll seek your approval at these key stages:

1. After analyzing the current codebase and creating the directory structure
2. After extracting the core package
3. After creating the first variant (HEICFlip)
4. Before creating additional variants
5. Before deploying to Vercel
6. After deployment is complete

---

Last updated: April 30, 2025```

---

### [HEICFLIP-604]_cloudflare_domain_configuration.md

**Path:** meta/monorepo/[HEICFLIP-604]_cloudflare_domain_configuration.md

```markdown
# CloudFlare Domain Configuration for Multiple Converters

This guide provides detailed instructions for managing multiple domains on CloudFlare and connecting them to your Vercel-hosted converter variants.

## Domain Management Strategy

For a multi-variant converter project, each variant needs its own domain:
- heicflip.com
- jpgflip.com
- aviflip.com
- etc.

## CloudFlare Setup Process

### 1. Register Domains

If you haven't already:

1. Log in to CloudFlare
2. Go to "Domains" → "Register"
3. Search for and register each domain you need
4. Complete the registration process

### 2. Add Existing Domains to CloudFlare

If you already have domains registered elsewhere:

1. Log in to CloudFlare
2. Click "Add Site"
3. Enter your domain name
4. Select a plan (Free plan is sufficient for most needs)
5. Follow the instructions to update nameservers with your registrar

### 3. Configure DNS for Vercel

For each domain:

1. Go to the domain in CloudFlare dashboard
2. Select "DNS" from the menu
3. Add the appropriate DNS records for Vercel:

**For apex domains (e.g., `heicflip.com`):**
```
Type: A
Name: @
Content: 76.76.21.21
TTL: Auto
Proxy status: Proxied
```

**For www subdomain:**
```
Type: CNAME
Name: www
Content: cname.vercel-dns.com
TTL: Auto
Proxy status: Proxied
```

### 4. SSL/TLS Configuration

For optimal security:

1. Go to "SSL/TLS" in CloudFlare
2. Set encryption mode to "Full (strict)"
3. Enable "Always Use HTTPS"
4. Set minimum TLS version to 1.2

### 5. Configure Page Rules (Optional)

To enforce HTTPS and redirect www to non-www (or vice versa):

1. Go to "Rules" → "Page Rules"
2. Create a rule for HTTP to HTTPS redirect:
   - URL pattern: `http://*yourdomain.com/*`
   - Setting: "Always Use HTTPS"

3. Create a rule for www to non-www redirect (if preferred):
   - URL pattern: `www.yourdomain.com/*`
   - Setting: "Forwarding URL"
   - Status: 301
   - Destination: `https://yourdomain.com/$1`

## Verifying Domain Ownership on Vercel

After configuring DNS in CloudFlare:

1. Go to your Vercel project settings
2. Select "Domains"
3. Add your domain
4. Vercel will verify ownership via the DNS records
5. If verification fails, check your CloudFlare configuration

## Managing Multiple Domains

When managing multiple domains for different variants:

1. Create a spreadsheet or document with all domain details:
   - Domain name
   - Registrar
   - Expiration date
   - DNS configuration
   - Associated variant

2. Set calendar reminders for domain renewals

3. Create a consistent naming pattern for DNS records to stay organized

## CloudFlare Features to Leverage

### Performance

1. Enable Auto Minify (HTML, CSS, JS)
2. Enable Brotli compression
3. Configure caching rules for static assets

### Security

1. Configure Web Application Firewall (WAF)
2. Enable Bot Fight Mode
3. Set up rate limiting rules

### Analytics

1. Enable CloudFlare Analytics to track visitor metrics
2. Set up notifications for unusual traffic patterns

## Troubleshooting CloudFlare Issues

### Domain Not Connecting to Vercel

1. Verify nameservers are correctly set to CloudFlare
2. Check DNS records match Vercel's requirements
3. Temporarily disable CloudFlare proxy to test direct connection
4. Look for error messages in Vercel domain settings

### SSL Certificate Issues

1. Verify SSL mode is set to "Full" or "Full (strict)"
2. Check for certificate validation errors in CloudFlare
3. Ensure DNS is properly configured
4. Allow up to 24 hours for SSL certificate issuance

### Domain Propagation Delays

1. Use tools like [whatsmydns.net](https://www.whatsmydns.net/) to check propagation
2. Remember that DNS changes can take up to 48 hours to fully propagate
3. Test from multiple locations and networks

## Domain Management Best Practices

1. **Auto-Renewal**: Enable auto-renewal for all domains
2. **Contact Info**: Keep registrant contact information up to date
3. **Domain Locking**: Enable domain locking to prevent unauthorized transfers
4. **Email Forwarding**: Set up email forwarding for domain-based emails
5. **Documentation**: Maintain documentation of all domain settings

---

Last updated: April 30, 2025```

---

### [HEICFLIP-801]_monorepo_ad_implementation.md

**Path:** meta/monetization/[HEICFLIP-801]_monorepo_ad_implementation.md

```markdown
# Monorepo Ad Implementation Guide

This guide provides specific implementation steps for integrating advertising into the converter monorepo structure.

## Core Package Ad Components

First, we'll create reusable ad components in the core package that all variants can use.

### Step 1: Create Ad Component Directory Structure

```bash
mkdir -p packages/core/src/ui/components/ads
```

### Step 2: Create Base Ad Components

#### AdUnit.tsx

```typescript
// packages/core/src/ui/components/ads/AdUnit.tsx
import React, { useEffect, useRef } from 'react';
import { AdConfig } from '../../../utils/ads';

export interface AdUnitProps {
  adSlot: string;
  format: 'banner' | 'rectangle' | 'leaderboard' | 'interstitial';
  className?: string;
  provider: AdConfig['provider'];
}

export const AdUnit: React.FC<AdUnitProps> = ({ 
  adSlot, 
  format, 
  className = '',
  provider = 'adsense'
}) => {
  const adRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    // Only attempt to load ads in production
    if (import.meta.env.PROD) {
      try {
        if (provider === 'adsense' && window.adsbygoogle) {
          (window.adsbygoogle = window.adsbygoogle || []).push({});
        }
      } catch (error) {
        console.error('Error loading ad:', error);
      }
    }
  }, [provider]);

  if (provider === 'adsense') {
    return (
      <div ref={adRef} className={`ad-container ${format} ${className}`}>
        <ins
          className="adsbygoogle"
          style={{ 
            display: 'block',
            width: format === 'leaderboard' ? '728px' : '300px',
            height: format === 'leaderboard' ? '90px' : '250px',
            maxWidth: '100%',
            overflow: 'hidden'
          }}
          data-ad-client="ca-pub-XXXXXXXXXXXXXXXX" // Will be overridden by variant config
          data-ad-slot={adSlot}
          data-ad-format={format === 'interstitial' ? 'rectangle' : format}
          data-full-width-responsive="true"
        ></ins>
      </div>
    );
  }
  
  if (provider === 'ezoic') {
    return (
      <div 
        ref={adRef} 
        className={`ezoic-ad ${className}`} 
        data-ez-name={adSlot}
        id={`ezoic-pub-ad-placeholder-${adSlot}`}
      ></div>
    );
  }
  
  if (provider === 'carbon') {
    return (
      <div ref={adRef} id="_carbonads_js" className={className}></div>
    );
  }
  
  return null;
};
```

#### AdBanner.tsx

```typescript
// packages/core/src/ui/components/ads/AdBanner.tsx
import React from 'react';
import { AdUnit } from './AdUnit';

export interface AdBannerProps {
  adSlot: string;
  provider: 'adsense' | 'ezoic' | 'media.net' | 'carbon';
  className?: string;
}

export const AdBanner: React.FC<AdBannerProps> = ({ 
  adSlot, 
  provider, 
  className = '' 
}) => {
  return (
    <div className={`ad-banner-container ${className}`}>
      <AdUnit 
        adSlot={adSlot} 
        format="leaderboard" 
        provider={provider} 
        className="w-full mx-auto max-w-[728px] h-[90px] overflow-hidden" 
      />
    </div>
  );
};
```

#### InterstitialAd.tsx

```typescript
// packages/core/src/ui/components/ads/InterstitialAd.tsx
import React, { useState, useEffect } from 'react';
import { AdUnit } from './AdUnit';

export interface InterstitialAdProps {
  adSlot: string;
  provider: 'adsense' | 'ezoic' | 'media.net' | 'carbon';
  onClose?: () => void;
  autoCloseAfter?: number; // in milliseconds
}

export const InterstitialAd: React.FC<InterstitialAdProps> = ({ 
  adSlot, 
  provider, 
  onClose,
  autoCloseAfter = 5000 // Default 5 seconds
}) => {
  const [isVisible, setIsVisible] = useState(true);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false);
      if (onClose) onClose();
    }, autoCloseAfter);
    
    return () => clearTimeout(timer);
  }, [autoCloseAfter, onClose]);
  
  if (!isVisible) return null;
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-4 rounded-lg max-w-md w-full">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-medium">Your file is ready!</h3>
          <button 
            onClick={() => {
              setIsVisible(false);
              if (onClose) onClose();
            }}
            className="text-gray-500 hover:text-gray-700"
          >
            Close
          </button>
        </div>
        
        <AdUnit 
          adSlot={adSlot} 
          format="rectangle" 
          provider={provider} 
          className="w-full h-[250px]" 
        />
        
        <div className="mt-4 text-center">
          <button
            onClick={() => {
              setIsVisible(false);
              if (onClose) onClose();
            }}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Continue to Download
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### Index file to export all components

```typescript
// packages/core/src/ui/components/ads/index.ts
export * from './AdUnit';
export * from './AdBanner';
export * from './InterstitialAd';
```

### Step 3: Create Ad Utility Functions

```typescript
// packages/core/src/utils/ads.ts
export type AdProvider = 'adsense' | 'ezoic' | 'media.net' | 'carbon';

export interface AdConfig {
  enabled: boolean;
  provider: AdProvider;
  clientId: string; // e.g., "ca-pub-XXXXXXXXXXXXXXXX" for AdSense
  slots: Record<string, string>;
  customScript?: string;
}

// Declare global AdSense object
declare global {
  interface Window {
    adsbygoogle: any[];
  }
}

/**
 * Initializes ad scripts based on the provided configuration
 */
export function initializeAds(config: AdConfig): void {
  if (!config.enabled || !import.meta.env.PROD) return;
  
  switch (config.provider) {
    case 'adsense':
      const script = document.createElement('script');
      script.src = `https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${config.clientId}`;
      script.async = true;
      script.crossOrigin = "anonymous";
      document.head.appendChild(script);
      
      // Initialize AdSense
      window.adsbygoogle = window.adsbygoogle || [];
      break;
    
    case 'ezoic':
      if (config.customScript) {
        const ezoicScript = document.createElement('script');
        ezoicScript.innerHTML = config.customScript;
        document.head.appendChild(ezoicScript);
      }
      break;
    
    case 'media.net':
      if (config.customScript) {
        const mediaNetScript = document.createElement('script');
        mediaNetScript.innerHTML = config.customScript;
        document.head.appendChild(mediaNetScript);
      }
      break;
    
    case 'carbon':
      const carbonScript = document.createElement('script');
      carbonScript.src = `//cdn.carbonads.com/carbon.js?serve=${config.clientId}`;
      carbonScript.id = "_carbonads_js";
      carbonScript.async = true;
      
      // Carbon typically needs to be inserted into a specific element
      const carbonContainer = document.getElementById('carbon-container');
      if (carbonContainer) {
        carbonContainer.appendChild(carbonScript);
      } else {
        document.body.appendChild(carbonScript);
      }
      break;
  }
}

/**
 * Creates ads.txt content based on configuration
 */
export function generateAdsTxt(config: AdConfig): string {
  switch (config.provider) {
    case 'adsense':
      // Format: google.com, pub-0000000000000000, DIRECT, f08c47fec0942fa0
      return `google.com, ${config.clientId.replace('ca-pub-', '')}, DIRECT, f08c47fec0942fa0`;
      
    case 'ezoic':
      // Would need Ezoic-specific information
      return `# Ezoic ads.txt content would go here`;
      
    // Add other providers as needed
    
    default:
      return `# Please add the correct ads.txt content for your ad provider`;
  }
}
```

### Step 4: Add Ad Components Export to Core Package

```typescript
// packages/core/src/index.ts
// Re-export everything from the theme system
export * from './ui/themes/base';

// Re-export ad components
export * from './ui/components/ads';
export * from './utils/ads';

// Add other exports as they are created
```

## Variant-Specific Ad Implementation

### Step 5: Create Ad Configuration for HEICFlip Variant

```typescript
// packages/heicflip/src/config/ads.ts
import { AdConfig } from '@flip/core';

export const adConfig: AdConfig = {
  enabled: true,
  provider: 'adsense',
  clientId: 'ca-pub-XXXXXXXXXXXXXXXX', // Replace with your AdSense publisher ID
  slots: {
    header: '1234567890', // Replace with actual ad slot IDs
    sidebar: '0987654321',
    footer: '1122334455',
    postConversion: '5566778899'
  }
};
```

### Step 6: Integrate Ads into the HEICFlip Variant

Update the main entry point to initialize ads:

```typescript
// packages/heicflip/src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { theme } from './config/theme';
import { adConfig } from './config/ads';
import { initializeAds } from '@flip/core';

console.log('Running in HEICFlip mode with configuration:', theme);

// Initialize ads based on configuration
initializeAds(adConfig);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

Add ads to relevant components, for example:

```tsx
// packages/heicflip/src/components/ConversionComplete.tsx
import React from 'react';
import { InterstitialAd } from '@flip/core';
import { adConfig } from '../config/ads';

export const ConversionComplete: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  return (
    <InterstitialAd 
      adSlot={adConfig.slots.postConversion}
      provider={adConfig.provider}
      onClose={onClose}
      autoCloseAfter={10000} // 10 seconds
    />
  );
};
```

### Step 7: Create ads.txt for Each Variant

```typescript
// scripts/generate-ads-txt.js
const fs = require('fs');
const path = require('path');
const { generateAdsTxt } = require('../packages/core/dist/utils/ads');

// Load configurations from each variant
const heicflipConfig = require('../packages/heicflip/src/config/ads');
const jpgflipConfig = require('../packages/jpgflip/src/config/ads');

// Generate ads.txt content
const heicflipAdsTxt = generateAdsTxt(heicflipConfig);
const jpgflipAdsTxt = generateAdsTxt(jpgflipConfig);

// Write to files
fs.writeFileSync(
  path.join(__dirname, '../packages/heicflip/public/ads.txt'),
  heicflipAdsTxt
);

fs.writeFileSync(
  path.join(__dirname, '../packages/jpgflip/public/ads.txt'),
  jpgflipAdsTxt
);

console.log('Generated ads.txt files for all variants');
```

## Testing Ad Implementation

### Step 8: Create Test Mode for Ads

```typescript
// packages/core/src/utils/ads.ts
// Add to the existing file

/**
 * Toggles ad test mode
 * @param enable Whether to enable test mode
 */
export function enableAdTestMode(enable: boolean = true): void {
  if (!import.meta.env.PROD) {
    console.log(`Ad test mode ${enable ? 'enabled' : 'disabled'}`);
    
    // Create a visual indicator for ad placements
    const adContainers = document.querySelectorAll('.ad-container, .ezoic-ad');
    adContainers.forEach(container => {
      const element = container as HTMLElement;
      if (enable) {
        element.style.border = '2px dashed red';
        element.style.background = '#ffeeee';
        element.style.minHeight = '90px';
        element.style.display = 'flex';
        element.style.alignItems = 'center';
        element.style.justifyContent = 'center';
        
        const label = document.createElement('span');
        label.textContent = 'AD PLACEMENT';
        label.style.color = 'red';
        label.style.fontWeight = 'bold';
        
        element.appendChild(label);
      } else {
        element.style.border = '';
        element.style.background = '';
        element.style.minHeight = '';
        
        const label = element.querySelector('span');
        if (label) element.removeChild(label);
      }
    });
  }
}
```

## Privacy and Compliance

### Step 9: Create Cookie Consent Banner Component

```typescript
// packages/core/src/ui/components/CookieConsent.tsx
import React, { useState, useEffect } from 'react';

export interface CookieConsentProps {
  privacyPolicyUrl: string;
  onAccept: () => void;
  onDecline: () => void;
}

export const CookieConsent: React.FC<CookieConsentProps> = ({
  privacyPolicyUrl,
  onAccept,
  onDecline
}) => {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    // Check if user has already made a choice
    const consentGiven = localStorage.getItem('cookie-consent');
    
    if (!consentGiven) {
      setIsVisible(true);
    }
  }, []);
  
  const handleAccept = () => {
    localStorage.setItem('cookie-consent', 'accepted');
    setIsVisible(false);
    onAccept();
  };
  
  const handleDecline = () => {
    localStorage.setItem('cookie-consent', 'declined');
    setIsVisible(false);
    onDecline();
  };
  
  if (!isVisible) return null;
  
  return (
    <div className="fixed bottom-0 left-0 right-0 bg-gray-100 p-4 shadow-md z-50">
      <div className="container mx-auto flex flex-col sm:flex-row items-center justify-between">
        <div className="mb-4 sm:mb-0">
          <p className="text-gray-800">
            We use cookies to improve your experience and show relevant ads. 
            By using our site, you agree to our use of cookies. 
            <a 
              href={privacyPolicyUrl}
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-500 hover:text-blue-700 ml-1"
            >
              Learn more
            </a>
          </p>
        </div>
        <div className="flex space-x-4">
          <button
            onClick={handleDecline}
            className="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400"
          >
            Decline
          </button>
          <button
            onClick={handleAccept}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Accept
          </button>
        </div>
      </div>
    </div>
  );
};
```

### Step 10: Implement Privacy Policy Page for Each Variant

Create a privacy policy template that can be customized for each variant:

```typescript
// packages/heicflip/src/pages/PrivacyPolicy.tsx
import React from 'react';
import { theme } from '../config/theme';

export const PrivacyPolicy: React.FC = () => {
  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <h1 className="text-3xl font-bold mb-6">{theme.siteName} Privacy Policy</h1>
      
      <section className="mb-6">
        <h2 className="text-2xl font-semibold mb-3">Introduction</h2>
        <p className="mb-4">
          This Privacy Policy explains how {theme.siteName} collects, uses, and shares information 
          about you when you use our website at {theme.domain}.
        </p>
      </section>
      
      <section className="mb-6">
        <h2 className="text-2xl font-semibold mb-3">Information We Collect</h2>
        <p className="mb-4">
          We collect information that you provide directly to us, such as when you use our 
          conversion tools, contact us, or sign up for our newsletter.
        </p>
        <p className="mb-4">
          We also automatically collect certain information about your device and how you 
          interact with our website, including:
        </p>
        <ul className="list-disc pl-8 mb-4">
          <li>Log information (such as IP address, browser type, pages visited)</li>
          <li>Device information (such as hardware model, operating system)</li>
          <li>Usage information (such as how you use our conversion tools)</li>
        </ul>
      </section>
      
      <section className="mb-6">
        <h2 className="text-2xl font-semibold mb-3">Cookies and Similar Technologies</h2>
        <p className="mb-4">
          We use cookies and similar technologies to collect information about your browsing 
          activities and to personalize content including ads.
        </p>
      </section>
      
      <section className="mb-6">
        <h2 className="text-2xl font-semibold mb-3">How We Use Information</h2>
        <p className="mb-4">
          We use the information we collect to:
        </p>
        <ul className="list-disc pl-8 mb-4">
          <li>Provide and improve our conversion services</li>
          <li>Communicate with you about our services</li>
          <li>Monitor and analyze usage patterns</li>
          <li>Personalize content and advertisements</li>
          <li>Comply with legal obligations</li>
        </ul>
      </section>
      
      <section className="mb-6">
        <h2 className="text-2xl font-semibold mb-3">Advertising</h2>
        <p className="mb-4">
          We work with third-party advertising companies to show you ads on our website. 
          These companies may use information about your visits to this and other websites 
          to provide advertisements about goods and services that may interest you.
        </p>
        <p className="mb-4">
          We use the following advertising partners:
        </p>
        <ul className="list-disc pl-8 mb-4">
          <li>Google AdSense</li>
          {/* Add other ad networks as applicable */}
        </ul>
      </section>
      
      {/* Additional sections for sharing info, user choices, data retention, etc. */}
      
      <section className="mb-6">
        <h2 className="text-2xl font-semibold mb-3">Contact Us</h2>
        <p className="mb-4">
          If you have any questions about this Privacy Policy, please contact us at:
        </p>
        <p className="mb-4">
          Email: privacy@{theme.domain}
        </p>
      </section>
      
      <p className="text-sm text-gray-500">
        Last updated: April 30, 2025
      </p>
    </div>
  );
};
```

## Summary of Files to Create for Ad Implementation

1. Core package:
   - `packages/core/src/ui/components/ads/AdUnit.tsx`
   - `packages/core/src/ui/components/ads/AdBanner.tsx`
   - `packages/core/src/ui/components/ads/InterstitialAd.tsx`
   - `packages/core/src/ui/components/ads/index.ts`
   - `packages/core/src/ui/components/CookieConsent.tsx`
   - `packages/core/src/utils/ads.ts`

2. For each variant:
   - `packages/{variant}/src/config/ads.ts`
   - `packages/{variant}/public/ads.txt`
   - `packages/{variant}/src/pages/PrivacyPolicy.tsx`

3. Script files:
   - `scripts/generate-ads-txt.js`

---

Last updated: April 30, 2025```

---

## Tool & Script Documentation

### BACKUP_README.md

**Path:** formatflip_complete/scripts/BACKUP_README.md

```markdown
# HEICFlip Backup System

This directory contains scripts for creating, managing, and restoring backups of the HEICFlip project.

## Available Scripts

### 1. Create a Backup

```bash
./scripts/create_backup.sh
```

This script will create a backup of critical project files in the `backups/` directory. Each backup is stored in a timestamped folder (e.g., `backups/backup_20250501_155018`).

The backup includes:
- Configuration files (drizzle.config.ts, postcss.config.js, tailwind.config.ts, etc.)
- Server files
- Shared files
- Enhanced variant generator scripts
- Client files (if they exist)
- Demo HTML files

### 2. List Available Backups

```bash
./scripts/list_backups.sh
```

This script displays all available backups in reverse chronological order (newest first), showing:
- Backup directory path
- Creation date and time
- Number of files in the backup
- Summary information

### 3. Restore from a Backup

```bash
./scripts/restore_backup.sh backups/backup_YYYYMMDD_HHMMSS
```

This script restores files from a specified backup. It will prompt for confirmation before proceeding, as this action will overwrite existing files.

To view available backups to restore from, run the `list_backups.sh` script or omit the backup directory parameter:

```bash
./scripts/restore_backup.sh
```

## Important Notes

- Backups are stored in the `backups/` directory within the project
- After restoring from a backup, you may need to restart the application for changes to take effect
- These backup scripts focus on code and configuration files, not database content
- For complete project backup, consider also backing up any database content separately
```

---

### LOADERS_AND_ENCODERS.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/LOADERS_AND_ENCODERS.md

```markdown
# Loaders and Encoders System

## Overview

The Loaders and Encoders system is a Python PIL-inspired approach for handling various file formats with automatic format detection and conversion capabilities. This system is designed to be flexible, extensible, and maintainable.

## Core Concepts

### Format Registry

The Format Registry is the central component that manages all supported file formats and their associated metadata. It provides a lookup mechanism for:

- Identifying formats by file extension
- Automatic format detection from filenames
- Finding appropriate converters between formats

### Formats and Conversions

Formats are registered with minimal configuration, similar to how Python's PIL works:

```typescript
registerFormat('heic', {
  name: 'HEIC Image',
  ext: '.heic',
  mime: 'image/heic',
  variations: ['HEIC', 'heic', 'Heic'],
  description: 'High Efficiency Image Container'
});
```

Conversions between formats can be registered manually or created dynamically:

```typescript
// Manually register a conversion
registerConversion('heicToJpg', {
  name: 'HEIC to JPG',
  source: 'heic',
  target: 'jpg',
  namingVariations: [...],
  description: 'Convert HEIC images to JPG format'
});

// Or dynamically create a conversion
const conversionKey = createConverter('heic', 'jpg');
```

## Key Features

### Automatic Format Detection

The system can automatically detect the format of a file based on its extension:

```typescript
const formatKey = identifyFormat('vacation_photo.heic');
// Returns 'heic'
```

### Dynamic Conversion Creation

Conversions between formats can be created on demand:

```typescript
// Create a conversion from HEIC to WEBP
const heicToWebpKey = createConverter('heic', 'webp');
```

### Code Generation Utilities

Utilities for generating registration code make it easy to add new formats:

```typescript
const codeSnippet = generateFormatCode(
  'avif',
  'AVIF Image',
  '.avif',
  'image/avif',
  ['AVIF', 'avif', 'Avif']
);

// Returns TypeScript code to register the format
```

## Implementation Details

### Extension Lists

Format entries can have multiple extensions to support variations:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],  // Supports both extensions
  mime: 'image/jpeg',
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

### MIME Type Lists

Formats can have multiple MIME types:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],
  mime: ['image/jpeg', 'image/jpg'],  // Multiple MIME types
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

## Usage Example

A complete workflow for format identification and conversion:

```typescript
// Identify the format of a file
const sourceFormatKey = identifyFormat('photo.heic');

// Find or create a conversion to the target format
const targetFormatKey = 'jpg';
const conversionKey = createConverter(sourceFormatKey, targetFormatKey);

// In a real implementation:
// 1. Load the source file using the source format's handler
// 2. Process the image data
// 3. Save using the target format's handler
const outputFilename = 'photo.jpg';
```

## Extending The System

### Adding a New Format

To add support for a new file format:

1. Register the format with its metadata
2. Create converters to/from existing formats as needed

### Creating Custom Loaders/Encoders

In a full implementation:

1. Create the loader (decoder) module for your format
2. Create the encoder (saver) module for your format
3. Register the format with references to these modules

## Benefits Over the Previous Approach

- **Simplified Architecture**: Reduces complexity by focusing on formats rather than transformations
- **Automatic Detection**: Format detection works out of the box based on file extensions
- **Dynamic Conversions**: Conversions can be created on demand rather than pre-defined
- **Extensibility**: New formats can be added without modifying existing code
- **Maintainability**: Clearer separation of concerns between format definitions and processing logic
```

---

### TRANSFORMER_COMPARISON.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/TRANSFORMER_COMPARISON.md

```markdown
# AST vs Text-Based Transformer Comparison

This document summarizes the key differences between AST-based and text-based code transformation approaches in the HEICFlip variant generator.

## Overview

The transformer system supports two modes of operation:

1. **AST-based transformation**: Uses Babel's Abstract Syntax Tree parsing to understand code structure
2. **Text-based transformation**: Uses regex-based string replacement for simpler but less precise transformations

## Comparative Analysis

| Aspect | AST-Based Transformer | Text-Based Transformer |
|--------|----------------------|------------------------|
| **Transformation Rate** | ~56% (more selective) | ~100% (more comprehensive) |
| **Context Preservation** | High | Low |
| **Parameter Handling** | Preserves parameter names | May transform parameter names incorrectly |
| **String Replacement** | Only in string contexts | In all contexts |
| **Template Literals** | Limited handling | Full replacement |
| **Error Handling** | May fail on complex syntax | More resilient to syntax errors |
| **Performance** | Slower (parsing overhead) | Faster (direct replacement) |

## Specific Strengths

### AST-Based Transformer

✓ **Context-aware**: Understands code structure and only transforms appropriate elements
✓ **Scope-sensitive**: Preserves variables in parameter scope 
✓ **Structure-preserving**: Maintains code structure and formatting
✓ **Selective transformation**: Avoids incorrect transformations in sensitive contexts

### Text-Based Transformer

✓ **Comprehensive**: Transforms all occurrences of target strings
✓ **Resilient**: Works even with invalid or complex code structures
✓ **Fast**: No parsing overhead
✓ **Template handling**: Better at transforming template literal content

## Current Limitations

### AST-Based Transformer

- Limited transformation of template literals
- Doesn't transform some object properties consistently
- May fail to parse some complex syntax patterns
- Error code strings are sometimes incorrectly transformed

### Text-Based Transformer

- Transforms parameter names inappropriately
- Doesn't respect variable scoping
- Context-insensitive replacements can cause errors
- May transform reserved words or constants that should be preserved

## When to Use Each Approach

- **AST-based transformer**: For production-quality transformations where context preservation is critical
- **Text-based transformer**: For quick prototyping or when AST parsing fails

## Hybrid Approach Benefits

The system uses a hybrid approach that:

1. Attempts AST-based transformation first for precision
2. Falls back to text-based transformation if parsing fails
3. Provides detailed statistics about the transformation process

This approach combines the context-awareness of AST with the resilience of text-based replacement.

## Test Results

Test results consistently show that:

- AST transformation preserves ~8-14 HEIC/JPG occurrences in appropriate contexts
- Text transformation replaces all HEIC/JPG occurrences regardless of context
- Both approaches successfully transform most format references
- AST excels at context preservation, text excels at comprehensive replacement

## Recommendation

For most use cases, the hybrid approach provides the best balance of precision and completeness. Users can explicitly set the transformer mode based on their specific needs.```

---

### README.md

**Path:** formatflip_complete/scripts/enhanced-variant-generator/README.md

```markdown
# HEICFlip Format Transformation System

## Overview

The Format Transformation System is a sophisticated architecture for working with different file formats, enabling loading, transforming, and saving files with a consistent interface. Inspired by the Python Imaging Library (PIL), this system allows for seamless conversion between formats while also supporting visual identity transformations for different variant sites.

## Key Features

1. **Format Detection**: Automatic detection of file formats based on extensions
2. **Open/Save Architecture**: PIL-inspired approach to loading and saving files
3. **Visual Identity**: Consistent theming system for different formats
4. **Dynamic Registration**: Runtime registration of new formats and converters
5. **Variant Generation**: Ability to transform between different format pairs
6. **Theming Transformation**: Automatic adjustment of visual identities when switching variants

## System Architecture

The system is organized into several layers:

### Registry Layer

- **Format Registry**: Centralized storage of all format definitions and converters
- **Visual Identity Registry**: Stores visual styling elements for each format and conversion
- **Format Manager**: Manages the registration and retrieval of formats and converters

### Loader Layer

- **BaseLoader**: Abstract class implementing common functionality for all loaders
- **ILoader Interface**: Defines the contract for format loaders
- **Format-Specific Loaders**: Concrete implementations for each supported format (HEIC, JPEG, etc.)

### Transformer Layer

- **Internal Representation**: Common data structure for representing loaded files
- **Color Transformation**: Utilities for adjusting visual identities
- **Format Adaptation**: Adjustments needed for specific format conversions

### Encoder Layer

- **BaseEncoder**: Abstract class implementing common functionality for all encoders
- **IEncoder Interface**: Defines the contract for format encoders
- **Format-Specific Encoders**: Concrete implementations for each supported format

### Output Layer

- **File Output**: Mechanisms for saving to files
- **Blob Output**: Utilities for creating blobs and handling downloads

## Format Registry

The Format Registry is the central hub for managing supported formats and conversions:

```typescript
export interface Format {
  key: string;         // Unique identifier (e.g., 'heic')
  name: string;        // Display name (e.g., 'HEIC')
  extensions: string[]; // File extensions (e.g., ['.heic', '.heif'])
  mimeTypes: string[]; // MIME types (e.g., ['image/heic'])
  description: string; // Human-readable description
  loader?: any;        // Reference to loader implementation
  encoder?: any;       // Reference to encoder implementation
}

export interface Converter {
  key: string;         // Unique identifier (e.g., 'heicToJpg')
  source: string;      // Source format key
  target: string;      // Target format key
  name: string;        // Display name
  description: string; // Human-readable description
  strategies: string[]; // Available conversion strategies
  defaultStrategy: string; // Default strategy to use
}
```

## Visual Identity System

Each format and conversion has an associated visual identity:

```typescript
export interface FormatVisualIdentity {
  formatKey: string;       // Format this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for format-specific elements
  iconShape: 'circle' | 'square' | 'rounded' | 'diamond'; // Icon shape
}

export interface ConversionVisualIdentity {
  conversionKey: string;   // Conversion this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for conversion-specific elements
  gradient: string;        // Gradient using source and target colors
}
```

## Loader and Encoder System

The system uses a loader/encoder architecture for handling different formats:

### Loaders

Loaders are responsible for decoding file formats into an internal representation:

```typescript
export interface ILoader {
  supportedFormats: string[];
  load(source: any, options?: any): Promise<any>;
  canLoad(source: any): boolean;
  getInfo?(source: any): Promise<any>;
}
```

### Encoders

Encoders are responsible for encoding the internal representation into a specific file format:

```typescript
export interface IEncoder {
  supportedFormats: string[];
  encode(data: any, options?: any): Promise<any>;
  defaultOptions: Record<string, any>;
}
```

## Format Manager

The Format Manager provides a high-level API for working with formats and conversions:

```typescript
export class FormatManager {
  // Load a file from a source
  async open(source: any, formatHint?: string): Promise<any>;
  
  // Save data to a specific format
  async save(data: any, format: string, options?: any): Promise<any>;
  
  // Convert data from one format to another
  async convert(source: any, targetFormat: string, options?: any): Promise<any>;
  
  // Register a loader for a format
  registerLoader(formatKey: string, loader: any): void;
  
  // Register an encoder for a format
  registerEncoder(formatKey: string, encoder: any): void;
}
```

## Variant Generation

The Variant Generation system allows for transforming sites between different format pairs:

```typescript
interface TransformationConfig {
  sourceSourceFormat: string;  // Current source format (e.g., 'heic')
  sourceTargetFormat: string;  // Current target format (e.g., 'jpg')
  targetSourceFormat: string;  // New source format (e.g., 'png')
  targetTargetFormat: string;  // New target format (e.g., 'webp')
  inputDir: string;           // Directory containing the original site
  outputDir: string;          // Directory to write the transformed site
}

export async function transformSite(config: TransformationConfig): Promise<void>;
```

This process includes:

1. Identifying color transformations between formats
2. Updating CSS variables and selectors
3. Replacing format names in text content
4. Updating visual assets to match the new formats

## Usage Example

```typescript
// Detect format from file extension
const format = detectFormatFromExtension('image.heic'); // Returns 'heic'

// Load a HEIC file
const imageData = await formatManager.open('image.heic');

// Save as JPEG
const jpegBlob = await formatManager.save(imageData, 'jpg', { quality: 90 });

// Direct conversion
const jpegBlob = await formatManager.convert('image.heic', 'jpg', { quality: 90 });

// Transform a site from HEIC→JPG to WebP→PNG
const config = {
  sourceSourceFormat: 'heic',
  sourceTargetFormat: 'jpg',
  targetSourceFormat: 'webp',
  targetTargetFormat: 'png',
  inputDir: './original-site',
  outputDir: './transformed-site'
};
await transformSite(config);
```

## Visual Identity Transformation

The system enables transformation between different format pairs, including visual identity changes:

- **HEIC** (Orange) ↔ **JPG** (Blue)
- **HEIC** (Orange) ↔ **WebP** (Purple)
- **WebP** (Purple) ↔ **PNG** (Green)
- **AVI** (Red) ↔ **MP4** (Teal)

This allows for generating different variants of the same site with consistent branding for each format pair.

## Extending the System

To add support for a new format:

1. Add the format definition to the registry
2. Create a loader implementation
3. Create an encoder implementation
4. Add visual identity for the format
5. Register with the format manager

```typescript
// Add format to registry
registry.formats.avif = {
  key: 'avif',
  name: 'AVIF',
  extensions: ['.avif'],
  mimeTypes: ['image/avif'],
  description: 'AV1 Image File Format with excellent compression',
};

// Create and register loader
const avifLoader = new AvifLoader();
formatManager.registerLoader('avif', avifLoader);

// Create and register encoder
const avifEncoder = new AvifEncoder();
formatManager.registerEncoder('avif', avifEncoder);

// Add visual identity
visualIdentityRegistry.formats.avif = {
  formatKey: 'avif',
  primaryColor: '#6A5ACD', // Slate blue
  secondaryColor: '#5A4ABD',
  accentColor: '#8A7AED',
  cssPrefix: 'avif',
  dataAttribute: 'data-format-avif',
  iconShape: 'diamond',
};
```

## Conclusion

The Format Transformation System provides a robust and extensible framework for working with different file formats and creating variant sites. By using a consistent loader/encoder architecture and a well-defined visual identity system, it enables seamless transformation between different format pairs while maintaining consistent branding and styling.```

---

### README.md

**Path:** deploy_tools/README.md

```markdown
# Deployment Guide for FlipMyFile

## Recent Changes Summary

1. **Rebranding from HEICFlip to FlipMyFile**
   - Updated page titles and headers
   - Updated meta descriptions

2. **Document Format Support**
   - Added UI for document format conversion (DOC, PDF, PPT, XLS, etc.)
   - Implemented custom icons for different file types
   - Added format selection buttons that appear after file upload

3. **Auto-detection improvements**
   - Enhanced format detection for document files
   - Updated format options based on file type

## Deployment Instructions

### Method 1: Using the deploy script

1. Pull the latest changes from Replit to your local repository
2. Navigate to the project directory
3. Run the deploy script:
   ```bash
   bash deploy_tools/deploy.sh
   ```

### Method 2: Manual deployment

1. Pull the latest changes from Replit to your local repository
2. Stage the changes:
   ```bash
   git add .
   ```
3. Commit the changes:
   ```bash
   git commit -m "Update FlipMyFile with document format support"
   ```
4. Push to GitHub:
   ```bash
   git push origin main
   ```

## Important Notes

- The document format conversion UI is implemented, but the actual conversion functionality is not yet active
- The format detection works automatically based on file extension
- Custom icons are implemented for different document formats

## Next Steps

- Implement actual document format conversion using FFmpeg or other appropriate libraries
- Add support for more document formats
- Create format-specific landing pages for SEO optimization
```

---

### README.md

**Path:** meta/tools/README.md

```markdown
# HEICFlip Project Tools Directory

This directory contains all utility scripts and tools for the HEICFlip project, organized by purpose and function.

## Directory Structure

```
meta/tools/
├── github/         # GitHub version control and deployment scripts
├── backup/         # Backup and restore system scripts
├── deployment/     # Deployment and release management scripts
├── project/        # Project management and renaming scripts
├── maintenance/    # Code maintenance and cleanup scripts 
└── dev/            # Development utility scripts
```

## Organization Rules

All scripts must follow these organization rules:

1. **Categorization**: Place each script in the most appropriate subdirectory based on its primary purpose
2. **Naming Convention**: All scripts should follow the `[HEICFLIP-XXX]_descriptive_name.sh` format
3. **Numbering Scheme**:
   - Scripts in `github/`: 200-299
   - Scripts in `backup/`: 900-999
   - Scripts in `deployment/`: 700-799
   - Scripts in `project/`: 000-099
   - Scripts in `maintenance/`: 500-599
   - Scripts in `dev/`: 300-399
4. **Documentation**: Each script must include a header comment explaining its purpose and usage
5. **Permissions**: All scripts must have execute permissions (`chmod +x`)

## File List by Directory

### GitHub Scripts (`github/`)

GitHub-related scripts for version control, pushing changes, and repository management:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-200]_github_helper.sh` | Core GitHub helper functions |
| `[HEICFLIP-201]_push_to_github.sh` | Push current changes to GitHub |
| `[HEICFLIP-202]_push_clean_to_github.sh` | Push a clean version to GitHub |
| `[HEICFLIP-210]_push_heicflip_to_github.sh` | Push HEICFlip-specific changes |
| `[HEICFLIP-211]_push_jpgflip_to_github.sh` | Push JPGFlip-specific changes |
| `[HEICFLIP-220]_git_reset_push.sh` | Reset and push fresh changes |

### Backup Scripts (`backup/`)

Scripts for creating and restoring backups of the project state:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-910]_save_version.sh` | Save current project state |
| `[HEICFLIP-911]_restore_version.sh` | Restore from saved project state |

### Project Scripts (`project/`)

Scripts for project setup, configuration, and management:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-010]_project_rename.sh` | Rename project across all files |
| `[HEICFLIP-020]_prepare_heicflip.sh` | Prepare HEICFlip configuration |

### Maintenance Scripts (`maintenance/`)

Scripts for code maintenance, cleanup, and health checks:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-500]_push_css_fix.sh` | Fix and update CSS |
| `[HEICFLIP-510]_push_better.sh` | Apply optimizations and improvements |
| `[HEICFLIP-520]_push_title_updates.sh` | Update titles and metadata |

### Deployment Scripts (`deployment/`)

Scripts for deployment and release management:

| Script | Purpose |
|--------|---------|
| `[HEICFLIP-700]_push_client_to_github.sh` | Deploy client changes |
| `[HEICFLIP-710]_push_complete_heicflip.sh` | Deploy complete application |
| `[HEICFLIP-720]_push_current_to_github.sh` | Deploy current working version |

## Usage Guidelines

1. **Running Scripts**: Scripts should be run from the project root directory
2. **Script Creation**: When creating a new script, use the appropriate directory and number prefix
3. **Maintenance**: Keep this README updated when adding or modifying scripts

For any script that needs to be easily accessible from the project root, create a proxy script that calls the actual script from its organized location.

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/project/README.md

```markdown
# Project Management Scripts

This directory contains scripts for managing the HEICFlip project's configuration, setup, and maintenance.

## Purpose

These scripts provide tools for:
- Project renaming and rebranding
- Configuration management
- Setting up development environments

## Scripts Overview

### Core Project Scripts

- `[HEICFLIP-010]_project_rename.sh`: Comprehensive script for renaming the project across all files
- `[HEICFLIP-020]_prepare_heicflip.sh`: Script to prepare and configure the HEICFlip environment

## Project Rename System

The project rename script provides comprehensive renaming capabilities:

1. Allows changing the project name across all files (e.g., "HEICFlip" to "ImageConverter")
2. Updates file names, contents, directory names, and configuration files
3. Preserves the functionality while updating the branding
4. Includes safety checks to prevent accidental changes

### When to Use Project Rename

Use the rename script when:
- Forking the project for a different purpose
- White-labeling the application
- Creating a specialized version with different branding

## Usage Guidelines

1. Before running rename scripts:
   - Create a backup using the backup system
   - Review the changes that will be made
   - Ensure the new name follows naming conventions

2. After renaming:
   - Verify all functionality still works
   - Update documentation to reflect the new name
   - Commit the changes to version control

## Adding New Scripts

When adding new project management scripts:

1. Follow the numbering convention (000-099)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

For detailed instructions on renaming the project, see:
`meta/docs/[HEICFLIP-050]_NAME_CHANGE_GUIDE.md`

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/github/README.md

```markdown
# GitHub Scripts

This directory contains all scripts related to GitHub operations, version control, and repository management for the HEICFlip project.

## Purpose

These scripts handle various GitHub operations including:
- Pushing changes to GitHub repositories
- Managing different project configurations (HEICFlip vs JPGFlip)
- Cleaning and preparing repositories for deployment
- Handling Git reset and branch management

## Scripts Organization

All GitHub scripts follow the `[HEICFLIP-2XX]` numbering convention for clear identification:

| Number Range | Purpose |
|--------------|---------|
| 200-209 | Core GitHub utility scripts |
| 210-219 | Project-specific push scripts |
| 220-229 | Git operations and maintenance |
| 230-239 | Branch management |
| 240-249 | CI/CD pipeline scripts |

## Scripts Inventory

### Core GitHub Scripts (200-209)

- `[HEICFLIP-200]_github_helper.sh`: Core utility functions used by other GitHub scripts
- `[HEICFLIP-201]_push_to_github.sh`: Main script for pushing changes to GitHub
- `[HEICFLIP-202]_push_to_github_clean.sh`: Push a clean version with temporary files removed

### Project-Specific Push Scripts (210-219)

- `[HEICFLIP-210]_push_heicflip_to_github.sh`: Push HEICFlip-specific configurations
- `[HEICFLIP-211]_push_jpgflip_to_github.sh`: Push JPGFlip-specific configurations
- `[HEICFLIP-212]_push_client_to_github.sh`: Push client-side changes only
- `[HEICFLIP-213]_push_heicflip_changes.sh`: Push HEICFlip specific changes
- `[HEICFLIP-214]_push_heicflip_changes_fixed.sh`: Push HEICFlip changes with fixes

### Git Operations (220-229)

- `[HEICFLIP-220]_git_reset_push.sh`: Reset local repository and push fresh changes
- `[HEICFLIP-221]_push_current_to_github.sh`: Push current working version

### Component-Specific Scripts (230-239)

- `[HEICFLIP-230]_push_css_fix.sh`: Push CSS-specific fixes
- `[HEICFLIP-231]_push_title_updates.sh`: Push title and metadata updates
- `[HEICFLIP-232]_push_complete_heicflip.sh`: Push complete HEICFlip application
- `[HEICFLIP-233]_push_better.sh`: Push optimized version

## Script Documentation

Each script includes a standard header:

```bash
#!/bin/bash
#
# [HEICFLIP-2XX] Script Name
#
# Purpose: Brief description of what this script does
#
# Usage: ./meta/tools/github/[HEICFLIP-2XX]_script_name.sh [options]
#
# Options:
#   -h, --help     Display this help message
#   -v, --verbose  Display detailed output during execution
#
# Author: Your Name
# Date: Creation/Last Update Date
```

## Usage Guidelines

1. All scripts should be run from the project root directory
2. Scripts follow the numbering convention `[HEICFLIP-2XX]` for GitHub operations
3. Scripts that need to update specific parts of the codebase should be named descriptively

## Adding New Scripts

When adding a new GitHub-related script:

1. Follow the numbering convention (200-299)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/deployment/README.md

```markdown
# Deployment Scripts

This directory contains scripts for deployment, release management, and publishing for the HEICFlip project.

## Purpose

These scripts handle various deployment operations including:
- Publishing to hosting platforms
- Managing release versions
- Configuring deployment environments
- Preparing distribution packages

## Scripts Organization

All deployment scripts follow the `[HEICFLIP-7XX]` numbering convention for clear identification:

| Number Range | Purpose |
|--------------|---------|
| 700-709 | Core deployment utility scripts |
| 710-719 | Environment-specific deployment |
| 720-729 | Release management |
| 730-739 | Distribution packaging |
| 740-749 | Post-deployment verification |

## Scripts Inventory

### Core Deployment Scripts (700-709)

- `[HEICFLIP-700]_deploy_helper.sh`: Core utility functions used by other deployment scripts

### Environment Deployment Scripts (710-719)

- `[HEICFLIP-710]_deploy_production.sh`: Deploy to production environment
- `[HEICFLIP-711]_deploy_staging.sh`: Deploy to staging environment

### Release Management (720-729)

- `[HEICFLIP-720]_create_release.sh`: Create a new release with proper versioning
- `[HEICFLIP-721]_tag_release.sh`: Tag a release in Git

### Distribution Packaging (730-739)

- `[HEICFLIP-730]_package_distribution.sh`: Create distribution packages
- `[HEICFLIP-731]_create_artifacts.sh`: Generate deployment artifacts

## Script Documentation

Each script includes a standard header:

```bash
#!/bin/bash
#
# [HEICFLIP-7XX] Script Name
#
# Purpose: Brief description of what this script does
#
# Usage: ./meta/tools/deployment/[HEICFLIP-7XX]_script_name.sh [options]
#
# Options:
#   -h, --help     Display this help message
#   -v, --verbose  Display detailed output during execution
#   -e, --env      Specify deployment environment
#
# Author: Your Name
# Date: Creation/Last Update Date
```

## Usage Guidelines

1. All scripts should be run from the project root directory
2. Scripts follow the numbering convention `[HEICFLIP-7XX]` for deployment operations
3. When deploying to production, always test on staging first
4. Create backup points before deployment operations

## Adding New Scripts

When adding a new deployment-related script:

1. Follow the numbering convention (700-799)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/maintenance/README.md

```markdown
# Maintenance Scripts

This directory contains scripts for code maintenance, cleanup, and health checks for the HEICFlip project.

## Purpose

These scripts provide tools for:
- Code quality improvements
- CSS and styling fixes
- Performance optimizations
- Content and text updates

## Scripts Overview

### Styling and UI Maintenance

- `[HEICFLIP-500]_push_css_fix.sh`: Fixes and updates CSS styles across the application
- `[HEICFLIP-520]_push_title_updates.sh`: Updates titles and metadata throughout the project

### Performance and Optimization

- `[HEICFLIP-510]_push_better.sh`: Applies various optimizations and improvements to the codebase

## Usage Guidelines

1. Before running maintenance scripts:
   - Create a backup using the backup system
   - Run tests to establish a baseline
   - Understand what changes the script will make

2. After running maintenance scripts:
   - Verify all functionality still works
   - Test performance if relevant
   - Commit the changes to version control

## Script Naming Conventions

Maintenance scripts should follow these naming patterns:

- CSS/styling scripts: `[HEICFLIP-50X]_push_css_*.sh`
- Performance scripts: `[HEICFLIP-51X]_push_performance_*.sh`
- Content scripts: `[HEICFLIP-52X]_push_content_*.sh`
- Code quality scripts: `[HEICFLIP-53X]_push_quality_*.sh`
- Test scripts: `[HEICFLIP-54X]_push_test_*.sh`

## Adding New Scripts

When adding new maintenance scripts:

1. Follow the numbering convention (500-599)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

Last Updated: April 30, 2025```

---

### README.md

**Path:** meta/tools/backup/README.md

```markdown
# Backup System Scripts

This directory contains scripts for the HEICFlip project's backup and restore system.

## Purpose

These scripts provide a safety net during development by:
- Creating snapshots of the project at critical points
- Enabling restoration to previous known-good states
- Preserving work when testing risky changes

## Scripts Overview

### Core Backup Scripts

- `[HEICFLIP-910]_save_version.sh`: Save the current project state to a restore point
- `[HEICFLIP-911]_restore_version.sh`: Restore the project from a saved restore point

## How The Backup System Works

### Save Process

The save script:
1. Creates a `/restore_point` directory (or clears it if it exists)
2. Copies all essential project files (code, config, docs)
3. Saves a timestamp for reference
4. Reports the number of files backed up

### Restore Process

The restore script:
1. Checks if a restore point exists
2. Makes a temporary backup of the current state as a safeguard
3. Copies all files from the restore point back to their original locations
4. Reports completion and includes recovery instructions

## Usage Guidelines

1. Create backups:
   - Before making significant changes
   - After completing important features
   - When the project is in a known good state

2. Restoring backups:
   - When changes introduce unexpected problems
   - To compare current work with previous versions
   - To recover from failed experiments

## Adding New Scripts

When adding new backup-related scripts:

1. Follow the numbering convention (900-999)
2. Include comprehensive header documentation
3. Update this README with the new script information
4. Ensure the script has executable permissions (`chmod +x`)

For comprehensive documentation on the backup system, see:
`meta/docs/backup-system/[HEICFLIP-900]_BACKUP_SYSTEM.md`

Last Updated: April 30, 2025```

---

### github_summary.md

**Path:** github_tools/github_summary.md

```markdown
# FormatFlip GitHub Repository Summary

## Overview

This document summarizes the FormatFlip GitHub repository structure, components, and integration strategy. FormatFlip is a web application that allows users to convert between multiple file formats, including images, videos, and audio files, using FFmpeg WASM for client-side processing.

## Repository Structure

```
FormatFlip/
├── .github/              # GitHub-specific files
│   ├── workflows/        # CI/CD workflows
│   │   └── ci.yml        # Continuous integration workflow
│   └── PULL_REQUEST_TEMPLATE.md  # PR template
├── client/               # Frontend code
│   ├── public/           # Static assets
│   └── src/              # React source files
├── server/               # Backend API code
│   ├── db.ts             # Database connection
│   ├── index.ts          # Server entry point
│   ├── routes.ts         # API routes
│   ├── storage.ts        # Storage interface
│   └── vite.ts           # Vite configuration
├── shared/               # Shared code between client and server
│   └── schema.ts         # Database schema and types
├── scripts/              # Utility scripts
├── packages/             # Monorepo packages
├── meta/                 # Documentation and metadata
├── format-transformation-demo.html  # Format conversion demo
├── push_to_formatflip.sh  # GitHub API push script
├── push_to_github.sh     # Enhanced GitHub push script
├── .gitignore           # Git ignore file
├── drizzle.config.ts    # Drizzle ORM configuration
├── package.json         # Project dependencies
├── tsconfig.json        # TypeScript configuration
├── vercel.json          # Vercel deployment configuration
└── vite.config.ts       # Vite build configuration
```

## Key Components

### Database Schema

The application uses a PostgreSQL database with the following main entities:

- **Users**: Store user information and authentication details
- **Conversions**: Track file conversion history and metadata
- **ConversionSettings**: Store user preferences for conversions

### GitHub Integration

Due to Replit's restrictions on direct Git operations, we've implemented a custom GitHub API-based approach for repository management:

1. **Creation Scripts**: Create necessary directory structure
2. **Push Scripts**: Upload individual files with proper version tracking
3. **Update Scripts**: Handle updating existing files with proper SHA tracking

### CI/CD Workflow

The repository includes a GitHub Actions workflow that:

1. Builds the application
2. Runs linting checks
3. Executes tests

### Deployment

The application is configured for deployment on Vercel with:

- Node.js server for the backend API
- Static serving for frontend assets
- Environment variable configuration

## Development Workflow

1. Make changes in the Replit environment
2. Run tests and verify locally
3. Use `push_to_github.sh` to upload changed files
4. GitHub Actions validates the changes
5. Vercel automatically deploys from the main branch

## Future Improvements

- Implement more comprehensive test suite
- Add database migration scripts
- Enhance CI pipeline with additional checks
- Configure multi-environment deployments
```

---

### BACKUP_README.md

**Path:** scripts/BACKUP_README.md

```markdown
# HEICFlip Backup System

This directory contains scripts for creating, managing, and restoring backups of the HEICFlip project.

## Available Scripts

### 1. Create a Backup

```bash
./scripts/create_backup.sh
```

This script will create a backup of critical project files in the `backups/` directory. Each backup is stored in a timestamped folder (e.g., `backups/backup_20250501_155018`).

The backup includes:
- Configuration files (drizzle.config.ts, postcss.config.js, tailwind.config.ts, etc.)
- Server files
- Shared files
- Enhanced variant generator scripts
- Client files (if they exist)
- Demo HTML files

### 2. List Available Backups

```bash
./scripts/list_backups.sh
```

This script displays all available backups in reverse chronological order (newest first), showing:
- Backup directory path
- Creation date and time
- Number of files in the backup
- Summary information

### 3. Restore from a Backup

```bash
./scripts/restore_backup.sh backups/backup_YYYYMMDD_HHMMSS
```

This script restores files from a specified backup. It will prompt for confirmation before proceeding, as this action will overwrite existing files.

To view available backups to restore from, run the `list_backups.sh` script or omit the backup directory parameter:

```bash
./scripts/restore_backup.sh
```

## Important Notes

- Backups are stored in the `backups/` directory within the project
- After restoring from a backup, you may need to restart the application for changes to take effect
- These backup scripts focus on code and configuration files, not database content
- For complete project backup, consider also backing up any database content separately
```

---

### LOADERS_AND_ENCODERS.md

**Path:** scripts/deployment/enhanced-variant-generator/LOADERS_AND_ENCODERS.md

```markdown
# Loaders and Encoders System

## Overview

The Loaders and Encoders system is a Python PIL-inspired approach for handling various file formats with automatic format detection and conversion capabilities. This system is designed to be flexible, extensible, and maintainable.

## Core Concepts

### Format Registry

The Format Registry is the central component that manages all supported file formats and their associated metadata. It provides a lookup mechanism for:

- Identifying formats by file extension
- Automatic format detection from filenames
- Finding appropriate converters between formats

### Formats and Conversions

Formats are registered with minimal configuration, similar to how Python's PIL works:

```typescript
registerFormat('heic', {
  name: 'HEIC Image',
  ext: '.heic',
  mime: 'image/heic',
  variations: ['HEIC', 'heic', 'Heic'],
  description: 'High Efficiency Image Container'
});
```

Conversions between formats can be registered manually or created dynamically:

```typescript
// Manually register a conversion
registerConversion('heicToJpg', {
  name: 'HEIC to JPG',
  source: 'heic',
  target: 'jpg',
  namingVariations: [...],
  description: 'Convert HEIC images to JPG format'
});

// Or dynamically create a conversion
const conversionKey = createConverter('heic', 'jpg');
```

## Key Features

### Automatic Format Detection

The system can automatically detect the format of a file based on its extension:

```typescript
const formatKey = identifyFormat('vacation_photo.heic');
// Returns 'heic'
```

### Dynamic Conversion Creation

Conversions between formats can be created on demand:

```typescript
// Create a conversion from HEIC to WEBP
const heicToWebpKey = createConverter('heic', 'webp');
```

### Code Generation Utilities

Utilities for generating registration code make it easy to add new formats:

```typescript
const codeSnippet = generateFormatCode(
  'avif',
  'AVIF Image',
  '.avif',
  'image/avif',
  ['AVIF', 'avif', 'Avif']
);

// Returns TypeScript code to register the format
```

## Implementation Details

### Extension Lists

Format entries can have multiple extensions to support variations:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],  // Supports both extensions
  mime: 'image/jpeg',
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

### MIME Type Lists

Formats can have multiple MIME types:

```typescript
registerFormat('jpg', {
  name: 'JPEG Image',
  ext: ['.jpg', '.jpeg'],
  mime: ['image/jpeg', 'image/jpg'],  // Multiple MIME types
  variations: ['JPG', 'jpg', 'JPEG', 'jpeg']
});
```

## Usage Example

A complete workflow for format identification and conversion:

```typescript
// Identify the format of a file
const sourceFormatKey = identifyFormat('photo.heic');

// Find or create a conversion to the target format
const targetFormatKey = 'jpg';
const conversionKey = createConverter(sourceFormatKey, targetFormatKey);

// In a real implementation:
// 1. Load the source file using the source format's handler
// 2. Process the image data
// 3. Save using the target format's handler
const outputFilename = 'photo.jpg';
```

## Extending The System

### Adding a New Format

To add support for a new file format:

1. Register the format with its metadata
2. Create converters to/from existing formats as needed

### Creating Custom Loaders/Encoders

In a full implementation:

1. Create the loader (decoder) module for your format
2. Create the encoder (saver) module for your format
3. Register the format with references to these modules

## Benefits Over the Previous Approach

- **Simplified Architecture**: Reduces complexity by focusing on formats rather than transformations
- **Automatic Detection**: Format detection works out of the box based on file extensions
- **Dynamic Conversions**: Conversions can be created on demand rather than pre-defined
- **Extensibility**: New formats can be added without modifying existing code
- **Maintainability**: Clearer separation of concerns between format definitions and processing logic
```

---

### TRANSFORMER_COMPARISON.md

**Path:** scripts/deployment/enhanced-variant-generator/TRANSFORMER_COMPARISON.md

```markdown
# AST vs Text-Based Transformer Comparison

This document summarizes the key differences between AST-based and text-based code transformation approaches in the HEICFlip variant generator.

## Overview

The transformer system supports two modes of operation:

1. **AST-based transformation**: Uses Babel's Abstract Syntax Tree parsing to understand code structure
2. **Text-based transformation**: Uses regex-based string replacement for simpler but less precise transformations

## Comparative Analysis

| Aspect | AST-Based Transformer | Text-Based Transformer |
|--------|----------------------|------------------------|
| **Transformation Rate** | ~56% (more selective) | ~100% (more comprehensive) |
| **Context Preservation** | High | Low |
| **Parameter Handling** | Preserves parameter names | May transform parameter names incorrectly |
| **String Replacement** | Only in string contexts | In all contexts |
| **Template Literals** | Limited handling | Full replacement |
| **Error Handling** | May fail on complex syntax | More resilient to syntax errors |
| **Performance** | Slower (parsing overhead) | Faster (direct replacement) |

## Specific Strengths

### AST-Based Transformer

✓ **Context-aware**: Understands code structure and only transforms appropriate elements
✓ **Scope-sensitive**: Preserves variables in parameter scope 
✓ **Structure-preserving**: Maintains code structure and formatting
✓ **Selective transformation**: Avoids incorrect transformations in sensitive contexts

### Text-Based Transformer

✓ **Comprehensive**: Transforms all occurrences of target strings
✓ **Resilient**: Works even with invalid or complex code structures
✓ **Fast**: No parsing overhead
✓ **Template handling**: Better at transforming template literal content

## Current Limitations

### AST-Based Transformer

- Limited transformation of template literals
- Doesn't transform some object properties consistently
- May fail to parse some complex syntax patterns
- Error code strings are sometimes incorrectly transformed

### Text-Based Transformer

- Transforms parameter names inappropriately
- Doesn't respect variable scoping
- Context-insensitive replacements can cause errors
- May transform reserved words or constants that should be preserved

## When to Use Each Approach

- **AST-based transformer**: For production-quality transformations where context preservation is critical
- **Text-based transformer**: For quick prototyping or when AST parsing fails

## Hybrid Approach Benefits

The system uses a hybrid approach that:

1. Attempts AST-based transformation first for precision
2. Falls back to text-based transformation if parsing fails
3. Provides detailed statistics about the transformation process

This approach combines the context-awareness of AST with the resilience of text-based replacement.

## Test Results

Test results consistently show that:

- AST transformation preserves ~8-14 HEIC/JPG occurrences in appropriate contexts
- Text transformation replaces all HEIC/JPG occurrences regardless of context
- Both approaches successfully transform most format references
- AST excels at context preservation, text excels at comprehensive replacement

## Recommendation

For most use cases, the hybrid approach provides the best balance of precision and completeness. Users can explicitly set the transformer mode based on their specific needs.```

---

### README.md

**Path:** scripts/deployment/enhanced-variant-generator/README.md

```markdown
# HEICFlip Format Transformation System

## Overview

The Format Transformation System is a sophisticated architecture for working with different file formats, enabling loading, transforming, and saving files with a consistent interface. Inspired by the Python Imaging Library (PIL), this system allows for seamless conversion between formats while also supporting visual identity transformations for different variant sites.

## Key Features

1. **Format Detection**: Automatic detection of file formats based on extensions
2. **Open/Save Architecture**: PIL-inspired approach to loading and saving files
3. **Visual Identity**: Consistent theming system for different formats
4. **Dynamic Registration**: Runtime registration of new formats and converters
5. **Variant Generation**: Ability to transform between different format pairs
6. **Theming Transformation**: Automatic adjustment of visual identities when switching variants

## System Architecture

The system is organized into several layers:

### Registry Layer

- **Format Registry**: Centralized storage of all format definitions and converters
- **Visual Identity Registry**: Stores visual styling elements for each format and conversion
- **Format Manager**: Manages the registration and retrieval of formats and converters

### Loader Layer

- **BaseLoader**: Abstract class implementing common functionality for all loaders
- **ILoader Interface**: Defines the contract for format loaders
- **Format-Specific Loaders**: Concrete implementations for each supported format (HEIC, JPEG, etc.)

### Transformer Layer

- **Internal Representation**: Common data structure for representing loaded files
- **Color Transformation**: Utilities for adjusting visual identities
- **Format Adaptation**: Adjustments needed for specific format conversions

### Encoder Layer

- **BaseEncoder**: Abstract class implementing common functionality for all encoders
- **IEncoder Interface**: Defines the contract for format encoders
- **Format-Specific Encoders**: Concrete implementations for each supported format

### Output Layer

- **File Output**: Mechanisms for saving to files
- **Blob Output**: Utilities for creating blobs and handling downloads

## Format Registry

The Format Registry is the central hub for managing supported formats and conversions:

```typescript
export interface Format {
  key: string;         // Unique identifier (e.g., 'heic')
  name: string;        // Display name (e.g., 'HEIC')
  extensions: string[]; // File extensions (e.g., ['.heic', '.heif'])
  mimeTypes: string[]; // MIME types (e.g., ['image/heic'])
  description: string; // Human-readable description
  loader?: any;        // Reference to loader implementation
  encoder?: any;       // Reference to encoder implementation
}

export interface Converter {
  key: string;         // Unique identifier (e.g., 'heicToJpg')
  source: string;      // Source format key
  target: string;      // Target format key
  name: string;        // Display name
  description: string; // Human-readable description
  strategies: string[]; // Available conversion strategies
  defaultStrategy: string; // Default strategy to use
}
```

## Visual Identity System

Each format and conversion has an associated visual identity:

```typescript
export interface FormatVisualIdentity {
  formatKey: string;       // Format this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for format-specific elements
  iconShape: 'circle' | 'square' | 'rounded' | 'diamond'; // Icon shape
}

export interface ConversionVisualIdentity {
  conversionKey: string;   // Conversion this identity belongs to
  primaryColor: string;    // Primary brand color
  secondaryColor: string;  // Secondary/darker variation
  accentColor: string;     // Accent/lighter variation
  cssPrefix: string;       // CSS class prefix for styling
  dataAttribute: string;   // Data attribute for conversion-specific elements
  gradient: string;        // Gradient using source and target colors
}
```

## Loader and Encoder System

The system uses a loader/encoder architecture for handling different formats:

### Loaders

Loaders are responsible for decoding file formats into an internal representation:

```typescript
export interface ILoader {
  supportedFormats: string[];
  load(source: any, options?: any): Promise<any>;
  canLoad(source: any): boolean;
  getInfo?(source: any): Promise<any>;
}
```

### Encoders

Encoders are responsible for encoding the internal representation into a specific file format:

```typescript
export interface IEncoder {
  supportedFormats: string[];
  encode(data: any, options?: any): Promise<any>;
  defaultOptions: Record<string, any>;
}
```

## Format Manager

The Format Manager provides a high-level API for working with formats and conversions:

```typescript
export class FormatManager {
  // Load a file from a source
  async open(source: any, formatHint?: string): Promise<any>;
  
  // Save data to a specific format
  async save(data: any, format: string, options?: any): Promise<any>;
  
  // Convert data from one format to another
  async convert(source: any, targetFormat: string, options?: any): Promise<any>;
  
  // Register a loader for a format
  registerLoader(formatKey: string, loader: any): void;
  
  // Register an encoder for a format
  registerEncoder(formatKey: string, encoder: any): void;
}
```

## Variant Generation

The Variant Generation system allows for transforming sites between different format pairs:

```typescript
interface TransformationConfig {
  sourceSourceFormat: string;  // Current source format (e.g., 'heic')
  sourceTargetFormat: string;  // Current target format (e.g., 'jpg')
  targetSourceFormat: string;  // New source format (e.g., 'png')
  targetTargetFormat: string;  // New target format (e.g., 'webp')
  inputDir: string;           // Directory containing the original site
  outputDir: string;          // Directory to write the transformed site
}

export async function transformSite(config: TransformationConfig): Promise<void>;
```

This process includes:

1. Identifying color transformations between formats
2. Updating CSS variables and selectors
3. Replacing format names in text content
4. Updating visual assets to match the new formats

## Usage Example

```typescript
// Detect format from file extension
const format = detectFormatFromExtension('image.heic'); // Returns 'heic'

// Load a HEIC file
const imageData = await formatManager.open('image.heic');

// Save as JPEG
const jpegBlob = await formatManager.save(imageData, 'jpg', { quality: 90 });

// Direct conversion
const jpegBlob = await formatManager.convert('image.heic', 'jpg', { quality: 90 });

// Transform a site from HEIC→JPG to WebP→PNG
const config = {
  sourceSourceFormat: 'heic',
  sourceTargetFormat: 'jpg',
  targetSourceFormat: 'webp',
  targetTargetFormat: 'png',
  inputDir: './original-site',
  outputDir: './transformed-site'
};
await transformSite(config);
```

## Visual Identity Transformation

The system enables transformation between different format pairs, including visual identity changes:

- **HEIC** (Orange) ↔ **JPG** (Blue)
- **HEIC** (Orange) ↔ **WebP** (Purple)
- **WebP** (Purple) ↔ **PNG** (Green)
- **AVI** (Red) ↔ **MP4** (Teal)

This allows for generating different variants of the same site with consistent branding for each format pair.

## Extending the System

To add support for a new format:

1. Add the format definition to the registry
2. Create a loader implementation
3. Create an encoder implementation
4. Add visual identity for the format
5. Register with the format manager

```typescript
// Add format to registry
registry.formats.avif = {
  key: 'avif',
  name: 'AVIF',
  extensions: ['.avif'],
  mimeTypes: ['image/avif'],
  description: 'AV1 Image File Format with excellent compression',
};

// Create and register loader
const avifLoader = new AvifLoader();
formatManager.registerLoader('avif', avifLoader);

// Create and register encoder
const avifEncoder = new AvifEncoder();
formatManager.registerEncoder('avif', avifEncoder);

// Add visual identity
visualIdentityRegistry.formats.avif = {
  formatKey: 'avif',
  primaryColor: '#6A5ACD', // Slate blue
  secondaryColor: '#5A4ABD',
  accentColor: '#8A7AED',
  cssPrefix: 'avif',
  dataAttribute: 'data-format-avif',
  iconShape: 'diamond',
};
```

## Conclusion

The Format Transformation System provides a robust and extensible framework for working with different file formats and creating variant sites. By using a consistent loader/encoder architecture and a well-defined visual identity system, it enables seamless transformation between different format pairs while maintaining consistent branding and styling.```

---

## Miscellaneous Documentation

### VERSION_CONTROL.md

**Path:** /Users/cameronbrooks/Downloads/FlipMyFIle/VERSION_CONTROL.md

```markdown
# Version Control System for FormatFlip

This document explains how to use the version control system for the FormatFlip project.

## Version Control Options

### 1. Replit Native Version Control

Replit provides a built-in version control system through its interface:

- Click on the "Version Control" tab in the left sidebar
- Use "Create Checkpoint" to save the current state of your project
- View history and restore previous checkpoints as needed

### 2. Custom Version Management Scripts

The project includes custom scripts for version management:

#### Creating a Version

```bash
bash scripts/create_version.sh "Description of this version"
```

This will create a timestamped version in the `versions/` directory with your provided description.

#### Listing Available Versions

```bash
bash scripts/list_versions.sh
```

This will show all available versions with their timestamps and descriptions.

#### Restoring a Version

```bash
bash scripts/restore_version.sh "versions/version_YYYYMMDD_HHMMSS"
```

This will restore the specified version while creating a backup of the current state.

### 3. GitHub Integration

For GitHub integration:

1. Use Replit's GitHub integration from the Version Control tab
2. Connect to your GitHub repository
3. Push changes directly to GitHub

## Best Practices

1. Create versions before making significant changes
2. Use descriptive messages for each version
3. Regularly push to GitHub for offsite backup
4. Keep the `versions/` directory organized by removing old versions when no longer needed
```

---

### [HEICFLIP-500]_converter_variants.md

**Path:** meta/variants/[HEICFLIP-500]_converter_variants.md

```markdown
# Converter Variants Configuration Guide

This document tracks all converter variants and their configurations. Use this as a reference when creating new deployments.

## Current Variants

### HEICFlip
- **Primary conversion**: HEIC to JPG
- **Domain**: heicflip.com
- **Config**:
  ```json
  {
    "siteName": "HEICFlip",
    "defaultConversionMode": "heicToJpg",
    "primaryColor": "#DD7230",
    "secondaryColor": "#B85A25", 
    "accentColor": "#F39C6B",
    "logoText": "HEICFlip",
    "domain": "heicflip.com"
  }
  ```

### JPGFlip
- **Primary conversion**: JPG to HEIC
- **Domain**: jpgflip.com
- **Config**:
  ```json
  {
    "siteName": "JPGFlip",
    "defaultConversionMode": "jpgToHeic",
    "primaryColor": "#3066BE",
    "secondaryColor": "#1E5693",
    "accentColor": "#5D89D0",
    "logoText": "JPGFlip",
    "domain": "jpgflip.com"
  }
  ```

### AVIFlip
- **Primary conversion**: AVI to MP4
- **Domain**: aviflip.com
- **Config**:
  ```json
  {
    "siteName": "AVIFlip",
    "defaultConversionMode": "aviToMp4",
    "primaryColor": "#119DA4",
    "secondaryColor": "#0D7A7F",
    "accentColor": "#3CBFC5",
    "logoText": "AVIFlip",
    "domain": "aviflip.com"
  }
  ```

## How to Add a New Variant

1. Add a new configuration object to `client/src/config.ts`
2. Update the `getSiteConfig()` function to detect the new domain
3. Add the configuration details to this document
4. Create a new repository following the deployment guide

## Required Files for Each Deployment

- All core application code
- Updated configuration for the specific variant
- Domain-specific assets (if any)
- Deployment configuration (vercel.json, etc.)

---

Last updated: April 30, 2025```

---

### [HEICFLIP-912]_backup_documentation.md

**Path:** meta/backup-system/[HEICFLIP-912]_backup_documentation.md

```markdown
# HEICFlip Backup System

This document describes the backup and restore system for the HEICFlip project, designed to provide a safety net during development and experimentation.

## Overview

The backup system creates point-in-time snapshots of the project in the `restore_point` directory, allowing developers to revert to a known good state if something goes wrong.

## Key Features

- **Reliable Path Resolution**: Uses absolute paths based on script location, ensuring scripts work regardless of the current working directory.
- **Selective Backup**: Excludes large directories like `node_modules` to keep backups efficient.
- **Timestamp Tracking**: Each backup includes a timestamp for easy identification.
- **Safety Confirmations**: Restore operations require explicit confirmation to prevent accidental data loss.
- **Preservation of Critical Data**: Handles .git directory and other essential metadata appropriately.

## Usage

### Creating a Backup

To create a backup of the current project state:

```bash
./save_current_version.sh
```

This will:
1. Create a backup in the `restore_point` directory
2. Generate a timestamp file with the backup date/time
3. Exclude large directories like `node_modules`

### Restoring from Backup

To restore the project to the previously saved state:

```bash
./restore_from_save.sh
```

This will:
1. Prompt for confirmation before proceeding
2. Restore all files from the backup
3. Preserve important directories like `.git` and `node_modules`

## File Structure

```
├── save_current_version.sh     # Root-level script for easy access
├── restore_from_save.sh        # Root-level script for easy access
├── meta/
│   └── tools/
│       └── backup/
│           ├── [HEICFLIP-910]_save_version.sh    # Main backup implementation
│           └── [HEICFLIP-911]_restore_version.sh # Main restore implementation
└── restore_point/              # Backup storage location
    └── SAVE_TIMESTAMP.txt      # Records when the backup was created
```

## Implementation Details

### Backup Process

The backup script:
1. Determines the project root directory using path resolution
2. Creates a timestamp for the backup
3. Sets up a list of directories/files to exclude
4. Uses `rsync` to efficiently copy files to the backup location

### Restore Process

The restore script:
1. Verifies that a valid backup exists
2. Gets the timestamp of the backup
3. Prompts for confirmation
4. Uses `rsync` to copy files from the backup location to the project directory

## Best Practices

- Create backups before making major changes to the codebase
- Create backups before trying experimental features
- Create backups before upgrading dependencies
- Use descriptive names for manual backups (via the timestamp file)

## Future Improvements

- Multiple backup slots
- Automatic periodic backups
- Backup compression
- Cloud backup integration

## Troubleshooting

If you encounter issues with the backup system:

1. Ensure all scripts have execute permissions: `chmod +x *.sh`
2. Check that the required directories exist
3. Verify that `rsync` is installed in your environment
4. Check available disk space if backups are failing

For persistent issues, you can manually create backups by copying the relevant files.```

---

### [HEICFLIP-800]_ad_monetization_guide.md

**Path:** meta/monetization/[HEICFLIP-800]_ad_monetization_guide.md

```markdown
# Ad Monetization Guide for Converter Sites

This guide covers strategies for monetizing your converter websites with advertisements, focusing on platforms that work well for tools with brief but frequent user visits.

## Top Advertising Platforms for Converter Tools

### 1. Google AdSense
**Best for:** General audience, highest coverage, easiest to get started.  
**Requirements:**
- Website with original content
- Follow Google's program policies
- No prohibited content
- Active for at least 6 months (recommended)

**Implementation Process:**
1. Apply for AdSense account
2. Place ad code on your site
3. Create ad units
4. Test and optimize placement

### 2. Ezoic
**Best for:** Small to medium sites looking to optimize ad revenue.  
**Advantages:**
- AI-driven ad testing
- Higher RPMs than AdSense in many cases
- Integrated site speed tools
- Mediation layer (can include AdSense and other ad networks)

**Requirements:**
- 10,000+ monthly visits (though they have a program for smaller sites)
- Quality content
- Compliance with policies

### 3. Media.net
**Best for:** Contextual ads, good alternative to Google.  
**Advantages:**
- Yahoo/Bing ads network
- Contextual targeting
- Clean, professional ads
- Good for tech-focused audience

### 4. Carbon Ads
**Best for:** Developer tools and tech audience.  
**Advantages:**
- High-quality, curated ads
- Single, non-intrusive ad per page
- Higher-than-average payouts
- Tech-focused advertising

## Recommended Ad Placements for Converter Tools

For tools like HEICFlip, JPGFlip, and other converters:

1. **Banner above the converter** (high visibility, non-intrusive)
2. **Sidebar ads** (visible during the conversion process)
3. **In-between steps** ad (shown between upload and download)
4. **Footer banner** (less intrusive)
5. **Post-conversion interstitial** (shown after successful conversion)

## Monorepo Implementation Strategy for Ads

### Core Ad Components

Create reusable ad components in the core package:

```typescript
// packages/core/src/ui/components/ads/AdUnit.tsx
import React from 'react';

export interface AdUnitProps {
  adSlot: string;
  adFormat: 'banner' | 'rectangle' | 'leaderboard' | 'interstitial';
  className?: string;
}

export const AdUnit: React.FC<AdUnitProps> = ({ 
  adSlot, 
  adFormat, 
  className = '' 
}) => {
  // Implementation depends on the ad network
  // This is a placeholder for Google AdSense
  return (
    <div className={`ad-container ${adFormat} ${className}`}>
      <ins
        className="adsbygoogle"
        style={{ display: 'block' }}
        data-ad-client="ca-pub-XXXXXXXXXXXXXXXX" // Replace with your AdSense ID
        data-ad-slot={adSlot}
        data-ad-format={adFormat}
        data-full-width-responsive="true"
      ></ins>
    </div>
  );
};
```

### Ad Configuration by Variant

Each variant can have its own ad configuration:

```typescript
// packages/heicflip/src/config/ads.ts
export const adConfig = {
  enabled: true,
  provider: 'adsense', // or 'ezoic', 'media.net', 'carbon'
  slots: {
    header: '1234567890',
    sidebar: '0987654321',
    footer: '1122334455',
    postConversion: '5566778899'
  },
  // For non-AdSense networks
  customScript: ''
};
```

### Ad Initialization

Handle ad initialization in the core package:

```typescript
// packages/core/src/utils/ads.ts
export type AdProvider = 'adsense' | 'ezoic' | 'media.net' | 'carbon';

export interface AdConfig {
  enabled: boolean;
  provider: AdProvider;
  slots: Record<string, string>;
  customScript?: string;
}

export function initializeAds(config: AdConfig): void {
  if (!config.enabled) return;
  
  switch (config.provider) {
    case 'adsense':
      // Load AdSense script
      const script = document.createElement('script');
      script.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js';
      script.async = true;
      script.setAttribute('data-ad-client', `ca-pub-XXXXXXXXXXXXXXXX`); // Your AdSense ID
      document.head.appendChild(script);
      break;
    
    // Add other providers
    case 'ezoic':
      // Ezoic specific initialization
      break;
    
    case 'media.net':
      // Media.net specific initialization
      break;
    
    case 'carbon':
      // Carbon ads specific initialization
      break;
  }
}
```

## Set Up Requirements for Each Ad Network

### Google AdSense

1. **Domain Setup:**
   - Verify domain ownership
   - Add DNS TXT record
   - Have a privacy policy page
   - Add `ads.txt` file to root of domain

2. **Code Integration:**
   ```html
   <!-- Add to <head> once approved -->
   <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX"></script>
   ```

### Ezoic

1. **Site Integration:**
   - Integrate via Cloudflare
   - Add DNS records
   - Install Chrome extension for verification

2. **Placeholder Setup:**
   ```html
   <!-- Create ad placeholders -->
   <div class="ezoic-ad box-1" data-ez-name="heicflip_header"></div>
   ```

## Ad Performance Optimization

For tools like HEICFlip, optimize for quick, task-based visits:

1. **Lazy load ads** after conversion process starts
2. **Prioritize non-disruptive placements**
3. **Test interstitial ads** after conversion completes  
4. **Implement sticky ads** that stay visible during conversion
5. **A/B test different ad networks** on different variants

## Ad-Related Considerations in Monorepo

1. **Environment-Specific Ads:**
   ```typescript
   // Enable ads only in production
   const adsEnabled = import.meta.env.PROD ? true : false;
   ```

2. **Variant-Specific Ad Units:**
   Each variant can have custom ad unit IDs and placements while sharing the core ad components.

3. **Ad Analytics Integration:**
   Include analytics to track ad performance across variants.

## Compliance Requirements

All ad implementations must include:

1. **Cookie consent banner** (for EU/GDPR compliance)
2. **Privacy policy** detailing ad usage
3. **Proper ads.txt file** for each domain
4. **Responsive ad units** that work on all devices

## Recommended Implementation Timeline

1. **Phase 1:** Set up architecture for ads in monorepo
2. **Phase 2:** Apply for ad networks (start with AdSense)
3. **Phase 3:** Implement non-intrusive placeholder ads
4. **Phase 4:** Once approved, replace with live ads
5. **Phase 5:** Optimize ad placement and test alternatives

---

Last updated: April 30, 2025```

---

### PULL_REQUEST_TEMPLATE.md

**Path:** .github/PULL_REQUEST_TEMPLATE.md

```markdown
## Description

<!-- Describe the changes introduced by this PR -->

## Related Issues

<!-- Link to related issues or features -->

## Type of Change

- [ ] Bug fix (non-breaking change fixing an issue)
- [ ] New feature (non-breaking change adding functionality)
- [ ] Breaking change (fix or feature causing existing functionality to change)
- [ ] Documentation update

## Testing

<!-- Describe the testing you have performed -->

## Checklist

- [ ] My code follows the code style of this project
- [ ] I have reviewed my own code before submitting
- [ ] I have added tests that prove my fix/feature works
- [ ] All new and existing tests pass
- [ ] I have updated documentation if needed
- [ ] The commit message follows our guidelines
```

---

### deploy_opus_guide.md

**Path:** /Users/cameronbrooks/Downloads/FlipMyFIle/deploy_opus_guide.md

```markdown
# OpusFlip Deployment Guide

This guide explains how to deploy the OpusFlip web application to Vercel.

## What's Included

The `deploy_opus` directory contains everything needed for a successful deployment:

1. **index.html** - The OpusFlip web application 
2. **vercel.json** - Configuration file for Vercel deployment
3. **FFmpeg files** - Core WebAssembly files needed for audio conversion:
   - ffmpeg-core.js
   - ffmpeg-core.wasm
   - ffmpeg-core.worker.js
   - ffmpeg.min.js

## Deployment Steps

### Option 1: Using Vercel CLI

1. Install Vercel CLI if you haven't already:
   ```bash
   npm install -g vercel
   ```

2. Navigate to the deploy_opus directory:
   ```bash
   cd ~/Downloads/FlipMyFIle/deploy_opus
   ```

3. Deploy to Vercel:
   ```bash
   vercel deploy --prod
   ```

4. Follow the prompts to complete the deployment.

### Option 2: Using Vercel Dashboard

1. Zip the deploy_opus directory:
   ```bash
   cd ~/Downloads/FlipMyFIle
   zip -r deploy_opus.zip deploy_opus
   ```

2. Go to [vercel.com](https://vercel.com) and log in to your account.

3. Create a new project and upload the zip file.

4. Deploy the project.

## Verification Steps

After deployment, verify:

1. The site loads correctly
2. CORS headers are set properly (check browser console)
3. FFmpeg files are accessible

## Troubleshooting

### CORS Issues

If you see errors related to SharedArrayBuffer or cross-origin isolation:

1. Check that the proper headers are being set:
   - Cross-Origin-Opener-Policy: same-origin
   - Cross-Origin-Embedder-Policy: require-corp

2. Verify these headers are applied to all routes using browser dev tools:
   ```
   curl -I https://your-deployment-url.vercel.app
   ```

### FFmpeg Loading Errors

If FFmpeg fails to load:

1. Check that all FFmpeg files are accessible at the root path
2. Verify the Content-Type header is set correctly for .wasm files

## Customizing the Application

To customize the OpusFlip application:

1. Edit the HTML in `deploy_opus/index.html`
2. Update styling in the CSS section
3. Modify the JavaScript for better functionality```

---

### content-1745540097810.md

**Path:** attached_assets/content-1745540097810.md

```markdown
# The Cloudflare dashboard is loading.

![Company Logo](https://dash.cloudflare.com/static/vendor/onetrust/oneTrust_production/consent/bbd9e347-d67f-48f1-bdc2-682831c03425/018debfb-4917-76f1-8862-8a2f83812baa/logos/6b10d640-dc80-4fbf-a462-ae81dbad56e4/8596cb00-a06f-4131-bbaa-509b45573acf/3a070200-a811-4c47-88b4-f35732a17771/Logo.png)

Your Opt Out Preference Signal is Honored

- ### Your Privacy Choices

- ### Advertising and Marketing Cookies

- ### Functional Cookies

- ### Strictly Necessary Cookies


#### Your Privacy Choices

Depending on your state of residence, including if you are a California resident, you have the right to opt out of certain sharing of personal information with third-party ad partners. We may share personal information with third-party ad partners, such as through cookies or by providing lists of email addresses for potential customers, so that we can reach them across the web with relevant ads.

We also use Strictly Necessary Cookies that are essential for delivering our website experience to you safely and securely, and we use “Functional Cookies” that help the website work better for you (e.g., remember your login information or language preferences). You can opt out of Functional Cookies.

In addition, we may also provide these marketing and advertising partners with your email address or other limited account information. You may opt out of such sharing by emailing us at sar@cloudflare.com.

To learn more about the cookies we use on our site, please read our Cookie Policy.



[Cloudflare's Cookie Policy](https://www.cloudflare.com/cookie-policy/)

#### Advertising and Marketing Cookies

Advertising and Marketing Cookies

Like many companies, Cloudflare uses services that help deliver interest-based ads to you and may transfer Personal Information to business partners for their use, including via advertising and marketing cookies. Making Personal Information (such as online identifiers or browsing activity) available to these companies may be considered a “sale” or “sharing” of your Personal Information under the CCPA or another U.S. state privacy law. Cloudflare does not sell your Personal Information in the conventional sense (i.e., for money).

You can request to opt out of these cookies by toggling OFF the option to allow “Advertising and Marketing Cookies” above.

- ##### Targeting Cookies




Switch Label



We use Targeting cookies to deliver advertisements relevant to you and your interests when you visit other websites that host advertisements.


- ##### Performance Cookies




Switch Label



Performance cookies help us learn how you use our website to help improve its performance and design. These cookies provide us with aggregated statistical information such as number of page visits, page load speeds, how long a user spends on a particular page, and the types of browsers or devices used to access our site.


Cookies Details‎

#### Functional Cookies

Functional Cookies

Functional cookies allow us to remember choices you make about the kind of experience you want on our site and to provide you with a more personalized experience. For example, a functional cookie is required to remember which language you prefer.

Cookies Details‎

#### Strictly Necessary Cookies

Always Active

Strictly Necessary cookies are essential to our website functioning as expected. You cannot turn off Strictly Necessary cookies because they are required to deliver security, enable core site functionality, and help you use our site's features and services as you would expect (including remembering your cookie consent preferences). Cloudflare does not use these cookies to track individuals across websites.

Cookies Details‎

Back Button

### Cookie List

Filter Button

ConsentLeg.Interest

checkbox labellabel

checkbox labellabel

checkbox labellabel

Clear

checkbox labellabel

ApplyCancel

Confirm My Choices

Reject All But Necessary

[![Powered by Onetrust](https://dash.cloudflare.com/static/vendor/onetrust/oneTrust_production/consent/bbd9e347-d67f-48f1-bdc2-682831c03425/018debfb-4917-76f1-8862-8a2f83812baa/logos/static/powered_by_logo.svg)](https://www.onetrust.com/products/cookie-consent/)```

---

